{"meta":{"title":"Hu","subtitle":"","description":"Welcome!","author":"Hu","url":"https://humancloud.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-04-05T05:10:56.000Z","updated":"2020-04-05T05:13:47.982Z","comments":true,"path":"categories/index.html","permalink":"https://humancloud.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-05T05:10:45.000Z","updated":"2020-04-05T05:14:19.486Z","comments":true,"path":"tags/index.html","permalink":"https://humancloud.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git基础总结","slug":"Git基础总结","date":"2020-11-03T08:19:45.000Z","updated":"2020-11-03T08:24:18.699Z","comments":true,"path":"2020/11/03/Git基础总结/","link":"","permalink":"https://humancloud.github.io/2020/11/03/Git%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/","excerpt":"前言Git基础使用: 基础命令(修改,远程操作),分支合并,解决冲突,标签","text":"前言Git基础使用: 基础命令(修改,远程操作),分支合并,解决冲突,标签 1.基础操作 12345678910111213141516171819202122232425工作区: 电脑里能看到的目录暂存区: 英文为stage或index,一般存放在.git目录下的index文件(.git&#x2F;index)中,所以我们把暂存区有时也叫作索引index版本库(仓库区): 工作区有一个隐藏目录.git,这个不算工作区,而是Git的版本库图中左侧为工作区，右侧为版本库。在版本库中标记为 &quot;index&quot; 的区域是暂存区（stage&#x2F;index），标记为 &quot;master&quot; 的是 master 分支所代表的目录树。图中我们可以看出此时 &quot;HEAD&quot; 实际是指向 master 分支的一个&quot;游标&quot;。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。图中的 objects 标识的区域为 Git 的对象库，实际位于 &quot;.git&#x2F;objects&quot; 目录下，里面包含了创建的各种对象及内容。当对工作区修改（或新增）的文件执行 git add 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。当执行 git rm --cached &lt;file&gt; 命令时，会直接从暂存区删除文件，工作区则不做出改变。当执行 git checkout . 或者 git checkout -- &lt;file&gt; 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。当执行 git checkout HEAD . 或者 git checkout HEAD &lt;file&gt; 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 1. 1 最简单使用12345678910111213git config --global user.name &#39;humancloud&#39;git config --global user.email &#39;humancloud@126.com&#39;git init 版本区建立(创建.git文件)git add . 把工作区所有文件提交到版本区里的暂存区git commit -m &quot;xxx&quot; 暂存区所以文件提交到仓库区(暂存区空)git remote add origin xxxxxx.git 把本地仓库与远程仓库连接起来git push -u origin master 把仓库区文件提交到远程仓库里(将本地的master分支推送到origin主机,同时指定origin为默认主机))平常:git add .git commit -m &quot;regular&quot;git push -u origin master 最简单操作 123456789101112131415161718192021➜ calculator git:(master) ✗ git add a.c 添加到暂存区➜ calculator git:(master) ✗ git commit -m &quot;first&quot; 将文件从暂存区提交到仓库➜ calculator git:(master) ✗ git remote add origin https:&#x2F;&#x2F;github.com&#x2F;humancloud&#x2F;c.git &#x2F;&#x2F;将本地仓库同步到远程仓库➜ calculator git:(master) ✗ git push -u origin master Username for &#39;https:&#x2F;&#x2F;github.com&#39;: humancloudPassword for &#39;https:&#x2F;&#x2F;humancloud@github.com&#39;: 对象计数中: 5, 完成.Delta compression using up to 8 threads.压缩对象中: 100% (2&#x2F;2), 完成.写入对象中: 100% (5&#x2F;5), 1.72 KiB | 1.72 MiB&#x2F;s, 完成.Total 5 (delta 0), reused 0 (delta 0)To https:&#x2F;&#x2F;github.com&#x2F;humancloud&#x2F;c.git * [new branch] master -&gt; master分支 &#39;master&#39; 设置为跟踪来自 &#39;origin&#39; 的远程分支 &#39;master&#39;。➜ calculator git:(master) ✗ ➜ calculator git:(master) ✗ git rm -r . &#x2F;&#x2F;删除暂存区和工作区(本地的文件哦)的文件➜ calculator git:(master) ✗ git commit -m &quot;xxx&quot; &#x2F;&#x2F;提交修改➜ calculator git:(master) ✗ git push -u origin master &#x2F;&#x2F;提交修改到远程仓库执行此三条后远程仓库和本地所有都被删除,要想不删除本地的,执行这个➜ calculator git:(master) ✗ git rm --cache . &#x2F;&#x2F;只会删除暂存区的,不会删除工作区 1234Git 常用的是以下 6 个命令：git clone、git push、git add 、git commit、git checkout、git pull➜ calculator git:(master) ✗ git status 查看状态 1.2 创建仓库init 1git init 命用于在目录中创建新的 Git 仓库。 clone 1➜ calculator git:(master) ✗ git clone 拷贝一个远程仓库,将复制该项目的所有记录 1.3 提交与修改add 1234567添加文件到仓库git add [file1] [file2] ...git add [dir]git add . 添加当前目录所有文件到暂存区 status 1git status 命令用于查看在你上次提交之后是否有对文件进行再次修改。显示有变更的文件 diff 1234567891011121314比较文件的不同,即暂存区和工作区的差异显示暂存区和工作区的差异:$ git diff [file]显示暂存区和上一次提交(commit)的差异:$ git diff --cached [file]或$ git diff --staged [file]显示两次提交之间的差异:$ git diff [first-branch]...[second-branch] commit 123456提交暂存区到本地仓库git commit -m &quot;有用的信息每次都不一样&quot;git commit [file1] [file2] -m &quot;xxxxxx&quot; reset 12345678910111213141516171819202122232425262728293031git reset [HEAD] 回溯版本--mixed 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。--soft 参数用于回退到某个版本：--hard 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交：撤销版本库的修改(暂存区,工作区不变): git reset --soft [HEAD]撤销版本库和暂存区不修改工作区: git reset --mixed [HEAD]将工作区,暂存区,版本库恢复到指定的版本:git reset --hard [HEAD]HEAD 表示当前版本HEAD^ 上一个版本HEAD^^ 上上一个版本HEAD^^^ 上上上一个版本以此类推...可以使用 ～数字表示HEAD~0 表示当前版本HEAD~1 上一个版本HEAD^2 上上一个版本HEAD^3 上上上一个版本以此类推... rm 123456789101、将文件从暂存区和工作区中删除：git rm &lt;file&gt;如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f。强行从暂存区和工作区中删除修改后的 runoob.txt 文件：git rm -f runoob.txt 如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可：git rm --cached &lt;file&gt; mv 1234567git mv 命令用于移动或重命名一个文件、目录或软连接。(操作暂存区)git mv [file] [newfile]如果新文件名已经存在，但还是要重命名它，可以使用 -f 参数：git mv -f [file] [newfile] checkout 123456789git checkout（1）.切换或者新建分支。（2）.将暂存区或者指定commit内容覆盖到工作区。➜ calculator git:(master) ✗ git checkout --file 用版本区的版本替换工作区的版本 1.2 日志12345678910111213141516171819git log这个最上面的是最近的提交,这串数字就是版本库IDcommit d2c6f0ca1e7c075692c55870f4166b1e297dfcea (HEAD -&gt; master)Author: humancloud &lt;humancloud@126.com&gt;Date: Sat May 2 19:05:43 2020 +0800 regular git log --author&#x3D;xxx 查找指定用户的提交日志git blame &lt;file&gt; 查看指定文件的修改纪录我们可以用 --oneline 选项来查看历史记录的简洁的版本还可以用 --graph 选项，查看历史中什么时候出现了分支、合并也可以用 --reverse 参数来逆向显示所有日志。 1.3 远程操作remote 123456789101112remote常用的origin是远程仓库的别名[name],可以使用任何名字➜ calculator git:(master) ✗ git remote -v 查看远程仓库➜ calculator git:(master) ✗ git remote add [name] [url] 添加远程仓库(github和gitee一个本地可以有几个远程仓库)➜ calculator git:(master) ✗ git remote show https:&#x2F;&#x2F;github.com&#x2F;tian&#x2F;runoob 显示仓库信息➜ calculator git:(master) ✗ git remote set-url --push [name] [new url] 修改远程仓库 ➜ calculator git:(master) ✗ git remote rm [name] 删除远程仓库➜ calculator git:(master) ✗ git remote rename oldname newname 修改仓库名➜ calculator git:(master) ✗ git push -u [name] [branch] &#x2F;&#x2F;向[name]这个仓库的[branch]分支push fentch 1234567891011121314git fetch 命令用于从远程获取代码库。该命令执行完后需要执行 git merge 远程分支到你所在的分支。从远端仓库提取数据并尝试合并到当前分支：假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行:git fetch [name] &#x2F;&#x2F;name是仓库别名,这条命令告诉 Git 去获取它有你没有的数据，然后你可以执行git merge [name] [branch]例如 git merge origin master &#x2F;&#x2F;从origin仓库下载更新合并到我的master分支以上命令将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。 pull 12345678910111213141516git pull 命用于从远程获取代码并合并本地的版本。git pull 其实就是 git fetch 和 git merge FETCH_HEAD 的简写更新操作：$ git pull 把最新的提交从远程仓库抓取下来,在本地合并,克隆下项目来,如果想要更新项目,直接git pull 把最新的项目拉下来,即可.$ git pull origin将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。$ git pull origin master:brantest如果远程分支是与当前分支合并，则冒号后面的部分可以省略。$ git pull origin master push 12345678910111213141516git push 命用于从将本地的分支版本上传到远程并合并。以下命令将本地的 master 分支推送到 origin 主机的 master 分支。$ git push origin master相等于：$ git push origin master:master如果本地版本与远程版本有差异，但又要强制推送可以使用 --force 参数：git push --force origin master删除主机分支可以使用 --delete 参数，以下命令表示删除 origin 主机的 master 分支：git push origin --delete master 2.分支与合并创建自己的分支,开发完毕后,再一次性合并到原来的分支上,即安全又不影响别人工作, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051git init 会默认创建master分支➜ calculator git:(master) ✗ git branch other 新建other分支➜ calculator git:(master) ✗ git checkout other 切换到other分支,当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容，也就是如果本来master分支下commit的文件,切换分支时git会把master分支commit的文件制作快照,把本地文件切换为other分支里commit的文件.这样你不需要自己创建目录,存放其他分支的文件,注意工作区和暂存区不会这样,如果master有文件没有被commit那么切换分支时此文件也会出现在新的分支里,并且两个分支共享此文件所以为了两个分支不影响,应当将本分支所有文件commit后再切换分支实例:[root@ecs-x-medium-2-linux-20200315145740 gittest]# lsmain.c[root@ecs-x-medium-2-linux-20200315145740 gittest]# git add main.c[root@ecs-x-medium-2-linux-20200315145740 gittest]# git commit -m &quot;commit main.c on master&quot;[master 4c7e832] commit main.c on master1 file changed, 5 insertions(+)create mode 100644 main.c[root@ecs-x-medium-2-linux-20200315145740 gittest]# git checkout otherSwitched to branch &#39;other&#39;[root@ecs-x-medium-2-linux-20200315145740 gittest]# ls #main.c没有出现在other分支里[root@ecs-x-medium-2-linux-20200315145740 gittest]# vim other.txt[root@ecs-x-medium-2-linux-20200315145740 gittest]# git add .[root@ecs-x-medium-2-linux-20200315145740 gittest]# git commit -m &quot;other.txt commit on branch other&quot;[other a98fc2b] other.txt commit on branch other1 file changed, 1 insertion(+)create mode 100644 other.txt[root@ecs-x-medium-2-linux-20200315145740 gittest]# lsother.txt[root@ecs-x-medium-2-linux-20200315145740 gittest]# git checkout masterSwitched to branch &#39;master&#39;[root@ecs-x-medium-2-linux-20200315145740 gittest]# ls #other.txt没有出现在master分支里main.c[root@ecs-x-medium-2-linux-20200315145740 gittest]# vim a.a[root@ecs-x-medium-2-linux-20200315145740 gittest]# git add a.a[root@ecs-x-medium-2-linux-20200315145740 gittest]# git checkout otherA a.aSwitched to branch &#39;other&#39;[root@ecs-x-medium-2-linux-20200315145740 gittest]# ls #a.a出现在新分支里a.a other.txt[root@ecs-x-medium-2-linux-20200315145740 gittest]#➜ calculator git:(master) ✗ git add ➜ calculator git:(master) ✗ git commit -m &quot;xxx&quot; &#x2F;&#x2F;在other分支提交➜ calculator git:(master) ✗ git checkout master 切换回master➜ calculator git:(master) ✗ git branch 查看分支➜ calculator git:(master) ✗ ➜ calculator git:(master) ✗ git merge other 合并other分支到当前所在分支➜ calculator git:(master) ✗ git branch -d other 删除other分支➜ calculator git:(master) ✗ 冲突 123456789101112git merge 可能会发生冲突1、git merge冲突了，根据提示找到冲突的文件，解决冲突,如果文件有冲突，那么会有类似的标记2、修改完之后，执行git add冲突文件名,告诉 Git 文件冲突已经解决3、git commit注意:没有-m选项进去类似于vim的操作界面，把conflict相关的行删除掉4. 这就解决了冲突,并将新的master分支内容commit到仓库区 实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121制造冲突:两个分支commit的文件里有相同文件名的文件即会发生冲突[root@ecs-x-medium-2-linux-20200315145740 gittest]# git branch * masterother[root@ecs-x-medium-2-linux-20200315145740 gittest]# lsconfltest.txt main.c[root@ecs-x-medium-2-linux-20200315145740 gittest]# cat confltest.txt this is a test , a file on master[root@ecs-x-medium-2-linux-20200315145740 gittest]# git add confltest.txt [root@ecs-x-medium-2-linux-20200315145740 gittest]# git commit -m &quot;this is a commit on master&quot; [master 8bba54d] this is a commit on master1 file changed, 1 insertion(+)create mode 100644 confltest.txt[root@ecs-x-medium-2-linux-20200315145740 gittest]# git checkout otherSwitched to branch &#39;other&#39;[root@ecs-x-medium-2-linux-20200315145740 gittest]# lsother.txt[root@ecs-x-medium-2-linux-20200315145740 gittest]# touch confltest.txt[root@ecs-x-medium-2-linux-20200315145740 gittest]# vim confltest.txt[root@ecs-x-medium-2-linux-20200315145740 gittest]# cat confltest.txtlalala , i am branch other[root@ecs-x-medium-2-linux-20200315145740 gittest]# git add confltest.txt[root@ecs-x-medium-2-linux-20200315145740 gittest]# git commit -m &quot;this is branch other&quot;[other 0423971] this is branch other1 file changed, 1 insertion(+)create mode 100644 confltest.txt[root@ecs-x-medium-2-linux-20200315145740 gittest]# git checkout masterSwitched to branch &#39;master&#39;[root@ecs-x-medium-2-linux-20200315145740 gittest]# git merge other #看到发生冲突Auto-merging confltest.txtCONFLICT (add&#x2F;add): Merge conflict in confltest.txtAutomatic merge failed; fix conflicts and then commit the result.解决冲突[root@ecs-x-medium-2-linux-20200315145740 gittest]# ls confltest.txt main.c other.txt可以看到合并已经完成了,但是两个文件名相同的文件怎么就剩下一个了那 ?打开冲突文件(即confltest.txt)[root@ecs-x-medium-2-linux-20200315145740 gittest]# cat confltest.txt &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADthis is a test , a file on master&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;lalala , i am branch other&gt;&gt;&gt;&gt;&gt;&gt;&gt; other发现里面有格式冲突文件的格式基本如下&lt;&lt;&lt;&lt;&lt;&lt;&lt;到&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 是在当前分支合并之前的文件内容&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;到&gt;&gt;&gt;&gt;&gt;&gt;&gt; other 是在other分支下该文件的内容此时我们需要手动修改此文件,将冲突消除[root@ecs-x-medium-2-linux-20200315145740 gittest]# vim confltest.txt #手动修改冲突[root@ecs-x-medium-2-linux-20200315145740 gittest]# cat confltest.txt #修改之后文件内容this is a test , a file on masterlalala , i am branch other我手动将两个文件内容放在了一起,将特殊符号删除,此时冲突消失执行下面两条[root@ecs-x-medium-2-linux-20200315145740 gittest]# git add confltest.txt[root@ecs-x-medium-2-linux-20200315145740 gittest]# git commit[master 229dd70] Merge branch &#39;other&#39;此时进入类似vim的界面,内容如下:Merge branch &#39;other&#39;Conflicts:confltest.txt## It looks like you may be committing a merge.# If this is not correct, please remove the file# .git&#x2F;MERGE_HEAD# and try again.# Please enter the commit message for your changes. Lines starting# with &#39;#&#39; will be ignored, and an empty message aborts the commit.# On branch master# All conflicts fixed but you are still merging.# (use &quot;git commit&quot; to conclude merge)## Changes to be committed:## modified: confltest.txt# new file: other.txt#需要删掉下面这两行Conflicts:confltest.txt然后保存退出,此时合并良好完成,且合并后的master分支里面的文件都已经commit到了仓库区,工作完成,此时可直接push到远程仓库啦验证一下:可以看到,工作区新添加的文件也commit到了仓库区,就是合并后的新的master分支的内容都到了master的仓库区[root@ecs-x-medium-2-linux-20200315145740 gittest]# git status# On branch masternothing to commit, working directory clean[root@ecs-x-medium-2-linux-20200315145740 gittest]# git add .[root@ecs-x-medium-2-linux-20200315145740 gittest]# git commit -m &quot;test&quot;# On branch masternothing to commit, working directory clean[root@ecs-x-medium-2-linux-20200315145740 gittest]# lsconfltest.txt main.c other.txt[root@ecs-x-medium-2-linux-20200315145740 gittest]# 3.标签12345678910111213141516171819202122232425262728如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。比如说，我们想为我们的 runoob 项目发布一个&quot;1.0&quot;版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）&quot;v1.0&quot;的标签。-a 选项意为&quot;创建一个带注解的标签&quot;。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。使用:当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。现在，注意当我们执行 git log --decorate 时，我们可以看到我们的标签了如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。git tag -a v0.9 85fc7e7查看所有标签使用: git tag指定标签信息命令： git tag -a &lt;tagname&gt; -m &quot;runoob.com标签&quot;PGP签名标签命令： git tag -s &lt;tagname&gt; -m &quot;runoob.com标签&quot;","categories":[{"name":"Git","slug":"Git","permalink":"https://humancloud.github.io/categories/Git/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"剑指offer笔记/面试题3","slug":"剑指offer笔记/面试题3","date":"2020-10-30T14:47:54.386Z","updated":"2020-10-31T15:15:48.997Z","comments":true,"path":"2020/10/30/剑指offer笔记/面试题3/","link":"","permalink":"https://humancloud.github.io/2020/10/30/%E5%89%91%E6%8C%87offer%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%983/","excerpt":"","text":"数组中重复的数字12在长度为n的数组里的所有数字都在0 ~ n-1的范围内.数组中某些数字是重复的,也不知道每个数字重复了几次,请找出数组中任意一个重复的数字,例如输入长度为7的数组&#123;2,3,1,0,2,5,3&#125;,那么对应输出是重复的数字2或者3.","categories":[],"tags":[]},{"title":"剑指offer笔记","slug":"剑指offer笔记","date":"2020-10-30T14:45:05.000Z","updated":"2020-10-30T15:04:34.581Z","comments":true,"path":"2020/10/30/剑指offer笔记/","link":"","permalink":"https://humancloud.github.io/2020/10/30/%E5%89%91%E6%8C%87offer%E7%AC%94%E8%AE%B0/","excerpt":"","text":"面试题1","categories":[{"name":"算法","slug":"算法","permalink":"https://humancloud.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"剑指offer笔记/面试题2","slug":"剑指offer笔记/面试题2","date":"2020-10-30T14:42:39.912Z","updated":"2020-10-30T14:47:48.079Z","comments":true,"path":"2020/10/30/剑指offer笔记/面试题2/","link":"","permalink":"https://humancloud.github.io/2020/10/30/%E5%89%91%E6%8C%87offer%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%982/","excerpt":"","text":"实现单例模式设计一个类,我们只能生成该类的一个实例 1只适用于单线程环境,书中为java代码","categories":[],"tags":[]},{"title":"剑指offer笔记/面试题1","slug":"剑指offer笔记/面试题1","date":"2020-10-30T14:41:36.161Z","updated":"2020-10-30T14:41:36.161Z","comments":true,"path":"2020/10/30/剑指offer笔记/面试题1/","link":"","permalink":"https://humancloud.github.io/2020/10/30/%E5%89%91%E6%8C%87offer%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E9%A2%981/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"mianshi","slug":"mianshi","date":"2020-10-20T15:52:36.000Z","updated":"2020-10-27T10:51:09.662Z","comments":true,"path":"2020/10/20/mianshi/","link":"","permalink":"https://humancloud.github.io/2020/10/20/mianshi/","excerpt":"1. 网络编程系统编程部分常见面试题目 1. TCP和UDP的区别 1234567(1) TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接(2) TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付(3) TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）(4) 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信(5) TCP首部开销20字节;UDP的首部开销小，只有8个字节(6) TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。","text":"1. 网络编程系统编程部分常见面试题目 1. TCP和UDP的区别 1234567(1) TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接(2) TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付(3) TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）(4) 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信(5) TCP首部开销20字节;UDP的首部开销小，只有8个字节(6) TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。 流量控制与拥塞控制 1234拥塞控制网络拥塞现象是指到达通信子网中某一部分的分组数量过多,使得该部分网络来不及处理,以致引起这部分乃至整个网络性能下降的现象,严重时甚至会导致网络通信业务陷入停顿,即出现死锁现象。拥塞控制是处理网络拥塞现象的一种机制。流量控制数据的传送与接收过程当中很可能出现收方来不及接收的情况,这时就需要对发方进行控制,以免数据丢失。 多线程如何同步 1234567windows线程同步有四种方式：临界区、内核对象、互斥量、信号量。Linux线程同步有最常用的是：互斥锁、条件变量和信号量。 进程间通信有哪些方式,各有什么优缺点 123456789101112Linux 进程间通信（IPC）以下以几部分发展而来：早期UNIX进程间通信、基于System V进程间通信、基于Socket进程间通信和POSIX进程间通信。UNIX进程间通信方式包括：管道、FIFO、信号。System V进程间通信方式包括：System V消息队列、System V信号灯、System V共享内存、POSIX进程间通信包括：posix消息队列、posix信号灯、posix共享内存。现在linux使用的进程间通信方式：（1）管道（pipe）和有名管道（FIFO）（2）信号（signal）（3）消息队列（4）共享内存（5）信号量（6）套接字（socket) tcp连接建立的时候3次握手，断开连接的4次握手的具体过程 12345建立连接采用的3次握手协议，具体是指：第一次握手是客户端connect连接到server，server accept client的请求之后，向client端发送一个消息，相当于说我都准备好了，你连接上我了，这是第二次握手，第3次握手就是client向server发送的，就是对第二次握手消息的确认。之后client和server就开始通讯了。断开连接的4次握手,具体如下：断开连接的一端发送close请求是第一次握手，另外一端接收到断开连接的请求之后需要对close进行确认，发送一个消息，这是第二次握手，发送了确认消息之后还要向对端发送close消息，要关闭对对端的连接，这是第3次握手，而在最初发送断开连接的一端接收到消息之后，进入到一个很重要的状态time_wait状态，这个状态也是面试官经常问道的问题，最后一次握手是最初发送断开连接的一端接收到消息之后。对消息的确认。 epoll和select的区别 123456789(1) select缺点:1.最大并发数限制：使用32个整数的32位，即32*32&#x3D;1024来标识fd，虽然可修改，但是有以下第二点的瓶颈；2.效率低：每次都会线性扫描整个fd_set，集合越大速度越慢；3.内核&#x2F;用户空间内存拷贝问题。(2) epoll的提升：1.本身没有最大并发连接的限制，仅受系统中进程能打开的最大文件数目限制；2.效率提升：只有活跃的socket才会主动的去调用callback函数；3.省去不必要的内存拷贝：epoll通过内核与用户空间mmap同一块内存实现。 (不知道有没有共享内存..................) 2. Linux部分Linux是开源且免费的，Unix是闭源的且收费的传统商业软件。 基础指令 1234567891011121314151617181920212223242526cd 进入目录，切换目录pwd 查看当前路径ls -l , ls -a 列出所有文件（包括隐藏文件）mkdir 创建目录rmdir 删除空目录.当前目录，..上层目录，~ 主目录cat -b 对非空输入行显示行号cat -n 对所有行显示行号cat &gt; filename 从标准输入创建文件cat file1 file2 &gt; file 将几个文件合并为一个文件:cat -n log2012.log log2013.log 把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里cat -b log2012.log log2013.log log.log 把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里cp命令行复制，如果目标文件已经存在会提示是否覆盖，而在 shell 脚本中，如果不加 -i 参数，则不会提示，而是直接覆盖！-i 提示-r 复制目录及目录内所有项目-a 复制的文件与原文件时间一样vi touch 创建文件 (会修改文件的时间) 硬盘使用命令 1234567891011121314151617181920显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示：-a 全部文件系统列表-h 以方便阅读的方式显示信息-i 显示inode信息-k 区块为1024字节-l 只显示本地磁盘-T 列出文件系统类型实例：（1）显示磁盘使用情况 df -l（2）以易读方式列出所有文件系统及其类型 df -haT 1234567891011121314151617181920212223242526272829du命令常用参数：-a 显示目录中所有文件大小-k 以KB为单位显示文件大小-m 以MB为单位显示文件大小-g 以GB为单位显示文件大小-h 以易读方式显示文件大小-s 仅显示总计-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和实例：（1）以易读方式显示文件夹内及子文件夹大小 du -h scf&#x2F;（2）以易读方式显示文件夹内所有文件大小 du -ah scf&#x2F;（3）显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和 du -hc test&#x2F; scf&#x2F;（4）输出当前目录下各个子目录所使用的空间 du -hc --max-depth&#x3D;1 scf&#x2F; CPU使用指令 12cat /proc/cpuinfo 查看cpu基本硬件信息top 或 datat -c 查看cpu使用状态信息(yum install dstat) 内存使用指令 12cat /proc/meminfo 查看内存基本容量free -k(以kb为单位显示), free -m(以mb为单位显示) 查看内存运行空间信息 查看系统版本 1uname -a 查看网络/进程信息 12345678910111213查看网络连接: netstat -anp (-a 显示所有选项 -t 仅显示tcp相关选项, -u 仅显示udp相关选项, -n 尽量显示出数字 -p 显示相关链接的程序名)可以显示出: Proto 协议类型, LocalAddress本地地址,ForeignAddress对端地址,State表示状态对tcp有效,pid表示对应的进程id查看8080端口被哪个进程占用 netstat -apn | grep 8080查看进程名为Python的进程有哪些连接 netstat -apn | grep python查看进程信息:top执行top命令,使用快捷键M即可以查看内存占用最多的N个进程 使用快捷键P即可以查看CPU占用最多的前N个进程top -p pid 使用H键可以查看线程相关的信息查看ip地址, ifconfig可能会出现多个ip地址,因为一台主机可能具备多个网络接口,多个网络接口对应多个网卡或虚拟网卡设备 chmod修改文件权限 1234567891011121314151617181920212223242526272829303132333435363738394041424344参数：-c 当发生改变时，报告处理信息-R 处理指定目录以及其子目录下所有文件权限范围：u ：目录或者文件的当前的用户g ：目录或者文件的当前的群组o ：除了目录或者文件的当前用户或群组之外的用户或者群组a ：所有的用户及群组权限代号：r ：读权限，用数字4表示w ：写权限，用数字2表示x ：执行权限，用数字1表示- ：删除权限，用数字0表示s ：特殊权限chmod 777 file 以八进制数字形式指定文件权限chmod a+x t.logchmod u=x t.log -cchmod u+r,g+r,o+r -R text/ -c 将test 目录及其子目录所有文件添加可读权限chmod +t directory/ 设置目录的沾滞位,防止其他用户在该目录下删除文件chown参数：-c 显示更改的部分的信息-R 处理指定目录及子目录chown -c mail:mail log2012.log 改变拥有者和群组 并显示改变信息chown -c :mail t.log 改变文件群组chown -cR mail: test/ 改变文件夹及子文件目录属主及属组为 mailchown user file 将文件所有者改为指定用户chmod -R user directory 将目录下所有文件所有者权限都设置为指定用户chgrp group file 将文件所属组改为指定用户组 查看文件权限 123查看文件访问的权限: ls -l 文件类型 (每个文件或目录都有三个权限 r,w,x) 文件所有者权限 文件所属组权限 其他用户权限 umask 查看默认的权限掩码(掩码取反就是文件权限)信息,最后显示出来的是八进制数字的形式,如 0222 root指令 12su root 切换root用户sudo 普通用户执行root指令, 只有被root用户添加到/etc/sudoers 文件中的用户才可以使用sudo指令 find指令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354命令格式：find pathname -options [-print -exec -ok ...]命令参数：pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。-print： find命令将匹配的文件输出到标准输出。-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' &#123; &#125; \\;，注意&#123; &#125;和\\；之间的空格。-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。命令选项：-name 按照文件名查找文件-perm 按文件权限查找文件-user 按文件属主查找文件-group 按照文件所属的组来查找文件。-type 查找某一类型的文件，诸如： b - 块设备文件 d - 目录 c - 字符设备文件 l - 符号链接文件 p - 管道文件 f - 普通文件（1）查找 48 小时内修改过的文件 find -atime -2（2）在当前目录查找 以 .log 结尾的文件。 . 代表当前目录 find ./ -name '*.log'（3）查找 /opt 目录下 权限为 777 的文件 find /opt -perm 777（4）查找大于 1K 的文件 find -size +1000c查找等于 1000 字符的文件 find -size 1000c -exec 参数后面跟的是 command 命令，它的终止是以 ; 为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。&#123;&#125; 花括号代表前面find查找出来的文件名。find pathname -name filename 在pathname目录下寻找文件名为filename的文件find pathname -size filesize 寻找文件大小为filesize的文件find pathname -size +/- filesize 寻找文件大小大于/小于filesize的文件 head命令 1234567891011121314151617181920head 命令head 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。常用参数：-n&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数）实例：（1）显示 1.log 文件中前 20 行 head 1.log -n 20（2）显示 1.log 文件前 20 字节 head -c 20 log2014.log（3）显示 t.log最后 10 行 head -n -10 t.log ln 命令 1功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。 uniq命令 123456用于检查和删除文本中重复出现的行列uniq filename 去除文件当中重复的行,输出到标准输出uniq file file1 去除文件当中重复的行,输出到file1uniq -c file 每列旁边显示该行重复的次数uniq -u file 显示只出现一次的行 iptables命令 123456789iptables ，是一个配置 Linux 内核防火墙的命令行工具。功能非常强大，对于我们开发来说，主要掌握如何开放端口即可。例如：把来源 IP 为 192.168.1.101 访问本机 80 端口的包直接拒绝：iptables -I INPUT -s 192.168.1.101 -p tcp --dport 80 -j REJECT 。开启 80 端口，因为web对外都是这个端口iptables -A INPUT -p tcp --dport 80 -j ACCEP1另外，要注意使用 iptables save 命令，进行保存。否则，服务器重启后，配置的规则将丢失。 netstat 12 grep命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758命令格式：grep [option] pattern file|dir常用参数：-A n --after-context显示匹配字符后n行-B n --before-context显示匹配字符前n行-C n --context 显示匹配字符前后n行-c --count 计算符合样式的列数-i 忽略大小写-l 只列出文件内容符合指定的样式的文件名称-f 从文件中读取关键词-n 显示匹配内容的所在文件中行数-R 递归查找文件夹规则表达式^ #锚定行的开始 如：&#39;^grep&#39;匹配所有以grep开头的行。 $ #锚定行的结束 如：&#39;grep$&#39;匹配所有以grep结尾的行。 . #匹配一个非换行符的字符 如：&#39;gr.p&#39;匹配gr后接一个任意字符，然后是p。 * #匹配零个或多个先前字符 如：&#39;*grep&#39;匹配所有一个或多个空格后紧跟grep的行。.* #一起用代表任意字符。 [] #匹配一个指定范围内的字符，如&#39;[Gg]rep&#39;匹配Grep和grep。 [^] #匹配一个不在指定范围内的字符，如：&#39;[^A-FH-Z]rep&#39;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。 \\(..\\) #标记匹配字符，如&#39;\\(love\\)&#39;，love被标记为1。 \\&lt; #锚定单词的开始，如:&#39;\\&lt;grep&#39;匹配包含以grep开头的单词的行。\\&gt; #锚定单词的结束，如&#39;grep\\&gt;&#39;匹配包含以grep结尾的单词的行。x\\&#123;m\\&#125; #重复字符x，m次，如：&#39;0\\&#123;5\\&#125;&#39;匹配包含5个o的行。 x\\&#123;m,\\&#125; #重复字符x,至少m次，如：&#39;o\\&#123;5,\\&#125;&#39;匹配至少有5个o的行。 x\\&#123;m,n\\&#125; #重复字符x，至少m次，不多于n次，如：&#39;o\\&#123;5,10\\&#125;&#39;匹配5--10个o的行。 \\w #匹配文字和数字字符，也就是[A-Za-z0-9]，如：&#39;G\\w*p&#39;匹配以G后跟零个或多个文字或数字字符，然后是p。 \\W #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。 \\b #单词锁定符，如: &#39;\\bgrep\\b&#39;只匹配grep。（1）查找指定进程ps -ef | grep svn（2）查找指定进程个数ps -ef | grep svn -c（3）从文件中读取关键词cat test1.txt | grep -f key.log（4）从文件夹中递归查找以grep开头的行，并只列出文件grep -lR &#39;^grep&#39; &#x2F;tmp（5）查找非x开关的行内容grep &#39;^[^x]&#39; test.txt（6）显示包含 ed 或者 at 字符的内容行grep -E &#39;ed|at&#39; test.txt Linux目录结构 123456789101112131415/bin 存放二进制可执行文件,很多常用命令都在这里/sbin 存放二进制文件，只有root才能访问，存放的是系统管理员使用的系统级别的管理命令和程序/etc 存放系统管理和配置文件/usr 很多应用程序的安装目录/home 所有用户的家目录/root 超级用户的家目录/dev 存放设备文件/mnt 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统/boot 存放系统引导时使用的各种文件/lib 存放系统运行相关的库文件/var 保存各种服务的日志文件/opt 额外安装的可选应用程序包放置的位置/proc 虚拟文件系统目录，是系统内存的映射，可直接访问这个目录来获取系统信息/tmp 用于存放各种临时文件，是公用的临时文件存储点/lost+found 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件 硬链接与软链接 123456789101112131415161718192021221）硬链接由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。不足：1）不可以在不同文件系统的文件间建立链接；2）只有超级用户才可以为目录创建硬链接。ln a b2）软链接软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。ln -s a b实际场景下，基本是使用软链接。总结区别如下：硬链接不可以跨分区，软件链可以跨分区。硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。 shell脚本 1一个 Shell 脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell 脚本)来完成这些日常工作任务。 wc命令 1234567891011121314151617181920212223命令参数：-c 统计字节数-l 统计行数-m 统计字符数-w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串1234实例：（1）查找文件的 行数 单词数 字节数 文件名 wc text.txt结果： 7 8 70 test.txt（2）统计输出结果的行数 cat test.txt | wc -l 压缩 12345678910111213打包并压缩 tar -cvf ./abc.tar ./abc 只打包不压缩 tar -zcvf ./abc.tar.gz ./abc 打包并使用gzip压缩 tar -jcvf ./abc.tar.bz2 ./abc 打包并使用bzip2压缩 解压只需替换c为x即可不打包直接压缩gzip -v file 压缩文件gzip -d file.gz 解压缩 IPC相关 123456789101112131415161718192021222324252627282930313233ipcs 显示进程间通信设施状态的工具➜ code git:(master) ipcs --------- 消息队列 -----------键 msqid 拥有者 权限 已用字节数 消息 ------------ 共享内存段 --------------键 shmid 拥有者 权限 字节 连接数 状态 0x00000000 688136 lu 700 8294400 2 目标 0x00000000 688141 lu 700 91656 2 目标 0x00000000 753682 lu 600 524288 2 目标 0x51310018 22 lu 600 33024 1 0x5131001a 23 lu 600 16 1 0x00000000 688153 lu 700 1600 2 目标 0x00000000 27 lu 600 524288 2 目标 0x00000000 688159 lu 700 2537600 2 目标 0x00000000 32 lu 600 524288 2 目标 0x5131002f 37 lu 600 16 1 0x00000000 229416 lu 600 524288 2 目标 0x00000000 622634 lu 600 8015104 2 目标 0x00000000 65584 lu 700 30000 2 目标 0x00000000 557110 lu 700 307400 2 目标 0x5131004c 163900 lu 600 1024 1 0x00000000 622654 lu 700 289380 2 目标 --------- 信号量数组 -----------键 semid 拥有者 权限 nsems 0x51310017 1 lu 600 1 0x51310019 3 lu 600 1 0x5131002e 5 lu 600 1 0x5131004b 9 lu 600 1 其他 1&gt;&gt;(追加) &gt;(覆盖) 重定向 vim 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152NOMAL 模式底行命令模式插入模式:tabe a.txt 打开或创建新文件,使用gt切换文件\" %在括号匹配之间跳转\"\"\" =============================================================================\" Nomal模式\" =============================================================================\" ctrl v 块选择,可以用来给代码多行注释\" gd 跳转到局部定义 不用ctags\" gf 跳转到文件\" ctrl o 跳转到上一个跳转位置 这个很重要, 不管怎么跳转,都可以ctrl o 跳转回来\" ctrl i 到下一个跳转位置\" ctrl b 查看上一页内容 常用\" ctrl f 查看下一页内容 常用\" K 跳转到manul\" \" &lt;&lt; 左缩进\" &gt;&gt; 右缩进\" == 自动缩进 原来还可以这样\"\" 0到行首\" ^ 跳转到行首第一个非空字符\" $到行尾\" % 匹配括号移动\" gg到第一行行首\" G 到最后一行的行尾\" 100G 跳转到100行行首 , 比命令模式输入:行号方便\" \" \" y$复制到行尾\" yw 复制一个单词\" yy 复制一整行\" 10yy 复制光标下10行\" yG 复制到文本结束\" yH 从文本开始复制到光标处\"\"\" x 删掉光标处字符\" 3x剪切三个\" p 光标之后粘贴\" P光标之前粘贴\" 3p粘贴三次\" \"\" fa移动光标到本行下第一个字符a处, 2fa移动到第二个a处\" Fa移动到上一个字符a\" nfa 移动到第n个字符处\" nFa\"\" yfa 复制光标字符到字符a之间的内容\" y2fa 复制光标字符到第2个a之间的内容\"\" \" dw \" d2w 删除两个单词\" df\" 删除到出现第一个双引号的位置\" d2f\" 删除到出现第2个双引号的位置\" d$ 删除到本行结尾\" d^ 删除到本行开头\" dH 同yH\" dG 同yG \" dtg 删除到g字符的位置不删除g字符 (例如abcdegfhijk) 按键dtg从光标删除到g字符,\" 其实就是delete to g 的缩写很好用啊\"\" 重要的:\" f&#123; 移动到大括号处,然后d%删除整个大括号的内容(包括大括号), 或者di&#123;\" 删除大括号里面的内容,不删除大括号\"\" \"\" u 撤销操作\" ctrl r 恢复撤销操作\"\"\"\" ~ 将光标处的字符改变大小写\" 3~ 将光标位置开始的3个字符改变其大小写\" g~~ 改变当前行字符大小写\" gUU 当前行字符改成大写\" guu 当前行改成小写\" gUw 光标处的单词改成大写\" guw 光标处的单词改成小写\"\"\" 替换:\" r 替换光标处字符\" S替换行(删除当前行,并进入插入模式)\" cc 同 S\" ciw改写光标所处的单词\" caw改写光标所处的单词(如果两侧有空格删除空格)\" c0 从光标改写到行首\" c^ 从光标改写到行首（第一个非零字符）\" c$ 从光标改写到行末\" C 从光标改写到行尾（同c$）\" ci\" 改写双引号中的内容\" ci' 改写单引号中的内容\" cib 改写小括号中的内容\" cab 改写小括号中的内容（包含小括号本身）\" ci) 改写小括号中的内容\" ci] 改写中括号中内容\" ciB 改写大括号中内容\" caB 改写大括号中的内容（包含大括号本身）\" ci&#125; 改写大括号中内容\" c2w 改写下两个单词\" ct( 改写到小括号前\" c/apple 改写到光标后的第一个apple前\"\"\"\"\"\" =============================================================================\" 底行命令模式\" =============================================================================\" :%!xxd 16进制\" :s/$/sth 行尾追加sth\" :g/^/s*$/d 删除空行以及只有空格的行\"\" 替换\" :s/from/to 当前行第一个from替换成to\" :s/from/to/g 当前行所有from替换成to\" :33s/from/to/g 在第33行进行替换操作 \" :%s/from/to/g 对所有行内容进行替换\"\"\" =============================================================================\" Insert模式\" =============================================================================\" I 进入编辑,并将光标置于行首\" A 置光标与行尾并进入插入模式(在行尾插入)\" O 当前行上面新加一行,进入插入模式\"\" insert 模式 ctrl [ 相当于esc 但比esc更顺手\" ctrl d crtl t 左右缩进\" ctrl u 重新编辑本行\" ctrl w 删除单词\" \"\" 插入模式快捷键\" CTRL-M 或 CTRL-J 开始新行\" CTRL-E 插入光标下方的字符\" CTRL-Y 插入光标上方的字符\" CTRL-A 插入上次插入的文本\" CTRL-@ 插入上次插入的文本并结束插入模式\" CTRL-R &#123;0-9a-z%#:.-=\"&#125; 插入寄存器的内容\" CTRL-W 删除光标前的一个单词\" CTRL-U 删除当前行的所有字符\" CTRL-T 在当前行首插入一个移位宽度的缩进\" CTRL-D 从当前行首删除一个移位宽度的缩进\" 0 CTRL-D 删除当前行的所有缩进\" ^ CTRL-D 删除当前行的所有缩进，恢复下一行的缩进\"\" &lt;S-Left&gt; 按住 SHIFT 按左键，向左移动一个单词\" &lt;S-Right&gt; 按住 SHIFT 按右键，向右移动一个单词\" &lt;S-Up&gt; 按住 SHIFT 按上键，向上翻页\" &lt;S-Down&gt; 按住 SHIFT 按下键，向下翻页\"\" =============================================================================\"\"\"\"切换buffer\":bn 切换到后一个\":bp 切换到前一个\"\"\"\" vim 缩进大法\"\" 缩进4个格 1,18&gt; 1到18行向右缩进4格, &lt;向左缩进4空格\"\" 缩进自定义个格\" ctrl v 进入visual block模式, 选择块, 按I\" ,按1个空格,按esc键就可以整个块向右缩进1格\"\" 按几个空格缩进几个格,\" 甚至不输入空格而是输入字符,都会使得整个块每一行前面都加上这几个字符(其实输入空格就是在开头添加空格,输入字符就是添加字符)\" 编译过程 123456789101112131415161718191. 预定义 宏替换 处理条件编译/预编译指令 头文件展开 添加行号信息方便调试 去掉注释 生成.i文件2. 编译 语法/语义分析,源代码优化,目标代码生成与优化 词法分析: 语法分析: 语义分析: 生成汇编代码 生成.s文件3. 汇编 将汇编指令翻译为二进制指令 生成.o二进制文件4. 链接 gcc g++ 1234567891011-E 只激活预处理,不生成文件,需要把它重定向到一个输出文件里-S 预处理和编译,生成汇编代码-c 只激活预处理,编译,汇编生成obj文件(二进制文件)-o 生成可执行文件(指定文件名称,缺省为a.out)-static 禁止使用动态库(编译出来的东西一般都很大,也不需要什么动态链接库就可以运行),禁止使用共享连接-fPIC --share 尽量使用动态库,生成文件较小,但需要系统由动态库生成共享目标文件-L 指定库的路径-I 头文件默认搜索路径-l 指定链接库名称-g 编译时产生调试信息 gdb 12 makefile 1234makeifle编写规则makefile解释流程makefile解决的是编译问题,可以将命名写成一个脚本文件,然后去执行这个脚本文件 git 1234远程部署三连git add . 添加到缓冲区/暂存区git commit -m \"regular\" 提交文件,提交到仓库区git push -u origin master 提交到远程仓库 git基础操作 12工作区: 磁盘上的文件集合版本区(版本库): .git文件夹 &#x3D; 暂存区(stage) + 分支(master) + 指针Head 1234567git config --global user.name &#39;humancloud&#39;git config --global user.email &#39;humancloud@126.com&#39;git init 版本区建立(创建.git文件)git add . 把工作区所有文件提交到版本区里的暂存区git commit -m &quot;xxx&quot; 暂存区所以文件提交到仓库区(暂存区空)git remote add origin xxxxxx.git 把本地仓库与远程仓库连接起来git push -u origin master 把仓库区文件提交到远程仓库里(将本地的master分支推送到origin主机,同时指定origin为默认主机)) 其他命令: 123456789101112131415161718192021222324252627282930➜ calculator git:(master) ✗ git status 查看状态➜ calculator git:(master) ✗ git remote -v 查看远程仓库➜ calculator git:(master) ✗ git remote add [name] [url] 添加远程仓库➜ calculator git:(master) ✗ git remote rm [name] 删除远程仓库➜ calculator git:(master) ✗ git rm &amp;&amp; git commit -m &quot;xxx&quot; 删除版本区文件➜ calculator git:(master) ✗ git remote set-url --push [name] [new url] 修改远程仓库 ➜ calculator git:(master) ✗ git log 查看日志➜ calculator git:(master) ✗ git pull 把最新的提交从远程仓库抓取下来,在本地合并,和git push 相反注意:: 克隆下项目来,如果想要更新项目,直接git pull 把最新的项目拉下来,即可撤销: 1. 在工作区修改了内容,向回溯到版本区(版本库)里的版本➜ calculator git:(master) ✗ git checkout --file 用版本区的版本替换工作区的版本2. 在工作区修改了内容,并git add添加到了暂存区,要撤销➜ calculator git:(master) ✗ git reset --hard 版本号 ,暂存区回溯到以前的版本(版本号 git log查看)➜ calculator git:(master) ✗ git checkout --file 再用版本区的替换工作区的版本3. .....,并git commit 到了仓库区,与2相同删除:1. 删除版本区(版本库)的文件,(如果git add把某文件存到暂存区了,然后在工作区把这个文件删除了,要想把版本区的这个文件也删除,执行下面)➜ calculator git:(master) ✗ git rm [filename] &amp;&amp; git commit -m &quot;xxx&quot; ,删除版本区的文件并描述这次删除, 2. 如果git add了,然后删除了本地文件,git会知道,要想恢复,可以从版本区恢复,➜ calculator git:(master) ✗ git checkout --file test: 1234567891011121314151617➜ calculator git:(master) ✗ git add a.c 添加到暂存区➜ calculator git:(master) ✗ git commit -m &quot;first&quot; 将文件从暂存区提交到仓库➜ calculator git:(master) ✗ git remote add origin https:&#x2F;&#x2F;github.com&#x2F;humancloud&#x2F;c.git &#x2F;&#x2F;将本地仓库同步到远程仓库➜ calculator git:(master) ✗ git push -u origin master Username for &#39;https:&#x2F;&#x2F;github.com&#39;: humancloudPassword for &#39;https:&#x2F;&#x2F;humancloud@github.com&#39;: 对象计数中: 5, 完成.Delta compression using up to 8 threads.压缩对象中: 100% (2&#x2F;2), 完成.写入对象中: 100% (5&#x2F;5), 1.72 KiB | 1.72 MiB&#x2F;s, 完成.Total 5 (delta 0), reused 0 (delta 0)To https:&#x2F;&#x2F;github.com&#x2F;humancloud&#x2F;c.git * [new branch] master -&gt; master分支 &#39;master&#39; 设置为跟踪来自 &#39;origin&#39; 的远程分支 &#39;master&#39;。➜ calculator git:(master) ✗ ➜ calculator git:(master) ✗ git rm .➜ calculator git:(master) ✗ git commit -m &quot;xxx&quot; 常遇到 删除错误添加到暂存区的文件: 12345678touch 1.txtgit add 1.txt1. 删除添加到暂存区的文件1.txtgit rm --cache 1.txt2. 删除暂存区和工作区的文件git rm -f 1.txt 删除错误提交的 1234567touch 1.txtgit add 1.txtgit cimmit -m \"regular\"撤销版本库的修改(暂存区,工作区不变): git reset - 本站访客数:-soft 版本库ID撤销版本库和暂存区不修改工作区: git reset --mixed 版本库ID将工作区,暂存区,版本库恢复到指定的版本:git reset --hard 版本库ID 日志 1234567891011121314151617181920212223242526272829git log这个最上面的是最近的提交不是最下面的是,这串数字就是版本库IDcommit d2c6f0ca1e7c075692c55870f4166b1e297dfcea (HEAD -&gt; master)Author: humancloud &lt;humancloud@126.com&gt;Date: Sat May 2 19:05:43 2020 +0800 regularcommit d1212d0313103c4a1199624220a1ac7c415c6785Author: humancloud &lt;humancloud@126.com&gt;Date: Sat May 2 18:55:37 2020 +0800 regularcommit 87268a78fff1c94da04de77681cf617e151d6081 (origin/master)Author: humancloud &lt;humancloud@126.com&gt;Date: Wed Apr 22 20:58:16 2020 +0800 regularcommit 9bee9335b7a83680d18e1eb2523d0cd96b59bb31Author: humancloud &lt;humancloud@126.com&gt;Date: Sun Apr 19 13:42:37 2020 +0800 regular: 3. hr常问 工作城市 优缺点 哪些因素决定这家公司 4. C++语言方面4.1 C和C++区别12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561. 设计思想不同C语言是面向过程的: 优点(高效,性能好),缺点(不易维护,可扩展性低)C++是面向对象的,具有三大特性(封装,继承,多态)2. 参数列表C语言如果没有指定参数列表,可以默认接收多个参数C++如果没有指定参数列表,不接受任何参数3. 函数默认返回值C语言函数默认返回值为intC++函数默认返回值为void4. 输入输出不同C printf scanfC++ cout cin5. C++扩展了C语言的关键字static关键字: 全局静态变量: 全局变量前加static成为全局静态变量, 存储在静态区,属于静态变量,整个运行期间一直存在 未被初始化的全局静态变量自动初始化 作用域在当前文件,在声明他的其他文件之外不可见 链接属性由外部变为内部,存储类型不变 (默认全局变量是全局的,所以链接属性是外部的) 局部静态变量: 局部变量前加static成为局部静态变量, 存储在静态区,属于静态变量,整个运行期间一直存在 作用域依然是局部的,定义他的函数块结束,作用域结束,但是变量并没有被销毁,当再次进入此函数时,依然可以访问,值不变 存储类型发生改变,由自动变量改为静态变量 作用域和链接属性不变 静态函数: 函数返回类型前加static,成为静态函数 只在声明他的文件内可见,不能被其他文件所用,不会引起命名冲突 尽量不要在头文件声明static的全局函数 (要在源文件中写是吗,在头文件里写头文件会被包含到其他文件,但包含了并不能使用他) 类的静态成员: 实现多个对象间的数据共享,不会破坏隐藏规则 静态成员是所有对象的共享成员,不属于某一个对象 声明周期是创建类到销毁类 和类中非静态成员不同的是： 非静态成员属于对象，声明周期是从对象实例化开始，而静态成员是类一创建就已经存在了 类的静态函数： 属于类的静态成员，不属于对象 静态成员函数不能直接引用类的非静态成员，可以引用类中的静态成员 对于类中的成员变量和成员函数加上static就不属于对象，自然也没有this指针了extern关键字 引用另一个文件的变量 引用同一个文件的变量 引用另一个文件的函数 6. 常用sql语句必知必会总结 12 7. 数据结构部分MyTinySTL C实现的基础数据结构 cpp实现基础数据结构 交换排序冒泡排序 1234567891011121314151617181920/** * 从大到小 * a1 与 a2 比较,a2&gt;a1则交换位置 * 从第一个元素往后比较每次排序都把最大的放右边,不能放左边, 如果要把最大的放左边则要从最后一个元素往前比较 */void Bubble(int *array,int num)&#123; int tmp; for (int i = 0; i &lt; num; i++) &#123; for (int j = 0; j &lt; num - i; j++) &#123; if(array[j] &gt; array[j+1])&#123; tmp = array[j+1]; array[j+1] = array[j]; array[j] = tmp; &#125; &#125; &#125;&#125; 快速排序 选择排序简单选择排序 12345678910111213141516void SimpLeSelectSort(SqList *L)&#123; int tmp; for (int i = 1; i &lt;= L-&gt;length; i++) &#123; for(int j = i+1;j&lt;=L-&gt;length;j++) &#123; if (L-&gt;r[i].key &gt; L-&gt;r[j].key) &#123; tmp = L-&gt;r[j].key; L-&gt;r[j].key = L-&gt;r[i].key; L-&gt;r[i].key = tmp; &#125; &#125; &#125;&#125; 堆排序 链表队列栈二叉排序树哈希表","categories":[{"name":"面试小总结","slug":"面试小总结","permalink":"https://humancloud.github.io/categories/%E9%9D%A2%E8%AF%95%E5%B0%8F%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言宏实现max","slug":"C语言宏实现max","date":"2020-10-04T14:13:00.000Z","updated":"2020-10-30T14:58:43.797Z","comments":true,"path":"2020/10/04/C语言宏实现max/","link":"","permalink":"https://humancloud.github.io/2020/10/04/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E5%AE%9E%E7%8E%B0max/","excerpt":"前言C语言宏功能强大,但一不小心就会用错,许多经典书籍都曾讲过C语言宏的强大功能,此篇文章是参考C陷阱与缺陷书籍和网上其他文章总结的","text":"前言C语言宏功能强大,但一不小心就会用错,许多经典书籍都曾讲过C语言宏的强大功能,此篇文章是参考C陷阱与缺陷书籍和网上其他文章总结的 根据书籍写此篇文章 编程常用宏(常更新)max函数宏 12345错误版#define max(a,b) ((a)&gt;(b))?(a):(b)a或b会被计算两次,如果每次计算a或b都改变,那么最后得到的结果与预想中的会不同 123456789Linux Kernel 版#define max(x,y) (&#123; \\ typeof(x) _max1 = (x); \\ typeof(y) _max2 = (y); \\ (void)(&amp;_max1 == &amp;_max2); \\ _max1 &gt; _max2 ? _max1:_max2;&#125;)x或y只会被计算一次 assert宏 , swap宏","categories":[{"name":"C语言","slug":"C语言","permalink":"https://humancloud.github.io/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"网络编程考试总结","slug":"网络编程考试总结","date":"2020-05-31T12:56:25.000Z","updated":"2020-06-02T00:05:47.482Z","comments":true,"path":"2020/05/31/网络编程考试总结/","link":"","permalink":"https://humancloud.github.io/2020/05/31/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/","excerpt":"前言: 笔记linux多线程的同步即 sem 和 互斥量 程序设计题不涉及多线程,不会使用到select,epoll,WSA等模型,有字符串处理 简答五选三(背五道题)","text":"前言: 笔记linux多线程的同步即 sem 和 互斥量 程序设计题不涉及多线程,不会使用到select,epoll,WSA等模型,有字符串处理 简答五选三(背五道题) 函数总结TCP echo服务器用到的函数 12345#include &lt;unistd.h&gt;int close(int fd);成功返回0,失败返回-1,其他返回值通过man了解 123456789101112131415161718192021222324252627282930313233343536#include&lt;netinet/in.h&gt;struct sockaddr_in&#123; uint8_t sin_len; sa_family_t sin_family; in_port_t sin_port; struct in_addr sin_addr; char sin_zero[8];&#125;;struct in_addr&#123; in_addr_t s_addr;&#125;用到的就三个: sin_family, sin_port, sin_addr.s_addr#include&lt;sys/socket.h&gt;struct sockaddr&#123; uint8_t sa_len; sa_family_t sa_family; char sa_data[14];&#125;struct sockaddr_in addr;(struct sockaddr *)&amp;addr; //主要作用就是强制转换sockaddr_in类型为sockaddr类型 123456789101112#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;int socket(AF_INET, SOCK_STREAM,0);int socket(AF_INET,SOCK_DGRAM,0);AF_INET ipv4AF_INET6 ipv6SOCK_STREAM tcpSOCK_DGRAM udp使用指定参数创建一个套接字 123456#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);将创建的套接字标记为被动套接字,等待客户端连接 12345678910111213#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);阻塞等待连接请求到达,连接请求到达后,创建连接套接字,客户端与服务器使用连接套接字通信#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 123456789#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t send(int sockfd, const void *buf, size_t len, int flags);ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);send 和recv 函数只能用于tcp, sendto和recvfrom函数可以用于udp也可用于tcp 1234567#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t recv(int sockfd, void *buf, size_t len, int flags);ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); 123456789101112write#include &lt;unistd.h&gt; ssize_t write(int fd, const void *buf, size_t count);read#include &lt;unistd.h&gt; ssize_t read(int fd, void *buf, size_t count); 1234567891011121314151617181920212223242526inet_ntop()#include &lt;arpa/inet.h&gt;将网络字节序转为ip地址const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);inet_pton()#include &lt;arpa/inet.h&gt;直接将ip地址转为网络字节序(不需要先转为主机字节序,再转为网络字节序)int inet_pton(int af, const char *src, void *dst);#include &lt;arpa/inet.h&gt; uint32_t htonl(uint32_t hostlong); //host to network long 主机字节序转网络字节序 l表示long,转ip,s表示short转port uint16_t htons(uint16_t hostshort); uint32_t ntohl(uint32_t netlong); uint16_t ntohs(uint16_t netshort); Tcp 服务器客户端通信过程12345678910111213141516服务器:socket() 创建套接字bind()listen() 将套接字标记为监听套接字accept() 阻塞等待客户端连接,收到连接请求后,建立连接返回连接套接字send,recv接收消息(或者使用write,read,或者sendto,recvfrom)客户端:socket() 创建套接字bind() 可隐式绑定connect() 连接服务器sendto() recvfrom() 收发消息(udp不能使用recv和send函数) Udp服务器客户端通信过程12345678910111213141516Udp不需建立连接,所以不需要accept不需要connect不需要listen服务器:socket() 创建套接字bind()recvfrom()sendto()客户端:socket() 创建套接字bind() 可以隐式绑定sendto() recvfrom() 非阻塞123456789101112131415161718192021222324252627282930313233343536371）阻塞（Blocked）：当调用某个函数时，若操作条件不具备，函数会一直处于等待状态，程序的执行进程会在该函数调用处停顿，直到操作完成或发生错误为止。2）非阻塞（Nonblocked）：当调用某个函数时，无论操作条件是否具备，函数均会立即返回，程序的执行进程不会在该函数调用处停顿，而是继续执行。1）SOCK_DGRAM及SOCK_STREAM类型的套接字均可以工作在阻塞模式或非阻塞模式2）Linux中，创建套接字的同时可以指定工作模式，例如socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0)上述代码会创建非阻塞模式的套接字。默认情况下，新建的套接字工作在阻塞模式如果要把工作在阻塞模式的套接字改为非阻塞模式,可以使用函数fcntl (下面参数里sockfd即为阻塞模式的套接字),(用法: 例如accept函数返回的套接字不能直接设置为非阻塞需要fcntl函数处理)fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK);1）非阻塞模式套接字的函数调用失败时，并不一定表示真的遇到了网络错误，应根据errno的值进行相应的处理2）若errno值为EAGAIN或EWOULDBLOCK，则表示操作条件目前并不具备，而不是遇到了网络错误 sockC &#x3D; accept(sock, (struct sockaddr*)&amp;addrC, &amp;sizeAddr); if(-1 &#x3D;&#x3D; sockC) &#123; if(errno !&#x3D; EAGAIN &amp;&amp; errno !&#x3D; EWOULDBLOCK) &#123; printf(&quot;accept() error : %d -&gt; %s\\n&quot;, errno, strerror(errno)); &#125; &#125; 多线程多线程创建管理1234567头文件#include&lt;pthread.h&gt; 编译时加上-pthtread参数pthread_t thread;pthread_create(&amp;thread,NULL,doThread,(void*)arg); /*创建线程,线程id为thread*/pthread_detach(thread); /* 分离线程,意思是线程函数执行完毕后系统自动回收线程 */pthread_join(thread,NULL); /* 等待线程函数结束(直到线程函数结束,代码不会向下执行),可以接收线程函数的返回值(线程函数返回值为void* 所以可以返回任何值) */ 多线程同步信号量 1234567891011线程的信号量与进程间通信中使用的信号量的概念是一样，它是一种特殊的变量，它可以被增加或减少，但对其的关键访问被保证是原子操作。如果一个程序中有多个线程试图改变一个信号量的值，系统将保证所有的操作都将依次进行。信号量的函数都以sem_开头，线程中使用的基本信号量函数有4个，它们都声明在头文件semaphore.h中。1. sem_init函数 该函数用于创建信号量 int sem_init(sem_t *sem, int pshared， unsigned int value);2. sem_wait函数 该函数用于以原子操作的方式将信号量的值减1。 int sem_wait(sem_t *sem);3. sem_post函数 该函数用于以原子操作的方式将信号量的值加1。 int sem_post(sem_t *sem);4. sem_destroy函数 该函数用于对用完的信号量的清理 int sem_destroy(sem_t *sem);sem_wait(); 到 sem_post(); 之间的代码是原子操作,不用管信号量的值是几,具体由操作系统管理 互斥量 12345pthread_mutex_t mutex; /* 创建锁*/pthread_mutex_init(&amp;mutex, NULL); /* 初始化锁 */pthread_mutex_lock(&amp;mutex); /* 上锁 */pthread_mutex_unlock(&amp;mutex); /* 解锁*/pthread_mutex_destroy(&amp;mutex); /* 销毁锁 */ select1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;sys/select.h&gt;int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict errorfds, struct timeval *restrict timeout); void FD_ZERO(fd_set *set) 将set清空为0 void FD_SET(int fd,fd_set *set) 将fd设置到set集合中去 void FD_CLR(int fd,fd_set *set) 将fd从set中清除出去 int FD_ISSET(int fd,fd_set *set) 判断文件描述符fd是否在set集合中( FD_ISSET() tests to see if a file descriptor is part of the set;) __FD_SETSIZE 系统定义的宏,表示文件描述符最多个数,一般是1024,也可以不加前面两个下划线即FD_SETSIZE使用过程:fd_set fsRead,fsRead2; //集合int Maxfd; //最大描述符struct timeval tmot; //超时时间int countFd; //select返回值,(满足条件的描述符个数)FD_ZERO(&amp;fsRead); //清空集合FD_SET(listenfd,&amp;fsRead); //将监听套接字放在集合中Maxfd = listenfd;//主循环while(1)&#123; //备份 fsRead2 = fsRead; //设置超时时间 tmot.tv_sec = 0; //秒 tmot.tv_usec = 200000; //微秒 //select函数 countFD = select(maxFD + 1, &amp;fsRead2, NULL, NULL, &amp;tmot); //返回值: 返回发生事件的套接字的个数 if(countFD == -1) &#123; printf(\"select() error : %d -&gt; %s\\n\", errno, strerror(errno)); &#125; else if(countFD == 0) &#123; /* 无就绪描述符,输出超时 */ //time out printf(\"select() timeout\\n\"); &#125;else&#123; for(k = 0; k &lt; maxFD + 1; k++) &#123; if(FD_ISSET(k, &amp;fsRead2)) /* 判断k是否在集合fsRead2中 */ &#123; if(k == listenfd)&#123; //发生事件的是监听套接字,说明有连接到来 int connfd = accept(); /* 把创建的连接描述符放在集合里 */ FD_SET(sockC, &amp;fsRead); if(sockC &gt; maxFD)&#123; maxFD = sockC; &#125; &#125;else&#123; //发生事件的是连接套接字,接收发来的消息,并回复 recv(); send(); &#125; &#125; &#125; &#125;&#125; winsock编程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576771）准备WinSock环境int WSAStartup（WORD wVersionRequested， LPWSADATA lpWSAData）a）参数1：为期待的版本，可以使用MAKEWORD（x，y）来指定版本，其中x为主版本，占据低字节，y为次版本，占据高字节，目前均使用2.0以上版本，常用2.2；b）参数2：指向一个WSADATA结构体，用于填充返回相关信息c）返回值：操作成功，返回0，否则返回错误代码。注意，在WinSock执行环境未准备好时，不能调用WSAGetLastError（）2）清除WinSock环境int WSACleanup（void）若成功返回0，否则返回SOCKET_ERROR。一般不会出错。3）获取错误int WSAGetLastError（void）返回当前线程上次WinSock操作失败时的具体错误代码。大部分WinSock错误代码以WSAE作为前辍4）设置I/O模式int ioctlsocket（SOCKET s，long cmd，u_long FAR *argp）a）s为指定套接字b）cmd为要执行的命令c）argp指向命令需要的参数d）返回值：操作成功返回0，否则返回SOCKET_ERRORe）设置为非阻塞模式时，cmd为FIONBIO，argp指向值为非0的整型变量5）关闭套接字int closesocket（SOCKET s）若操作成功返回0，否则返回SOCKET_ERROR。#include&lt;winsock2.h&gt;#pragma comment(lib,\"ws2_32\")int main()&#123; struct WSADATA wsd; int code = WSAStartup(0x0202,&amp;wsd); //0x0202表示版本 if(code != 0)&#123; printf(\"WSAStartup error: %d\",code); return -1; &#125; 其他与Linux一样 closesocket(sockfd); WSACleanup();&#125; 字符串处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758头文件#include&lt;string.h&gt;strstr(str,\"hello\"); 在字符串str中找到hello字符串返回hello字符串,找不到返回NULLstrchr(str,'\\n'); 在字符串str中寻找回车符strcmp(str,\"hello\"); 如果str字符串与\"hello\"字符串相等,那么返回0,其他返回值不常用strcat(str,\"hello\"); 在字符串str后面拼接上hello字符strcpy(str,\"hello\"); 把字符串hello拷贝给str,str原来的值被覆盖指针,指针也是处理字符串很好用的方式例如:分割http请求第一行GET /index.html HTTP/1.1首先提取出http请求的第一行假设整个请求存在request数组里char *p = request;char *q = strchr(request,'\\n');指针p和q之间就是这一行数据char method[1024];char uri[1024];char version[1024];Split(&amp;p,q,method); 分离出方法Split(&amp;p,q,uri);Split(&amp;p,q,version);最终结果: method 存放 GETuri 存放/index.htmlversion存放HTTP/1.1void Split(char **p,char *q,char *s)&#123; while((*p) != q) &#123; if( (**p) == ' ' ) &#123; (*p)++; break; &#125; *(s++) = *((*p)++); &#125;&#125; 简答题listen backlog作用 recv 返回值 epoll使用过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;sys/epoll.h&gt;2）创建epoll实例int epoll_create（int size）epoll模型由内核管理，需要向内核申请创建实例。参数size为实例大小，可以理解为所管理描述符的数量。在Linux 2.6.8以后，size会由系统自动调整，该参数仅仅为保持兼容而存在。若操作成功，会返回引用该实例的描述符，否则返回-1。3）注册描述符及事件int epoll_ctl（int epfd, int op, int fd, struct epoll_event *event）epoll模型将管理若干描述符及关心的事件（与select作用类似），这些管理功能均通过该函数表示。操作成功，返回0，否则返回-1。各参数含义：a）epfd为epoll实例描述符b）fd为要管理的描述符c）event为该描述符上关心的事件，类型为结构体类型：struct epoll_event&#123; __uint32_t events; epoll_data_t data;｝；events是由以下事件标志通过 | 运算得到的组合EPOLLIN：可读数据（有数据到达）EPOLLOUT：可写数据（可发送给对方）EPOLLPRI：对于流式套接字，收到了OOB数据EPOLLRDHUP：对方调用了close()或shutdown()，在ET模式下很有用EPOLLERR：发生错误的情况EPOLLET：启用ET（Edge Triggered，边缘触发，状态发生变化）模式，默认模式为LT（Level Triggered，条件或水平触发，状态不变，但总满足“操作就绪”的要求）EPOLLONESHOT：只使用一次，单独使用无意义除上述标志以外，Linux的不同版本还增加了其它事件标志。data成员表示事件对应的数据，其定义为：typedef union epoll_data&#123; void *ptr; int fd; __uint32_t u32; __uint64_t u64;｝epoll_data_t；d）op表示要执行的管理操作，有三个：EPOLL_CTL_XXX，其中XXX是ADD、DEL、MOD三者之一，分别表示新注册、删除已有、修改已有4）进行监控int epoll_wait（int epfd, struct epoll_event *events, int maxevents, int timeout）执行完成后，若有描述符上期待的事件发生，返回描述数个数；若超时，返回0；若出错，返回-1。参数含义为：a）epfd，epoll实例的描述符b）events，用户动态申请的内存空间，用于存放产生事件的描述符等信息，若有n个描述符上产生了期待的事件，这n个描述符的相关信息存放在events的前n个元素中c）maxevents，events空间大小d）timeout，该参数与select模型中的不同，它以毫秒为单位设置时间间隔。若为0，调用会立即返回；若为-1，则无限期等待，直至出错或有描述符发生事件；若为其它值，则会等待指定的时间间隔，在此时间内，若有事件发生，会返回，否则会等到超时再返回。该参数设置会影响性能 123456789101112131415一、数据报套接字的两种通信模式1、客户机/服务器模式也可称为主从模式，服务器不主动向客户机发送数据，而是处于等待状态，客户机主动发起数据通信的过程，类似于流式套接字的工作模式。在该模式中，服务器需要绑定操作，客户机不需要。2、对等模式既向不特定主机发送信息，也接收不特定主机发送来的信息。在该模式中，参与通信方均需要绑定操作。 12345672、epoll模型1）epoll是Linux上的高性能I/O模型。Kqueue是FreeBSD系统中的模型，Windows是IOCP模型。2）下图中体现select与epoll模型性能的差异，很明显，当连接数量较大时，select模型的性能明显下降，epoll模型的性能比较稳定，不会随着管理描述数量的增加出现明显性能下降的情况。3）epoll适用于连接数量较多，但活动连接数量相对较少的情况。 123451、WSAAsyncSelect概述1）当协议栈检测到某个套接字上有数据到达（事件）时，便会向该套接字所属应用发送通知消息，应用收到消息后再进行处理。这种方式使用起来非常自然，也符合Windows系统的特性，即事件（套接字状态变化） -&gt; 消息传递（向应用发送消息） -&gt; 响应（应用程序处理）。2）WSAAsyncSelect是另一种I/O复用模型，非常适合GUI界面的应用。 123453、select模型1）该关注的套接字（描述符）存储在fd_set集合中，select模型会监控一段时间内集合中所有有效的套接字是否“操作就绪”，若是会保留下来，否则会将该套接字移出集合，对于仍然存在于集合中的套接字，可以直接进行相应的操作，而不必再花时间等待。2）对套接字的关注只有三种类型：数据是否可读？数据是否可写？是否发生错误？为方便，模型按感兴趣的类型将套接字集合分为三种，某个套接字可以只加入一个集合，也可以同时加入多个集合。 1TIME_WAIT出现的原因","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://humancloud.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"剑指offer笔记/1","slug":"剑指offer笔记/1","date":"2020-04-05T06:59:46.860Z","updated":"2020-10-31T15:57:53.653Z","comments":true,"path":"2020/04/05/剑指offer笔记/1/","link":"","permalink":"https://humancloud.github.io/2020/04/05/%E5%89%91%E6%8C%87offer%E7%AC%94%E8%AE%B0/1/","excerpt":"","text":"1. 面试官希望应聘者的代码能完成基本功能,还会关注是否考虑了边界条件,特殊输入(空指针,空字符串等),反映了平时的编程习惯 平常代码要写健全,面试时也会习惯 1234567891011121314151617181920微软面试开发工程师最常用的问题: 把一个字符串转成整数//这回答完全不对啊,就算字符串都是数字字符,也转不对int StrtoInt(char *string)&#123; int num = 0; while(*string != 0) &#123; num = num*10 + *string - '\\0'; ++string; &#125; return num;&#125; //正确做法","categories":[],"tags":[]},{"title":"这是一篇示例文章","slug":"example","date":"2020-04-05T03:51:04.000Z","updated":"2020-04-05T11:14:10.458Z","comments":true,"path":"2020/04/05/example/","link":"","permalink":"https://humancloud.github.io/2020/04/05/example/","excerpt":"前言 Hexo博客美化配置,这篇文章讲解了,Hexo博客的美化与配置","text":"前言 Hexo博客美化配置,这篇文章讲解了,Hexo博客的美化与配置 标题1内容1 标题2内容2 如果您喜欢我的文章,欢迎关注下面的我滴公众号","categories":[],"tags":[]},{"title":"network","slug":"network","date":"2020-03-22T07:06:29.275Z","updated":"2020-04-05T02:57:51.619Z","comments":true,"path":"2020/03/22/network/","link":"","permalink":"https://humancloud.github.io/2020/03/22/network/","excerpt":"作业:1、查看listen的man page信息，了解backlog的作用，下次找同学回答。123456789101112backlog::允许同时与服务器连接的客户端数量 查看系统默认backlog:cat /proc/sys/net/ipv4/tcp_max_syn_backlog 监听端口后,被动套接字等待连接(listen函数把套接字变成被动套接字,accept函数阻塞等待连接),此时系统中维护着两个队列,第一个队列存放的是已建立连接的套接字(即完成三次握手后的established),第二个队列是未建立连接的套接字(处于三次握手中的syn_rcvd),每次accept会将第一个队列中的套接字返回,进行通信,以完成网络传输linux2.2以前,backlog表示两个队列总和的长度linux2.2以后,backlog表示已完成连接的队列的长度","text":"作业:1、查看listen的man page信息，了解backlog的作用，下次找同学回答。123456789101112backlog::允许同时与服务器连接的客户端数量 查看系统默认backlog:cat /proc/sys/net/ipv4/tcp_max_syn_backlog 监听端口后,被动套接字等待连接(listen函数把套接字变成被动套接字,accept函数阻塞等待连接),此时系统中维护着两个队列,第一个队列存放的是已建立连接的套接字(即完成三次握手后的established),第二个队列是未建立连接的套接字(处于三次握手中的syn_rcvd),每次accept会将第一个队列中的套接字返回,进行通信,以完成网络传输linux2.2以前,backlog表示两个队列总和的长度linux2.2以后,backlog表示已完成连接的队列的长度 2、查看recv的man page信息，了解recv返回值的信息，下次解答12345678recv函数原型为: ssize_t recv(int sockfd, void *buf, size_t len, int flags);参数:第一个参数：接收端的套接字描述符第二个参数：接受数据的缓冲区第三个参数：缓冲区的尺寸，sizeof（）第四个参数：置0 原理: 123456789101112当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，如果协议在传送s的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR；如果s的发送缓冲中没有数据或者数据被协议成功发送完毕后，recv先检查套接字s的接收缓冲区，如果s接收缓冲区中没有数据或者协议正在接收数据，那么recv就一直等待，直到协议把数据接收完毕；当协议把数据接收完毕，recv函数就把s的接收缓冲中的数据copy到buf中注意协议接收到的数据可能大于buf的长度，所以在这种情况下要调用几次recv函数才能把s的接收缓冲中的数据copy完。recv函数仅仅是copy数据，真正的接收数据是协议来完成的，recv函数返回其实际copy的字节数；如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。 返回值: 12345678910111213如果recv函数成功，返回值大于0，返回的是其实际copy的字节数；如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。EAGAIN：套接字已标记为非阻塞，而接收操作被阻塞或者接收超时EBADF：sock不是有效的描述词ECONNREFUSE：远程主机阻绝网络连接EFAULT：内存空间访问出错EINTR：操作被信号中断EINVAL：参数无效ENOMEM：内存不足ENOTCONN：与面向连接关联的套接字尚未被连接上ENOTSOCK：sock索引的不是套接字 send函数: 12原型:ssize_t send(int sockfd, const void *buf, size_t len, int flags); 返回值: 1231. s 指定发送端套接字描述符。2. buff 表示存放发送数据的缓冲区。 3. 实际要发送的字节数， 原理: 1234567891011121314151617当调用该函数时，send先比较待发送数据的长度len和套接字s的发送缓冲区的长度，如果len大于s的发送缓冲区的长度，该函数返回SOCKET_ERROR； 如果len小于或者等于s的发送缓冲区的长度，那么send先检查协议是否正在发送s的发送缓冲中的数据； 如果是就等待协议把数据发送完，如果协议还没有开始发送s的发送缓冲中的数据或者s的发送缓冲中没有数据，那么send就比较s的发送缓冲区的剩余空间和len； 如果len大于剩余空间大小，send就一直等待协议把s的发送缓冲中的数据发送完，如果len小于剩余空间大小，send就仅仅把buf中的数据copy到剩余空间里（注意并不是send把s的发送缓冲中的数据传到连接的另一端的，而是协议传的，send仅仅是把buf中的数据copy到s的发送缓冲区的剩余空间里）。 如果send函数copy数据成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR； 如果send在等待协议传送数据时网络断开的话，那么send函数也返回SOCKET_ERROR。要注意send函数把buf中的数据成功copy到s的发送缓冲的剩余空间里后它就返回了，但是此时这些数据并不一定马上被传到连接的另一端。 如果协议在后续的传送过程中出现网络错误的话，那么下一个Socket函数就会返回SOCKET_ERROR。（每一个除send外的Socket函数在执行的最开始总要先等待套接字的发送缓冲中的数据被协议传送完毕才能继续，如果在等待时出现网络错误，那么该Socket函数就返回SOCKET_ERROR #### 3、为客户端加上退出机制 12345if (strcmp(bufOut,\"bye\")==0) &#123; printf(\"you input bye\"); break; &#125; 4、为服务端加上特殊的“停止服务”功能。(确定对方是管理员才退出,否则不退出)本节课内容:12345678910111213141516171819202122232425262728293031323334353637383940udp: recvfrom不一定接收到对端发来的信息,因为udp不检查对端是否收到,tcp检查吗浏览器访问www.qq.com:7777是访问不了的,因为服务器上没有应用程序运行在7777端口服务端:1、创建流式套接字，目的是监听连接请求2、绑定对外公布的地址信息3、确定连接请求队列大小，进入监听套接字监听状态4、当有客户端的连接请求到来时，创建一个为该客户端提供1对1服务的流式套接字，它只起数据传输作用，称为响应套接字5、响应套接字与客户端套接字成为通信双方，这个通信是有连接的，在此基础上，可以按照通信规程（业务逻辑）传输数据5.1、发送数据：将数据从应用程序缓冲区复制到套接字的发送缓冲区，至于何时真正发送到对方，由协议栈决定5.2、接收数据：将数据从套接字的接收缓冲区移动到应用程序的缓冲区，6、数据传输完成后，可关闭响应套接字7、一般情况下，不关闭监听套接字，除非有特殊要求客户端:1、创建流式套接字2、根据服务端公布的地址信息，连接到服务端3、连接成功后，可以按照通信规程（业务逻辑）传输数据3.1、发送数据：将数据从应用程序缓冲区复制到套接字的发送缓冲区，至于何时真正发送到对方，由协议栈决定3.2、接收数据：将数据从套接字的接收缓冲区移动到应用程序的缓冲区，4、数据传输完成后，可关闭套接字","categories":[],"tags":[]},{"title":"network-2","slug":"network-2","date":"2020-03-22T07:06:29.265Z","updated":"2020-05-31T12:58:01.016Z","comments":true,"path":"2020/03/22/network-2/","link":"","permalink":"https://humancloud.github.io/2020/03/22/network-2/","excerpt":"前言: 笔记linux系统中维护着两个队列 第一个队列存放的是已建立连接的套接字(即完成三次握手后的established), 第二个队列是未建立连接的套接字(处于三次握手中的syn_rcvd), 每次accept会将第一个队列中的套接字返回,进行通信,以完成网络传输","text":"前言: 笔记linux系统中维护着两个队列 第一个队列存放的是已建立连接的套接字(即完成三次握手后的established), 第二个队列是未建立连接的套接字(处于三次握手中的syn_rcvd), 每次accept会将第一个队列中的套接字返回,进行通信,以完成网络传输 图中仅给出了第一个队列,这个队列的连接已经被TCP接收（已经完成三次握手），但是还没有被应用程序接收（调用accept函数) 1234567监听端口后,被动套接字等待连接(socket函数产生套接字(默认为主动套接字),bind函数绑定端口,listen函数把套接字变成被动套接字,accept函数阻塞等待连接客户端使用connect函数主动与服务器建立连接,服务器accept接收连接,accept函数返回连接套接字,两端通过连接套接字进行通信) listen函数 123456listen函数int listen(int sockfd, int backlog);linux2.2以前,backlog表示两个队列总和的长度linux2.2以后,backlog表示已完成连接的队列的长度,当长度超过会忽略客户端的请求连接 实验1将服务端的listen函数第二个参数设置为0 可以看到,我打开了个5客户端, 123456netstat | grep tcp查看信息,可以看到,前两对客户端的状态是established后面三个客户端(不是3对了),状态是syn_sent(表示请求连接),也就是客户端在请求与服务器连接在一段时间后,后面三个客户端报错了-连接超时(说明服务器忽略了后面三个连接请求,因为达到了队列最大长度) 设置为1 123456netstat | grep tcp查看信息,可以看到,前3对客户端的状态是established后面两个状态是syn_sent(表示请求连接),也就是客户端在请求与服务器连接在一段时间后,后面2个客户端报错了-连接超时 实现1结论:12345backlog设置为0 : 可以与2个客户端建立tcp连接backlog设置为1 : 可以与3个客户端建立tcp连接&lt;&lt;Unix网络编程&gt;&gt;说backlog从未有过正式的定义, 实验2:123456789sockC = accept(sock, (struct sockaddr*)&amp;addrC, &amp;sizeAddr);if(-1 == sockC) &#123; printf(\"accept() error : %d -&gt; %s\\n\", errno, strerror(errno)); continue; &#125;printf(\"accept call\\n\");在accept函数后面加上信息,输出\"accept call\"表示accept已经执行完毕并返回 此时来看一下 第一个客户端与服务器建立连接,可以看到输出了客户端1的ip端口信息并且可以看到accept函数调用成功并返回了,再打开第二个客户端,服务器并没有响应此时客户端1可以与服务器通信但客户端2不可以 结束第一个客户端,可以看到此时第二个客户端连接到服务器并调用了accept函数, 注意: 1234567shell命令netstat查看信息(左下角终端)netstat | grep tcp可以看到有两对连接两对连接都是established状态,即两个客户端都已经与服务器建立了Tcp连接,进入连接队列","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://humancloud.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"pip更换国内源","slug":"pip","date":"2020-03-09T04:33:07.000Z","updated":"2020-04-11T02:03:56.761Z","comments":true,"path":"2020/03/09/pip/","link":"","permalink":"https://humancloud.github.io/2020/03/09/pip/","excerpt":"","text":"pip更换国内源将会有几兆每秒的速度 步骤 12345678mkdir ~/.pipvim ~/.pip/pip.conf打开文件后,输入以下信息,即可使用清华源[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host = https://pypi.tuna.tsinghua.edu.cn 使用easy_install来安装模块 1234567easy_install 换源cd /root 注意要放到/root目录下vi .pydistutils.cfg 打开配置文件[easy_install]index-url=http://mirrors.aliyun.com/pypi/simple/find-links=http://mirrors.aliyun.com/pypi/simple/","categories":[],"tags":[]}],"categories":[{"name":"Git","slug":"Git","permalink":"https://humancloud.github.io/categories/Git/"},{"name":"算法","slug":"算法","permalink":"https://humancloud.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"面试小总结","slug":"面试小总结","permalink":"https://humancloud.github.io/categories/%E9%9D%A2%E8%AF%95%E5%B0%8F%E6%80%BB%E7%BB%93/"},{"name":"C语言","slug":"C语言","permalink":"https://humancloud.github.io/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"网络编程","slug":"网络编程","permalink":"https://humancloud.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]}