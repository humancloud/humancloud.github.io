{"meta":{"title":"L.R.K","subtitle":"","description":"Welcome!","author":"L.R.K","url":"https://humancloud.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-04-05T05:10:56.000Z","updated":"2020-04-05T05:13:47.982Z","comments":true,"path":"categories/index.html","permalink":"https://humancloud.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-05T05:10:45.000Z","updated":"2020-04-05T05:14:19.486Z","comments":true,"path":"tags/index.html","permalink":"https://humancloud.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"函数write与read","slug":"write-read","date":"2020-12-05T11:03:27.000Z","updated":"2020-12-05T12:26:05.058Z","comments":true,"path":"2020/12/05/write-read/","link":"","permalink":"https://humancloud.github.io/2020/12/05/write-read/","excerpt":"解析Linux编程常用的write和read函数","text":"解析Linux编程常用的write和read函数 read（）函数将尝试从与打开文件描述符fildes关联的文件中读取nbyte字节到buf指向的缓冲区,但实际读取到的字节,取决于write端写了多少,或者取决于buffer的大小和第三个参数的大小.write() 函数写nbyte字节数据到描述符,不管write的第二个参数的buffer是多大,都会像 12","categories":[],"tags":[]},{"title":"C指针常用","slug":"C指针常用","date":"2020-11-27T10:19:07.000Z","updated":"2020-11-27T10:19:07.051Z","comments":true,"path":"2020/11/27/C指针常用/","link":"","permalink":"https://humancloud.github.io/2020/11/27/C%E6%8C%87%E9%92%88%E5%B8%B8%E7%94%A8/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"IOCCC1984-02","slug":"IOCCC1984-02","date":"2020-11-20T13:44:06.000Z","updated":"2020-11-22T11:47:04.599Z","comments":true,"path":"2020/11/20/IOCCC1984-02/","link":"","permalink":"https://humancloud.github.io/2020/11/20/IOCCC1984-02/","excerpt":"作者： Sjoerd Mullender and Robbert van Renesse源文件： mullender.c","text":"作者： Sjoerd Mullender and Robbert van Renesse源文件： mullender.c 源文件mullender.c 12345678910short main[] = &#123; 277, 04735, -4129, 25, 0, 477, 1019, 0xbef, 0, 12800, -113, 21119, 0x52d7, -1006, -7151, 0, 0x4bc, 020004, 14880, 10541, 2056, 04010, 4548, 3044, -6716, 0x9, 4407, 6, 5568, 1, -30460, 0, 0x9, 5570, 512, -30419, 0x7e82, 0760, 6, 0, 4, 02400, 15, 0, 4, 1280, 4, 0, 4, 0, 0, 0, 0x8, 0, 4, 0, ',', 0, 12, 0, 4, 0, '#', 0, 020, 0, 4, 0, 30, 0, 026, 0, 0x6176, 120, 25712, 'p', 072163, 'r', 29303, 29801, 'e'&#125;; 源文件目录下的hint.text部分内容123456789101112131415161718192021222324252627282930313233&gt; NOTE: If your machine is not a Vax-11 or pdp-11, this program will&gt; not execute correctly. In later years, machine dependent&gt; code was discouraged.The C startup routine (via crt0.o) transfers control to a locationnamed main. In this case, main just happens to be in the data area.The array of shorts, which has been further obfuscated by use ofdifferent data types, just happens to form a meaningful set of PDP-11and Vax instructions. The first word is a PDP-11 branch instructionthat branches to the rest of the PDP code. On the Vax main is called withthe calls instruction which uses the first word of the subroutine as amask of registers to be saved. So on the Vax the first word can be anything.The real Vax code starts with the second word. This small programmakes direct calls to the write() Unix system call to produce amessage on the screen. Can you guess what is printed? We knew youcouldn&#39;t! :-)翻译:&gt;注意：如果您的机器不是Vax-11或pdp-11，此程序将&gt;执行不正确。在未来,代码是依赖机器的&gt;这样的代码是不被鼓励的。C启动程序（通过crt0.o）将控制权转移到一个位置命名为main。在本例中，main正好在数据区域中。进一步使用了shorts的数组不同的数据类型，恰好形成了一组有意义的PDP-11和Vax指令。第一个字是PDP-11分支指令这将分支到PDP代码的其余部分。在Vax主管道上使用子例程的第一个字作为要保存的寄存器掩码。所以在Vax上第一个词可以是任何东西。真正的Vax代码从第二个单词开始。这个小程序直接调用write（）Unix系统调用以生成屏幕上的消息。你能猜出打印的是什么吗？我们知道你不能！:-) 分析写一个测试程序,只有一个主函数test.c 1234int main()&#123;&#125; 对比两个文件的反汇编 1234567891011test.s里面main标号表示main函数,也标志着程序开始执行的地方(由于内存中数据和指令是放在一起的,main标号的作用就是标志着main标号下面的数据都被当做指令处理,不被当做数据处理)而mullender.s里面也有main标号,这个main标号本来的意思是标志数组main的起始,main下面的数据是main数组的数据,而不是指令,但是由于main是有特殊意义的,所以最终执行时main标号下面的内存块的数据都被当做指令去执行,而main下面的数据是什么那, main标号下面是汇编器指令.value,.value将main数组中的元素存储在main标号内存地址下面(注意: 汇编程序中以.开头的名称并不是指令的助记符，不会被翻译成机器指令,所以最终可执行程序里main下面的所有数据都被当做机器码去执行)所以这个程序是可以执行的,而且会执行一些指令,但是要看机器平台了,源程序的目录下有文件说此程序只能运行在pdp-11或Vax-11机器上,其他平台可能会发生错误.&gt; NOTE: If your machine is not a Vax-11 or pdp-11, this program will&gt; not execute correctly. 使用gdb调试器证明main下的数据被当做指令执行123456789101112131415161718已知一下机器代码代表的汇编代码00 c0 add %al,%al08 c4 or %al,%ah编写一个简单的c程序如下short main[] = &#123;0xc000,0xc408&#125;;然后使用gdb反汇编得到结果如下(gdb) disassemble mainDump of assembler code for function main:0x0000000000004028 &lt;+0&gt;: add %al,%al0x000000000000402a &lt;+2&gt;: or %al,%ahEnd of assembler dump.(gdb)直接调试源文件查看汇编,也是一样,只是这里用了一个较小的文件,比较好看. 在pdp11模拟器上运行 使用pdp11模拟器,搭建unix v6系统运行程序但是编译错误,说声明语法有错误,查看了一下unix上的一些c文件,发现原来以前数组是这样初始化的 修改程序后还是编译错误,原来是unix v6不支持0x开头的十六进制数字,而且也没有short数据类型。。。。 重新使用模拟器搭建unix v7系统运行程序,终于可以运行了。。 运行结果 Linux下制作动态图ffmpeg -i xxx.mp4 xxx.gif 程序原理使用adb调试程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122# adb a.out:sstopped at start: setd:sa.out: runningstopped at start+02: mov 02(sp),r0$rps 0170010pc 02 start+02sp 0177720r5 0r4 0r3 0r2 0r1 06r0 012start+02: mov 02(sp),r0:sa.out: runningstopped at start+06: clr 0177776(r0):sa.out: runningstopped at start+012: mov sp,r0:sa.out: runningstopped at start+014: sub $04,sp:sa.out: runningstopped at start+020: mov 04(sp),(sp):sa.out: runningstopped at start+024: tst (r0)+:sa.out: runningstopped at start+026: mov r0,02(sp):sa.out: runningstopped at start+032: tst (r0)+:sa.out: runningstopped at start+034: bne start+032:sa.out: runningstopped at start+032: tst (r0)+:sa.out: runningstopped at start+034: bne start+032:sa.out: runningstopped at start+036: cmp r0,*02(sp):sa.out: runningstopped at start+042: bcs start+046:sa.out: runningstopped at start+046: mov r0,04(sp):sa.out: runningstopped at start+052: mov r0,_environ:sa.out: runningstopped at start+056: jsr pc,__cleanu+04:sa.out: runningstopped at __cleanu+04: br __cleanu+060:sa.out: runningstopped at __cleanu+060: mov pc,r4:sa.out: runningstopped at __cleanu+062: tst -(r4):sa.out: runningstopped at __cleanu+064: sub $011,r4:sa.out: runningstopped at __cleanu+070: mov r4,_main+076:sa.out: runningstopped at __cleanu+074: mov $01,r0:sa.out: runningstopped at __cleanu+0100: sys write; 0161; 011$rps 0170000pc 0212 __cleanu+0100sp 0177712r5 0r4 0161 _main+043r3 0r2 0r1 06r0 01__cleanu+0100: sys write; 0161; 011:sa.out: runningstopped at __cleanu+0112: sys tiu:sa.out: runningstopped at __cleanu+0112: sys tiu:sa.out: runningstopped at __cleanu+0112: sys tiu:sa.out: runningstopped at __cleanu+0112: sys tiu:sa.out: runningstopped at __cleanu+0112: sys tiu:sa.out: runningstopped at __cleanu+0112: sys tiu:sa.out: runningstopped at __cleanu+0112: sys tiu:sa.out: runningstopped at __cleanu+0112: sys tiu继续执行,后面一直都是stopped at __cleanu+0112: sys tiu 由于暂时对pdp-11和Vax指令很不了解, 详细过程暂时还是没有搞懂 如果您对pdp-11和Vax指令比较了解,并想了解原理,那么这篇博客有可能会帮到你","categories":[{"name":"IOCCC","slug":"IOCCC","permalink":"https://humancloud.github.io/categories/IOCCC/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"C表达式","slug":"C表达式","date":"2020-11-18T15:22:46.000Z","updated":"2020-11-19T16:24:05.062Z","comments":true,"path":"2020/11/18/C表达式/","link":"","permalink":"https://humancloud.github.io/2020/11/18/C%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"","categories":[{"name":"C语言","slug":"C语言","permalink":"https://humancloud.github.io/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"IOCCC分享","slug":"IOCCC分享","date":"2020-11-18T12:41:01.000Z","updated":"2020-11-18T12:54:57.033Z","comments":true,"path":"2020/11/18/IOCCC分享/","link":"","permalink":"https://humancloud.github.io/2020/11/18/IOCCC%E5%88%86%E4%BA%AB/","excerpt":"IOCCC官方网站下载代码 由于下载代码需要上外网,所以我将1984-2019的所有代码,放在了github上. 代码","text":"IOCCC官方网站下载代码 由于下载代码需要上外网,所以我将1984-2019的所有代码,放在了github上. 代码","categories":[{"name":"IOCCC","slug":"IOCCC","permalink":"https://humancloud.github.io/categories/IOCCC/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"1984IOCCC代码解析","slug":"IOCCC1984-01","date":"2020-11-18T09:39:39.000Z","updated":"2020-11-26T08:25:42.434Z","comments":true,"path":"2020/11/18/IOCCC1984-01/","link":"","permalink":"https://humancloud.github.io/2020/11/18/IOCCC1984-01/","excerpt":"anonymous.c时间: 1984作者: 作者匿名提交了此代码","text":"anonymous.c时间: 1984作者: 作者匿名提交了此代码 源代码: 12int i;main()&#123;for(;i[\"]&lt;i;++i)&#123;--i;&#125;\"];read('-'-'-',i+++\"hell\\o, world!\\n\",'/'/'/'));&#125;read(j,i,p)&#123;write(j/p+p,i---j,i/i);&#125; 解析初步手动格式化123456789101112131415int i; main()&#123; for(;i[\"]&lt;i;++i) //如果编辑器没有高亮,还是不容易看出来这里的格式化不对,其实这里是作者故意迷惑你的 &#123; --i; &#125; \"]; read('-'-'-',i+++\"hello, world!\\n\",'/'/'/'));&#125;read(j,i,p)&#123; write(j/p+p,i---j,i/i);&#125; 更容易理解的格式123456789101112131415161718192021#define STR \"]&lt;i;++i)&#123;--i;&#125;\"int i;int main()&#123; for(;STR[i];read(0,\"hello,world!\\n\"+i++,1)) // '-' - '-' (是两个字符相减)为0, '/' / '/' (两个字符相除)为1 arr[1] 相当于 1[arr] 运算结果相同 ; // 当STR[i] 为0时循环结束即当字符串到结束符时结束循环(一共14次循环)&#125; // 字符串字面值是字符串的首地址,\"hello,world!\\n\" + i++ 的值就是字符串的第i个字符int read(int j,int i,int p)&#123; write(1,i--,1); // i-- i先被使用后自减, 然而每次函数调用i都更新,所以i减不减1都与最后结果无任何关系 // STDIN_FILENO 0, STDOUT_FILENO 1, STDERR_FILENO 2&#125;循环14次,\"hello,world!\\n\"一个14个字符(字符串末尾有空字符'\\0'),每一个字符都使用write系统调用输出到标准输出STDOUT_FILENO程序功能就是输出hello,world!\\n但是在某些机器上运行,没有结果输出(在我的机器上测试时也没有输出)(原因见下面的疑问与解答) 疑问与解答 为什么write函数当做系统调用,read不被当做系统调用那? 由于用户自定义的函数优先,而read函数在源文件中有自己的定义所以不会被当做系统调用. 注意: 如果在当今的C语言中包含了unistd.h头文件,那么里面有read函数的声明,再去自定义read函数会命名冲突,发生错误 为什么没有输出也没有报错那? 1234567891011121314151617181920212223242526272829303132333435363738394041424344我运行代码发现程序并没有输出我们期望的hello,world!,而是什么也没有输出.原因:\"hello,world!\\n\" + i++ 得到的是一个指针,这个指针指针指向一个字符,write系统调用第二个参数也是一个char指针,但是此代码read函数过程中将指针转为int,write函数中再将int转回指针,由于64位机器,指针占8字节,整数占4字节,所以数据一定会丢失,指针将不再正确,write系统调用会失败,而程序并没有检查write系统调用是否正确执行,所以看起来没有报错.加上错误处理:#include &lt;stdio.h&gt;int i;main()&#123; for(; i[\"]&lt;i;++i)&#123;--i;&#125;\"]; read('-'-'-',i+++\"hello, world!\\n\",'/'/'/'));&#125;read(j,i,p) &#123; int n = write(j/p+p,i---j,i/i); if(-1 == n)&#123; perror(\"write\"); &#125;&#125;输出:➜ anonymous git:(master) ./mytestwrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad address如果你的机器是32位的,那么指针和int都是四字节,相互转换不会有问题 下面使用gdb调试继续分析上个问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051使用此代码:1 #include &lt;stdio.h&gt;2 int i;3 main()4 &#123;5 for(; i[\"]&lt;i;++i)&#123;--i;&#125;\"]; read('-'-'-',i+++\"hello, world!\\n\",'/'/'/'));6 &#125;78 read(j,i,p) 9 &#123;10 int n = write(j/p+p,i---j,i/i);11 if(-1 == n)&#123;12 perror(\"write\");13 &#125;14&#125;➜ anonymous git:(master) gcc anonymous.c -o anonymous -g➜ anonymous git:(master) gdb anonymous(gdb) b 5Breakpoint 1 at 0x114d: file mytest.c, line 5.(gdb) b 10Breakpoint 2 at 0x11b0: file mytest.c, line 10.(gdb) rStarting program: /home/lu/code/c/IOCCC/1984/anonymous/mytestBreakpoint 1, main () at mytest.c:55 for(; i[\"]&lt;i;++i)&#123;--i;&#125;\"]; read('-'-'-',i+++\"hello, world!\\n\",'/'/'/'));(gdb) x/14b \"hello, world!\\n\"0x5555555592a0: 104 101 108 108 111 44 32 1190x5555555592a8: 111 114 108 100 33 10(gdb) nBreakpoint 2, read (j=0, i=1431658500, p=1) at mytest.c:1010 int n = write(j/p+p,i---j,i/i);(gdb) info argsj = 0i = 1431658500p = 1可以看到字符串首地址为0x5555555592a0read函数的第二个参数i的值为1431658500 -&gt; 0x55556003指针的值: 0x55 55 55 55 92 a0 00 00转为int后的值: 0x55 55 60 03明显看到丢失了数据 正确运行 在pdp-11模拟器上的unix v7上面运行代码 可看到Unix v7上int类型和指针类型都是2字节,相互转换数据不会丢失","categories":[{"name":"IOCCC","slug":"IOCCC","permalink":"https://humancloud.github.io/categories/IOCCC/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言常用宏实现","slug":"C语言常用宏","date":"2020-10-04T14:13:00.000Z","updated":"2020-11-18T09:32:10.233Z","comments":true,"path":"2020/10/04/C语言常用宏/","link":"","permalink":"https://humancloud.github.io/2020/10/04/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%AE%8F/","excerpt":"前言C语言宏功能强大,但一不小心就会用错,许多经典书籍都曾讲过C语言宏的强大功能,此篇文章是参考C陷阱与缺陷书籍和网上其他文章总结的","text":"前言C语言宏功能强大,但一不小心就会用错,许多经典书籍都曾讲过C语言宏的强大功能,此篇文章是参考C陷阱与缺陷书籍和网上其他文章总结的 根据书籍写此篇文章 编程常用宏(常更新)max函数宏 12345错误版#define max(a,b) ((a)&gt;(b))?(a):(b)a或b会被计算两次,如果每次计算a或b都改变,那么最后得到的结果与预想中的会不同 123456789Linux Kernel 版#define max(x,y) (&#123; \\ typeof(x) _max1 = (x); \\ typeof(y) _max2 = (y); \\ (void)(&amp;_max1 == &amp;_max2); \\ _max1 &gt; _max2 ? _max1:_max2;&#125;)x或y只会被计算一次 assert宏 , swap宏","categories":[{"name":"C语言","slug":"C语言","permalink":"https://humancloud.github.io/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"pip更换国内源","slug":"pip","date":"2020-03-09T04:33:07.000Z","updated":"2020-11-18T08:52:43.347Z","comments":true,"path":"2020/03/09/pip/","link":"","permalink":"https://humancloud.github.io/2020/03/09/pip/","excerpt":"pip更换国内源可加快下载速度","text":"pip更换国内源可加快下载速度 步骤 12345678mkdir ~/.pipvim ~/.pip/pip.conf打开文件后,输入以下信息,即可使用清华源[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host = https://pypi.tuna.tsinghua.edu.cn 使用easy_install来安装模块 1234567easy_install 换源cd /root 注意要放到/root目录下vi .pydistutils.cfg 打开配置文件[easy_install]index-url=http://mirrors.aliyun.com/pypi/simple/find-links=http://mirrors.aliyun.com/pypi/simple/","categories":[],"tags":[]}],"categories":[{"name":"IOCCC","slug":"IOCCC","permalink":"https://humancloud.github.io/categories/IOCCC/"},{"name":"C语言","slug":"C语言","permalink":"https://humancloud.github.io/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]}