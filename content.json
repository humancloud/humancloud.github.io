{"meta":{"title":"Hu","subtitle":"","description":"Welcome!","author":"Hu","url":"https://humancloud.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-04-05T05:10:56.000Z","updated":"2020-04-05T05:13:47.982Z","comments":true,"path":"categories/index.html","permalink":"https://humancloud.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-05T05:10:45.000Z","updated":"2020-04-05T05:14:19.486Z","comments":true,"path":"tags/index.html","permalink":"https://humancloud.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"网络编程考试总结","slug":"网络编程考试总结","date":"2020-05-31T12:56:25.000Z","updated":"2020-06-02T00:05:47.482Z","comments":true,"path":"2020/05/31/网络编程考试总结/","link":"","permalink":"https://humancloud.github.io/2020/05/31/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/","excerpt":"前言: 笔记linux多线程的同步即 sem 和 互斥量 程序设计题不涉及多线程,不会使用到select,epoll,WSA等模型,有字符串处理 简答五选三(背五道题)","text":"前言: 笔记linux多线程的同步即 sem 和 互斥量 程序设计题不涉及多线程,不会使用到select,epoll,WSA等模型,有字符串处理 简答五选三(背五道题) 函数总结TCP echo服务器用到的函数 12345#include &lt;unistd.h&gt;int close(int fd);成功返回0,失败返回-1,其他返回值通过man了解 123456789101112131415161718192021222324252627282930313233343536#include&lt;netinet/in.h&gt;struct sockaddr_in&#123; uint8_t sin_len; sa_family_t sin_family; in_port_t sin_port; struct in_addr sin_addr; char sin_zero[8];&#125;;struct in_addr&#123; in_addr_t s_addr;&#125;用到的就三个: sin_family, sin_port, sin_addr.s_addr#include&lt;sys/socket.h&gt;struct sockaddr&#123; uint8_t sa_len; sa_family_t sa_family; char sa_data[14];&#125;struct sockaddr_in addr;(struct sockaddr *)&amp;addr; //主要作用就是强制转换sockaddr_in类型为sockaddr类型 123456789101112#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;int socket(AF_INET, SOCK_STREAM,0);int socket(AF_INET,SOCK_DGRAM,0);AF_INET ipv4AF_INET6 ipv6SOCK_STREAM tcpSOCK_DGRAM udp使用指定参数创建一个套接字 123456#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);将创建的套接字标记为被动套接字,等待客户端连接 12345678910111213#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);阻塞等待连接请求到达,连接请求到达后,创建连接套接字,客户端与服务器使用连接套接字通信#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 123456789#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t send(int sockfd, const void *buf, size_t len, int flags);ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);send 和recv 函数只能用于tcp, sendto和recvfrom函数可以用于udp也可用于tcp 1234567#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t recv(int sockfd, void *buf, size_t len, int flags);ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); 123456789101112write#include &lt;unistd.h&gt; ssize_t write(int fd, const void *buf, size_t count);read#include &lt;unistd.h&gt; ssize_t read(int fd, void *buf, size_t count); 1234567891011121314151617181920212223242526inet_ntop()#include &lt;arpa/inet.h&gt;将网络字节序转为ip地址const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);inet_pton()#include &lt;arpa/inet.h&gt;直接将ip地址转为网络字节序(不需要先转为主机字节序,再转为网络字节序)int inet_pton(int af, const char *src, void *dst);#include &lt;arpa/inet.h&gt; uint32_t htonl(uint32_t hostlong); //host to network long 主机字节序转网络字节序 l表示long,转ip,s表示short转port uint16_t htons(uint16_t hostshort); uint32_t ntohl(uint32_t netlong); uint16_t ntohs(uint16_t netshort); Tcp 服务器客户端通信过程12345678910111213141516服务器:socket() 创建套接字bind()listen() 将套接字标记为监听套接字accept() 阻塞等待客户端连接,收到连接请求后,建立连接返回连接套接字send,recv接收消息(或者使用write,read,或者sendto,recvfrom)客户端:socket() 创建套接字bind() 可隐式绑定connect() 连接服务器sendto() recvfrom() 收发消息(udp不能使用recv和send函数) Udp服务器客户端通信过程12345678910111213141516Udp不需建立连接,所以不需要accept不需要connect不需要listen服务器:socket() 创建套接字bind()recvfrom()sendto()客户端:socket() 创建套接字bind() 可以隐式绑定sendto() recvfrom() 非阻塞123456789101112131415161718192021222324252627282930313233343536371）阻塞（Blocked）：当调用某个函数时，若操作条件不具备，函数会一直处于等待状态，程序的执行进程会在该函数调用处停顿，直到操作完成或发生错误为止。2）非阻塞（Nonblocked）：当调用某个函数时，无论操作条件是否具备，函数均会立即返回，程序的执行进程不会在该函数调用处停顿，而是继续执行。1）SOCK_DGRAM及SOCK_STREAM类型的套接字均可以工作在阻塞模式或非阻塞模式2）Linux中，创建套接字的同时可以指定工作模式，例如socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0)上述代码会创建非阻塞模式的套接字。默认情况下，新建的套接字工作在阻塞模式如果要把工作在阻塞模式的套接字改为非阻塞模式,可以使用函数fcntl (下面参数里sockfd即为阻塞模式的套接字),(用法: 例如accept函数返回的套接字不能直接设置为非阻塞需要fcntl函数处理)fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK);1）非阻塞模式套接字的函数调用失败时，并不一定表示真的遇到了网络错误，应根据errno的值进行相应的处理2）若errno值为EAGAIN或EWOULDBLOCK，则表示操作条件目前并不具备，而不是遇到了网络错误 sockC &#x3D; accept(sock, (struct sockaddr*)&amp;addrC, &amp;sizeAddr); if(-1 &#x3D;&#x3D; sockC) &#123; if(errno !&#x3D; EAGAIN &amp;&amp; errno !&#x3D; EWOULDBLOCK) &#123; printf(&quot;accept() error : %d -&gt; %s\\n&quot;, errno, strerror(errno)); &#125; &#125; 多线程多线程创建管理1234567头文件#include&lt;pthread.h&gt; 编译时加上-pthtread参数pthread_t thread;pthread_create(&amp;thread,NULL,doThread,(void*)arg); /*创建线程,线程id为thread*/pthread_detach(thread); /* 分离线程,意思是线程函数执行完毕后系统自动回收线程 */pthread_join(thread,NULL); /* 等待线程函数结束(直到线程函数结束,代码不会向下执行),可以接收线程函数的返回值(线程函数返回值为void* 所以可以返回任何值) */ 多线程同步信号量 1234567891011线程的信号量与进程间通信中使用的信号量的概念是一样，它是一种特殊的变量，它可以被增加或减少，但对其的关键访问被保证是原子操作。如果一个程序中有多个线程试图改变一个信号量的值，系统将保证所有的操作都将依次进行。信号量的函数都以sem_开头，线程中使用的基本信号量函数有4个，它们都声明在头文件semaphore.h中。1. sem_init函数 该函数用于创建信号量 int sem_init(sem_t *sem, int pshared， unsigned int value);2. sem_wait函数 该函数用于以原子操作的方式将信号量的值减1。 int sem_wait(sem_t *sem);3. sem_post函数 该函数用于以原子操作的方式将信号量的值加1。 int sem_post(sem_t *sem);4. sem_destroy函数 该函数用于对用完的信号量的清理 int sem_destroy(sem_t *sem);sem_wait(); 到 sem_post(); 之间的代码是原子操作,不用管信号量的值是几,具体由操作系统管理 互斥量 12345pthread_mutex_t mutex; /* 创建锁*/pthread_mutex_init(&amp;mutex, NULL); /* 初始化锁 */pthread_mutex_lock(&amp;mutex); /* 上锁 */pthread_mutex_unlock(&amp;mutex); /* 解锁*/pthread_mutex_destroy(&amp;mutex); /* 销毁锁 */ select1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;sys/select.h&gt;int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict errorfds, struct timeval *restrict timeout); void FD_ZERO(fd_set *set) 将set清空为0 void FD_SET(int fd,fd_set *set) 将fd设置到set集合中去 void FD_CLR(int fd,fd_set *set) 将fd从set中清除出去 int FD_ISSET(int fd,fd_set *set) 判断文件描述符fd是否在set集合中( FD_ISSET() tests to see if a file descriptor is part of the set;) __FD_SETSIZE 系统定义的宏,表示文件描述符最多个数,一般是1024,也可以不加前面两个下划线即FD_SETSIZE使用过程:fd_set fsRead,fsRead2; //集合int Maxfd; //最大描述符struct timeval tmot; //超时时间int countFd; //select返回值,(满足条件的描述符个数)FD_ZERO(&amp;fsRead); //清空集合FD_SET(listenfd,&amp;fsRead); //将监听套接字放在集合中Maxfd = listenfd;//主循环while(1)&#123; //备份 fsRead2 = fsRead; //设置超时时间 tmot.tv_sec = 0; //秒 tmot.tv_usec = 200000; //微秒 //select函数 countFD = select(maxFD + 1, &amp;fsRead2, NULL, NULL, &amp;tmot); //返回值: 返回发生事件的套接字的个数 if(countFD == -1) &#123; printf(\"select() error : %d -&gt; %s\\n\", errno, strerror(errno)); &#125; else if(countFD == 0) &#123; /* 无就绪描述符,输出超时 */ //time out printf(\"select() timeout\\n\"); &#125;else&#123; for(k = 0; k &lt; maxFD + 1; k++) &#123; if(FD_ISSET(k, &amp;fsRead2)) /* 判断k是否在集合fsRead2中 */ &#123; if(k == listenfd)&#123; //发生事件的是监听套接字,说明有连接到来 int connfd = accept(); /* 把创建的连接描述符放在集合里 */ FD_SET(sockC, &amp;fsRead); if(sockC &gt; maxFD)&#123; maxFD = sockC; &#125; &#125;else&#123; //发生事件的是连接套接字,接收发来的消息,并回复 recv(); send(); &#125; &#125; &#125; &#125;&#125; winsock编程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576771）准备WinSock环境int WSAStartup（WORD wVersionRequested， LPWSADATA lpWSAData）a）参数1：为期待的版本，可以使用MAKEWORD（x，y）来指定版本，其中x为主版本，占据低字节，y为次版本，占据高字节，目前均使用2.0以上版本，常用2.2；b）参数2：指向一个WSADATA结构体，用于填充返回相关信息c）返回值：操作成功，返回0，否则返回错误代码。注意，在WinSock执行环境未准备好时，不能调用WSAGetLastError（）2）清除WinSock环境int WSACleanup（void）若成功返回0，否则返回SOCKET_ERROR。一般不会出错。3）获取错误int WSAGetLastError（void）返回当前线程上次WinSock操作失败时的具体错误代码。大部分WinSock错误代码以WSAE作为前辍4）设置I/O模式int ioctlsocket（SOCKET s，long cmd，u_long FAR *argp）a）s为指定套接字b）cmd为要执行的命令c）argp指向命令需要的参数d）返回值：操作成功返回0，否则返回SOCKET_ERRORe）设置为非阻塞模式时，cmd为FIONBIO，argp指向值为非0的整型变量5）关闭套接字int closesocket（SOCKET s）若操作成功返回0，否则返回SOCKET_ERROR。#include&lt;winsock2.h&gt;#pragma comment(lib,\"ws2_32\")int main()&#123; struct WSADATA wsd; int code = WSAStartup(0x0202,&amp;wsd); //0x0202表示版本 if(code != 0)&#123; printf(\"WSAStartup error: %d\",code); return -1; &#125; 其他与Linux一样 closesocket(sockfd); WSACleanup();&#125; 字符串处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758头文件#include&lt;string.h&gt;strstr(str,\"hello\"); 在字符串str中找到hello字符串返回hello字符串,找不到返回NULLstrchr(str,'\\n'); 在字符串str中寻找回车符strcmp(str,\"hello\"); 如果str字符串与\"hello\"字符串相等,那么返回0,其他返回值不常用strcat(str,\"hello\"); 在字符串str后面拼接上hello字符strcpy(str,\"hello\"); 把字符串hello拷贝给str,str原来的值被覆盖指针,指针也是处理字符串很好用的方式例如:分割http请求第一行GET /index.html HTTP/1.1首先提取出http请求的第一行假设整个请求存在request数组里char *p = request;char *q = strchr(request,'\\n');指针p和q之间就是这一行数据char method[1024];char uri[1024];char version[1024];Split(&amp;p,q,method); 分离出方法Split(&amp;p,q,uri);Split(&amp;p,q,version);最终结果: method 存放 GETuri 存放/index.htmlversion存放HTTP/1.1void Split(char **p,char *q,char *s)&#123; while((*p) != q) &#123; if( (**p) == ' ' ) &#123; (*p)++; break; &#125; *(s++) = *((*p)++); &#125;&#125; 简答题listen backlog作用 recv 返回值 epoll使用过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;sys/epoll.h&gt;2）创建epoll实例int epoll_create（int size）epoll模型由内核管理，需要向内核申请创建实例。参数size为实例大小，可以理解为所管理描述符的数量。在Linux 2.6.8以后，size会由系统自动调整，该参数仅仅为保持兼容而存在。若操作成功，会返回引用该实例的描述符，否则返回-1。3）注册描述符及事件int epoll_ctl（int epfd, int op, int fd, struct epoll_event *event）epoll模型将管理若干描述符及关心的事件（与select作用类似），这些管理功能均通过该函数表示。操作成功，返回0，否则返回-1。各参数含义：a）epfd为epoll实例描述符b）fd为要管理的描述符c）event为该描述符上关心的事件，类型为结构体类型：struct epoll_event&#123; __uint32_t events; epoll_data_t data;｝；events是由以下事件标志通过 | 运算得到的组合EPOLLIN：可读数据（有数据到达）EPOLLOUT：可写数据（可发送给对方）EPOLLPRI：对于流式套接字，收到了OOB数据EPOLLRDHUP：对方调用了close()或shutdown()，在ET模式下很有用EPOLLERR：发生错误的情况EPOLLET：启用ET（Edge Triggered，边缘触发，状态发生变化）模式，默认模式为LT（Level Triggered，条件或水平触发，状态不变，但总满足“操作就绪”的要求）EPOLLONESHOT：只使用一次，单独使用无意义除上述标志以外，Linux的不同版本还增加了其它事件标志。data成员表示事件对应的数据，其定义为：typedef union epoll_data&#123; void *ptr; int fd; __uint32_t u32; __uint64_t u64;｝epoll_data_t；d）op表示要执行的管理操作，有三个：EPOLL_CTL_XXX，其中XXX是ADD、DEL、MOD三者之一，分别表示新注册、删除已有、修改已有4）进行监控int epoll_wait（int epfd, struct epoll_event *events, int maxevents, int timeout）执行完成后，若有描述符上期待的事件发生，返回描述数个数；若超时，返回0；若出错，返回-1。参数含义为：a）epfd，epoll实例的描述符b）events，用户动态申请的内存空间，用于存放产生事件的描述符等信息，若有n个描述符上产生了期待的事件，这n个描述符的相关信息存放在events的前n个元素中c）maxevents，events空间大小d）timeout，该参数与select模型中的不同，它以毫秒为单位设置时间间隔。若为0，调用会立即返回；若为-1，则无限期等待，直至出错或有描述符发生事件；若为其它值，则会等待指定的时间间隔，在此时间内，若有事件发生，会返回，否则会等到超时再返回。该参数设置会影响性能 123456789101112131415一、数据报套接字的两种通信模式1、客户机/服务器模式也可称为主从模式，服务器不主动向客户机发送数据，而是处于等待状态，客户机主动发起数据通信的过程，类似于流式套接字的工作模式。在该模式中，服务器需要绑定操作，客户机不需要。2、对等模式既向不特定主机发送信息，也接收不特定主机发送来的信息。在该模式中，参与通信方均需要绑定操作。 12345672、epoll模型1）epoll是Linux上的高性能I/O模型。Kqueue是FreeBSD系统中的模型，Windows是IOCP模型。2）下图中体现select与epoll模型性能的差异，很明显，当连接数量较大时，select模型的性能明显下降，epoll模型的性能比较稳定，不会随着管理描述数量的增加出现明显性能下降的情况。3）epoll适用于连接数量较多，但活动连接数量相对较少的情况。 123451、WSAAsyncSelect概述1）当协议栈检测到某个套接字上有数据到达（事件）时，便会向该套接字所属应用发送通知消息，应用收到消息后再进行处理。这种方式使用起来非常自然，也符合Windows系统的特性，即事件（套接字状态变化） -&gt; 消息传递（向应用发送消息） -&gt; 响应（应用程序处理）。2）WSAAsyncSelect是另一种I/O复用模型，非常适合GUI界面的应用。 123453、select模型1）该关注的套接字（描述符）存储在fd_set集合中，select模型会监控一段时间内集合中所有有效的套接字是否“操作就绪”，若是会保留下来，否则会将该套接字移出集合，对于仍然存在于集合中的套接字，可以直接进行相应的操作，而不必再花时间等待。2）对套接字的关注只有三种类型：数据是否可读？数据是否可写？是否发生错误？为方便，模型按感兴趣的类型将套接字集合分为三种，某个套接字可以只加入一个集合，也可以同时加入多个集合。 1TIME_WAIT出现的原因","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://humancloud.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"剑指offer_01","slug":"剑指offer-01","date":"2020-04-06T04:42:40.000Z","updated":"2020-04-11T02:49:09.713Z","comments":true,"path":"2020/04/06/剑指offer-01/","link":"","permalink":"https://humancloud.github.io/2020/04/06/%E5%89%91%E6%8C%87offer-01/","excerpt":"前言 剑指offer刷题记录 题目大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）,n&lt;=39 F(n)=⎩⎪⎨⎪⎧​ 0,1,F(n−1)+F(n−2),​ n=0n=1,2n&gt;2​","text":"前言 剑指offer刷题记录 题目大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）,n&lt;=39 F(n)=⎩⎪⎨⎪⎧​ 0,1,F(n−1)+F(n−2),​ n=0n=1,2n&gt;2​ 解法一利用循环 将元素保存到数组里,从数组中取值 123456789101112131415161718class Solution &#123;public: int Fibonacci(int n) &#123; vector&lt;int&gt; Fib; Fib.push_back(0); /* 第0个元素赋值 */ Fib.push_back(1); /* 第1个元素*/ if(n == 0)&#123; return 0; &#125; for(int i = 2; i&lt;=39; i++) &#123; Fib.push_back(Fib[i-1] + Fib[i-2]); &#125; return Fib[n]; &#125;&#125;; 解法二使用递归 效率很低，占用内存空间较大(ｎ大了很可能会出问题) 时间复杂度 : O(2^n^)123456代码中return是基本操作,所以时间复杂度可以理解为return执行的次数如果n&#x3D;0&#x2F;n&#x3D;1,复杂度为O(1),n&#x3D;2为O(3),三次returnn&#x3D;3为O(4),四次returnO(n) &#x3D; O(n-1)+O(n-2) 空间复杂度 : O(1) 12345678910class Solution &#123;public: unsigned long Fibonacci(int n) &#123; if(n &gt; 1)&#123; return Fibonacci(n-1) + Fibonacci(n-2); &#125;else&#123; return n; &#125; &#125;&#125;; 时间复杂度一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 常见的算法时间复杂度由小到大依次为：$$Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)$$","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://humancloud.github.io/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"这是一篇示例文章","slug":"example","date":"2020-04-05T03:51:04.000Z","updated":"2020-04-05T11:14:10.458Z","comments":true,"path":"2020/04/05/example/","link":"","permalink":"https://humancloud.github.io/2020/04/05/example/","excerpt":"前言 Hexo博客美化配置,这篇文章讲解了,Hexo博客的美化与配置","text":"前言 Hexo博客美化配置,这篇文章讲解了,Hexo博客的美化与配置 标题1内容1 标题2内容2 如果您喜欢我的文章,欢迎关注下面的我滴公众号","categories":[],"tags":[]},{"title":"network","slug":"network","date":"2020-03-22T07:06:29.275Z","updated":"2020-04-05T02:57:51.619Z","comments":true,"path":"2020/03/22/network/","link":"","permalink":"https://humancloud.github.io/2020/03/22/network/","excerpt":"作业:1、查看listen的man page信息，了解backlog的作用，下次找同学回答。123456789101112backlog::允许同时与服务器连接的客户端数量 查看系统默认backlog:cat /proc/sys/net/ipv4/tcp_max_syn_backlog 监听端口后,被动套接字等待连接(listen函数把套接字变成被动套接字,accept函数阻塞等待连接),此时系统中维护着两个队列,第一个队列存放的是已建立连接的套接字(即完成三次握手后的established),第二个队列是未建立连接的套接字(处于三次握手中的syn_rcvd),每次accept会将第一个队列中的套接字返回,进行通信,以完成网络传输linux2.2以前,backlog表示两个队列总和的长度linux2.2以后,backlog表示已完成连接的队列的长度","text":"作业:1、查看listen的man page信息，了解backlog的作用，下次找同学回答。123456789101112backlog::允许同时与服务器连接的客户端数量 查看系统默认backlog:cat /proc/sys/net/ipv4/tcp_max_syn_backlog 监听端口后,被动套接字等待连接(listen函数把套接字变成被动套接字,accept函数阻塞等待连接),此时系统中维护着两个队列,第一个队列存放的是已建立连接的套接字(即完成三次握手后的established),第二个队列是未建立连接的套接字(处于三次握手中的syn_rcvd),每次accept会将第一个队列中的套接字返回,进行通信,以完成网络传输linux2.2以前,backlog表示两个队列总和的长度linux2.2以后,backlog表示已完成连接的队列的长度 2、查看recv的man page信息，了解recv返回值的信息，下次解答12345678recv函数原型为: ssize_t recv(int sockfd, void *buf, size_t len, int flags);参数:第一个参数：接收端的套接字描述符第二个参数：接受数据的缓冲区第三个参数：缓冲区的尺寸，sizeof（）第四个参数：置0 原理: 123456789101112当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，如果协议在传送s的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR；如果s的发送缓冲中没有数据或者数据被协议成功发送完毕后，recv先检查套接字s的接收缓冲区，如果s接收缓冲区中没有数据或者协议正在接收数据，那么recv就一直等待，直到协议把数据接收完毕；当协议把数据接收完毕，recv函数就把s的接收缓冲中的数据copy到buf中注意协议接收到的数据可能大于buf的长度，所以在这种情况下要调用几次recv函数才能把s的接收缓冲中的数据copy完。recv函数仅仅是copy数据，真正的接收数据是协议来完成的，recv函数返回其实际copy的字节数；如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。 返回值: 12345678910111213如果recv函数成功，返回值大于0，返回的是其实际copy的字节数；如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。EAGAIN：套接字已标记为非阻塞，而接收操作被阻塞或者接收超时EBADF：sock不是有效的描述词ECONNREFUSE：远程主机阻绝网络连接EFAULT：内存空间访问出错EINTR：操作被信号中断EINVAL：参数无效ENOMEM：内存不足ENOTCONN：与面向连接关联的套接字尚未被连接上ENOTSOCK：sock索引的不是套接字 send函数: 12原型:ssize_t send(int sockfd, const void *buf, size_t len, int flags); 返回值: 1231. s 指定发送端套接字描述符。2. buff 表示存放发送数据的缓冲区。 3. 实际要发送的字节数， 原理: 1234567891011121314151617当调用该函数时，send先比较待发送数据的长度len和套接字s的发送缓冲区的长度，如果len大于s的发送缓冲区的长度，该函数返回SOCKET_ERROR； 如果len小于或者等于s的发送缓冲区的长度，那么send先检查协议是否正在发送s的发送缓冲中的数据； 如果是就等待协议把数据发送完，如果协议还没有开始发送s的发送缓冲中的数据或者s的发送缓冲中没有数据，那么send就比较s的发送缓冲区的剩余空间和len； 如果len大于剩余空间大小，send就一直等待协议把s的发送缓冲中的数据发送完，如果len小于剩余空间大小，send就仅仅把buf中的数据copy到剩余空间里（注意并不是send把s的发送缓冲中的数据传到连接的另一端的，而是协议传的，send仅仅是把buf中的数据copy到s的发送缓冲区的剩余空间里）。 如果send函数copy数据成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR； 如果send在等待协议传送数据时网络断开的话，那么send函数也返回SOCKET_ERROR。要注意send函数把buf中的数据成功copy到s的发送缓冲的剩余空间里后它就返回了，但是此时这些数据并不一定马上被传到连接的另一端。 如果协议在后续的传送过程中出现网络错误的话，那么下一个Socket函数就会返回SOCKET_ERROR。（每一个除send外的Socket函数在执行的最开始总要先等待套接字的发送缓冲中的数据被协议传送完毕才能继续，如果在等待时出现网络错误，那么该Socket函数就返回SOCKET_ERROR #### 3、为客户端加上退出机制 12345if (strcmp(bufOut,\"bye\")==0) &#123; printf(\"you input bye\"); break; &#125; 4、为服务端加上特殊的“停止服务”功能。(确定对方是管理员才退出,否则不退出)本节课内容:12345678910111213141516171819202122232425262728293031323334353637383940udp: recvfrom不一定接收到对端发来的信息,因为udp不检查对端是否收到,tcp检查吗浏览器访问www.qq.com:7777是访问不了的,因为服务器上没有应用程序运行在7777端口服务端:1、创建流式套接字，目的是监听连接请求2、绑定对外公布的地址信息3、确定连接请求队列大小，进入监听套接字监听状态4、当有客户端的连接请求到来时，创建一个为该客户端提供1对1服务的流式套接字，它只起数据传输作用，称为响应套接字5、响应套接字与客户端套接字成为通信双方，这个通信是有连接的，在此基础上，可以按照通信规程（业务逻辑）传输数据5.1、发送数据：将数据从应用程序缓冲区复制到套接字的发送缓冲区，至于何时真正发送到对方，由协议栈决定5.2、接收数据：将数据从套接字的接收缓冲区移动到应用程序的缓冲区，6、数据传输完成后，可关闭响应套接字7、一般情况下，不关闭监听套接字，除非有特殊要求客户端:1、创建流式套接字2、根据服务端公布的地址信息，连接到服务端3、连接成功后，可以按照通信规程（业务逻辑）传输数据3.1、发送数据：将数据从应用程序缓冲区复制到套接字的发送缓冲区，至于何时真正发送到对方，由协议栈决定3.2、接收数据：将数据从套接字的接收缓冲区移动到应用程序的缓冲区，4、数据传输完成后，可关闭套接字","categories":[],"tags":[]},{"title":"network-2","slug":"network-2","date":"2020-03-22T07:06:29.265Z","updated":"2020-05-31T12:58:01.016Z","comments":true,"path":"2020/03/22/network-2/","link":"","permalink":"https://humancloud.github.io/2020/03/22/network-2/","excerpt":"前言: 笔记linux系统中维护着两个队列 第一个队列存放的是已建立连接的套接字(即完成三次握手后的established), 第二个队列是未建立连接的套接字(处于三次握手中的syn_rcvd), 每次accept会将第一个队列中的套接字返回,进行通信,以完成网络传输","text":"前言: 笔记linux系统中维护着两个队列 第一个队列存放的是已建立连接的套接字(即完成三次握手后的established), 第二个队列是未建立连接的套接字(处于三次握手中的syn_rcvd), 每次accept会将第一个队列中的套接字返回,进行通信,以完成网络传输 图中仅给出了第一个队列,这个队列的连接已经被TCP接收（已经完成三次握手），但是还没有被应用程序接收（调用accept函数) 1234567监听端口后,被动套接字等待连接(socket函数产生套接字(默认为主动套接字),bind函数绑定端口,listen函数把套接字变成被动套接字,accept函数阻塞等待连接客户端使用connect函数主动与服务器建立连接,服务器accept接收连接,accept函数返回连接套接字,两端通过连接套接字进行通信) listen函数 123456listen函数int listen(int sockfd, int backlog);linux2.2以前,backlog表示两个队列总和的长度linux2.2以后,backlog表示已完成连接的队列的长度,当长度超过会忽略客户端的请求连接 实验1将服务端的listen函数第二个参数设置为0 可以看到,我打开了个5客户端, 123456netstat | grep tcp查看信息,可以看到,前两对客户端的状态是established后面三个客户端(不是3对了),状态是syn_sent(表示请求连接),也就是客户端在请求与服务器连接在一段时间后,后面三个客户端报错了-连接超时(说明服务器忽略了后面三个连接请求,因为达到了队列最大长度) 设置为1 123456netstat | grep tcp查看信息,可以看到,前3对客户端的状态是established后面两个状态是syn_sent(表示请求连接),也就是客户端在请求与服务器连接在一段时间后,后面2个客户端报错了-连接超时 实现1结论:12345backlog设置为0 : 可以与2个客户端建立tcp连接backlog设置为1 : 可以与3个客户端建立tcp连接&lt;&lt;Unix网络编程&gt;&gt;说backlog从未有过正式的定义, 实验2:123456789sockC = accept(sock, (struct sockaddr*)&amp;addrC, &amp;sizeAddr);if(-1 == sockC) &#123; printf(\"accept() error : %d -&gt; %s\\n\", errno, strerror(errno)); continue; &#125;printf(\"accept call\\n\");在accept函数后面加上信息,输出\"accept call\"表示accept已经执行完毕并返回 此时来看一下 第一个客户端与服务器建立连接,可以看到输出了客户端1的ip端口信息并且可以看到accept函数调用成功并返回了,再打开第二个客户端,服务器并没有响应此时客户端1可以与服务器通信但客户端2不可以 结束第一个客户端,可以看到此时第二个客户端连接到服务器并调用了accept函数, 注意: 1234567shell命令netstat查看信息(左下角终端)netstat | grep tcp可以看到有两对连接两对连接都是established状态,即两个客户端都已经与服务器建立了Tcp连接,进入连接队列","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://humancloud.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-22T07:06:29.245Z","updated":"2020-03-08T01:11:43.000Z","comments":true,"path":"2020/03/22/hello-world/","link":"","permalink":"https://humancloud.github.io/2020/03/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"pip更换国内源","slug":"pip","date":"2020-03-09T04:33:07.000Z","updated":"2020-04-11T02:03:56.761Z","comments":true,"path":"2020/03/09/pip/","link":"","permalink":"https://humancloud.github.io/2020/03/09/pip/","excerpt":"","text":"pip更换国内源将会有几兆每秒的速度 步骤 12345678mkdir ~/.pipvim ~/.pip/pip.conf打开文件后,输入以下信息,即可使用清华源[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host = https://pypi.tuna.tsinghua.edu.cn 使用easy_install来安装模块 1234567easy_install 换源cd /root 注意要放到/root目录下vi .pydistutils.cfg 打开配置文件[easy_install]index-url=http://mirrors.aliyun.com/pypi/simple/find-links=http://mirrors.aliyun.com/pypi/simple/","categories":[],"tags":[]}],"categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://humancloud.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://humancloud.github.io/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]}