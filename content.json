{"meta":{"title":"Hu","subtitle":"","description":"Welcome!","author":"Hu","url":"https://humancloud.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-04-05T05:10:56.000Z","updated":"2020-04-05T05:13:47.982Z","comments":true,"path":"categories/index.html","permalink":"https://humancloud.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-05T05:10:45.000Z","updated":"2020-04-05T05:14:19.486Z","comments":true,"path":"tags/index.html","permalink":"https://humancloud.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mianshi","slug":"mianshi","date":"2020-10-20T15:52:36.000Z","updated":"2020-10-20T15:58:10.824Z","comments":true,"path":"2020/10/20/mianshi/","link":"","permalink":"https://humancloud.github.io/2020/10/20/mianshi/","excerpt":"1. 网络编程系统编程部分常见面试题目 1. TCP和UDP的区别 1234567(1) TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接(2) TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付(3) TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）(4) 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信(5) TCP首部开销20字节;UDP的首部开销小，只有8个字节(6) TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。","text":"1. 网络编程系统编程部分常见面试题目 1. TCP和UDP的区别 1234567(1) TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接(2) TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付(3) TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）(4) 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信(5) TCP首部开销20字节;UDP的首部开销小，只有8个字节(6) TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。 流量控制与拥塞控制 1234拥塞控制网络拥塞现象是指到达通信子网中某一部分的分组数量过多,使得该部分网络来不及处理,以致引起这部分乃至整个网络性能下降的现象,严重时甚至会导致网络通信业务陷入停顿,即出现死锁现象。拥塞控制是处理网络拥塞现象的一种机制。流量控制数据的传送与接收过程当中很可能出现收方来不及接收的情况,这时就需要对发方进行控制,以免数据丢失。 多线程如何同步 1234567windows线程同步有四种方式：临界区、内核对象、互斥量、信号量。Linux线程同步有最常用的是：互斥锁、条件变量和信号量。 进程间通信有哪些方式,各有什么优缺点 123456789101112Linux 进程间通信（IPC）以下以几部分发展而来：早期UNIX进程间通信、基于System V进程间通信、基于Socket进程间通信和POSIX进程间通信。UNIX进程间通信方式包括：管道、FIFO、信号。System V进程间通信方式包括：System V消息队列、System V信号灯、System V共享内存、POSIX进程间通信包括：posix消息队列、posix信号灯、posix共享内存。现在linux使用的进程间通信方式：（1）管道（pipe）和有名管道（FIFO）（2）信号（signal）（3）消息队列（4）共享内存（5）信号量（6）套接字（socket) tcp连接建立的时候3次握手，断开连接的4次握手的具体过程 12345建立连接采用的3次握手协议，具体是指：第一次握手是客户端connect连接到server，server accept client的请求之后，向client端发送一个消息，相当于说我都准备好了，你连接上我了，这是第二次握手，第3次握手就是client向server发送的，就是对第二次握手消息的确认。之后client和server就开始通讯了。断开连接的4次握手,具体如下：断开连接的一端发送close请求是第一次握手，另外一端接收到断开连接的请求之后需要对close进行确认，发送一个消息，这是第二次握手，发送了确认消息之后还要向对端发送close消息，要关闭对对端的连接，这是第3次握手，而在最初发送断开连接的一端接收到消息之后，进入到一个很重要的状态time_wait状态，这个状态也是面试官经常问道的问题，最后一次握手是最初发送断开连接的一端接收到消息之后。对消息的确认。 epoll和select的区别 123456789(1) select缺点:1.最大并发数限制：使用32个整数的32位，即32*32&#x3D;1024来标识fd，虽然可修改，但是有以下第二点的瓶颈；2.效率低：每次都会线性扫描整个fd_set，集合越大速度越慢；3.内核&#x2F;用户空间内存拷贝问题。(2) epoll的提升：1.本身没有最大并发连接的限制，仅受系统中进程能打开的最大文件数目限制；2.效率提升：只有活跃的socket才会主动的去调用callback函数；3.省去不必要的内存拷贝：epoll通过内核与用户空间mmap同一块内存实现。 (不知道有没有共享内存..................) 2. Linux部分基础指令 12345678910cd 进入目录，切换目录pwd 查看当前路径ls -l , ls -a 列出所有文件（包括隐藏文件）mkdir 创建目录rmdir 删除空目录.当前目录，..上层目录，~ 主目录cat -b 显示行号vi touch 创建文件 (会修改文件的时间) 硬盘使用命令 df CPU使用指令 12cat /proc/cpuinfo 查看cpu基本硬件信息top 或 datat -c 查看cpu使用状态信息(yum install dstat) 内存使用指令 12cat /proc/meminfo 查看内存基本容量free -k(以kb为单位显示), free -m(以mb为单位显示) 查看内存运行空间信息 查看系统版本 12uname -acat /etc/redhat-release (centos版本) 查看网络/进程信息 12345678910111213查看网络连接: netstat -anp (-a 显示所有选项 -t 仅显示tcp相关选项, -u 仅显示udp相关选项, -n 尽量显示出数字 -p 显示相关链接的程序名)可以显示出: Proto 协议类型, LocalAddress本地地址,ForeignAddress对端地址,State表示状态对tcp有效,pid表示对应的进程id查看8080端口被哪个进程占用 netstat -apn | grep 8080查看进程名为Python的进程有哪些连接 netstat -apn | grep python查看进程信息:top执行top命令,使用快捷键M即可以查看内存占用最多的N个进程 使用快捷键P即可以查看CPU占用最多的前N个进程top -p pid 使用H键可以查看线程相关的信息查看ip地址, ifconfig可能会出现多个ip地址,因为一台主机可能具备多个网络接口,多个网络接口对应多个网卡或虚拟网卡设备 修改文件权限 1234567891011chmod 777 file 以八进制数字形式指定文件权限chmod &lt;访问者&gt;[+ - =]&lt;访问权限&gt; 向指定用户添加,删除,设置指定权限 (没懂)chmod +t directory/ 设置目录的沾滞位,防止其他用户在该目录下删除文件chownchown user file 将文件所有者改为指定用户chmod -R user directory 将目录下所有文件所有者权限都设置为指定用户chgrp group file 将文件所属组改为指定用户组 查看文件权限 123查看文件访问的权限: ls -l (每个文件或目录都有三个权限 r,w,x) 文件所有者 文件所属者 其他用户 umask 查看默认的权限掩码(掩码取反就是文件权限)信息,最后显示出来的是八进制数字的形式,如 0222 root指令 12su root 切换root用户sudo 普通用户执行root指令, 只有被root用户添加到/etc/sudoers 文件中的用户才可以使用sudo指令 grep指令 12 find指令 123find pathname -name filename 在pathname目录下寻找文件名为filename的文件find pathname -size filesize 寻找文件大小为filesize的文件find pathname -size +/- filesize 寻找文件大小大于/小于filesize的文件 uniq命令 123456用于检查和删除文本中重复出现的行列uniq filename 去除文件当中重复的行,输出到标准输出uniq file file1 去除文件当中重复的行,输出到file1uniq -c file 每列旁边显示该行重复的次数uniq -u file 显示只出现一次的行 Linux目录结构 123456/bin 二进制可执行文件,常用命令/etc 系统管理和配置文件/usr 很多应用程序的安装目录/home 所有用户的家目录/root 超级用户的家目录/var 保存各种服务的日志文件 压缩 12345678910111213打包并压缩 tar -cvf ./abc.tar ./abc 只打包不压缩 tar -zcvf ./abc.tar.gz ./abc 打包并使用gzip压缩 tar -jcvf ./abc.tar.bz2 ./abc 打包并使用bzip2压缩 解压只需替换c为x即可不打包直接压缩gzip -v file 压缩文件gzip -d file.gz 解压缩 IPC相关 123456789101112131415161718192021222324252627282930313233ipcs 显示进程间通信设施状态的工具➜ code git:(master) ipcs --------- 消息队列 -----------键 msqid 拥有者 权限 已用字节数 消息 ------------ 共享内存段 --------------键 shmid 拥有者 权限 字节 连接数 状态 0x00000000 688136 lu 700 8294400 2 目标 0x00000000 688141 lu 700 91656 2 目标 0x00000000 753682 lu 600 524288 2 目标 0x51310018 22 lu 600 33024 1 0x5131001a 23 lu 600 16 1 0x00000000 688153 lu 700 1600 2 目标 0x00000000 27 lu 600 524288 2 目标 0x00000000 688159 lu 700 2537600 2 目标 0x00000000 32 lu 600 524288 2 目标 0x5131002f 37 lu 600 16 1 0x00000000 229416 lu 600 524288 2 目标 0x00000000 622634 lu 600 8015104 2 目标 0x00000000 65584 lu 700 30000 2 目标 0x00000000 557110 lu 700 307400 2 目标 0x5131004c 163900 lu 600 1024 1 0x00000000 622654 lu 700 289380 2 目标 --------- 信号量数组 -----------键 semid 拥有者 权限 nsems 0x51310017 1 lu 600 1 0x51310019 3 lu 600 1 0x5131002e 5 lu 600 1 0x5131004b 9 lu 600 1 其他 123shutdown -h nowreboot&gt;&gt;(追加) &gt;(覆盖) 重定向 vim 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147:tabe a.txt 打开或创建新文件,使用gt切换文件\" %在括号匹配之间跳转\"\"\" =============================================================================\" Nomal模式\" =============================================================================\" ctrl v 块选择,可以用来给代码多行注释\" gd 跳转到局部定义 不用ctags\" gf 跳转到文件\" ctrl o 跳转到上一个跳转位置 这个很重要, 不管怎么跳转,都可以ctrl o 跳转回来\" ctrl i 到下一个跳转位置\" ctrl b 查看上一页内容 常用\" ctrl f 查看下一页内容 常用\" K 跳转到manul\" \" &lt;&lt; 左缩进\" &gt;&gt; 右缩进\" == 自动缩进 原来还可以这样\"\" 0到行首\" ^ 跳转到行首第一个非空字符\" $到行尾\" % 匹配括号移动\" gg到第一行行首\" G 到最后一行的行尾\" 100G 跳转到100行行首 , 比命令模式输入:行号方便\" \" \" y$复制到行尾\" yw 复制一个单词\" yy 复制一整行\" 10yy 复制光标下10行\" yG 复制到文本结束\" yH 从文本开始复制到光标处\"\"\" x 删掉光标处字符\" 3x剪切三个\" p 光标之后粘贴\" P光标之前粘贴\" 3p粘贴三次\" \"\" fa移动光标到本行下第一个字符a处, 2fa移动到第二个a处\" Fa移动到上一个字符a\" nfa 移动到第n个字符处\" nFa\"\" yfa 复制光标字符到字符a之间的内容\" y2fa 复制光标字符到第2个a之间的内容\"\" \" dw \" d2w 删除两个单词\" df\" 删除到出现第一个双引号的位置\" d2f\" 删除到出现第2个双引号的位置\" d$ 删除到本行结尾\" d^ 删除到本行开头\" dH 同yH\" dG 同yG \" dtg 删除到g字符的位置不删除g字符 (例如abcdegfhijk) 按键dtg从光标删除到g字符,\" 其实就是delete to g 的缩写很好用啊\"\" 重要的:\" f&#123; 移动到大括号处,然后d%删除整个大括号的内容(包括大括号), 或者di&#123;\" 删除大括号里面的内容,不删除大括号\"\" \"\" u 撤销操作\" ctrl r 恢复撤销操作\"\"\"\" ~ 将光标处的字符改变大小写\" 3~ 将光标位置开始的3个字符改变其大小写\" g~~ 改变当前行字符大小写\" gUU 当前行字符改成大写\" guu 当前行改成小写\" gUw 光标处的单词改成大写\" guw 光标处的单词改成小写\"\"\" 替换:\" r 替换光标处字符\" S替换行(删除当前行,并进入插入模式)\" cc 同 S\" ciw改写光标所处的单词\" caw改写光标所处的单词(如果两侧有空格删除空格)\" c0 从光标改写到行首\" c^ 从光标改写到行首（第一个非零字符）\" c$ 从光标改写到行末\" C 从光标改写到行尾（同c$）\" ci\" 改写双引号中的内容\" ci' 改写单引号中的内容\" cib 改写小括号中的内容\" cab 改写小括号中的内容（包含小括号本身）\" ci) 改写小括号中的内容\" ci] 改写中括号中内容\" ciB 改写大括号中内容\" caB 改写大括号中的内容（包含大括号本身）\" ci&#125; 改写大括号中内容\" c2w 改写下两个单词\" ct( 改写到小括号前\" c/apple 改写到光标后的第一个apple前\"\"\"\"\"\" =============================================================================\" 底行命令模式\" =============================================================================\" :%!xxd 16进制\" :s/$/sth 行尾追加sth\" :g/^/s*$/d 删除空行以及只有空格的行\"\" 替换\" :s/from/to 当前行第一个from替换成to\" :s/from/to/g 当前行所有from替换成to\" :33s/from/to/g 在第33行进行替换操作 \" :%s/from/to/g 对所有行内容进行替换\"\"\" =============================================================================\" Insert模式\" =============================================================================\" I 进入编辑,并将光标置于行首\" A 置光标与行尾并进入插入模式(在行尾插入)\" O 当前行上面新加一行,进入插入模式\"\" insert 模式 ctrl [ 相当于esc 但比esc更顺手\" ctrl d crtl t 左右缩进\" ctrl u 重新编辑本行\" ctrl w 删除单词\" \"\" 插入模式快捷键\" CTRL-M 或 CTRL-J 开始新行\" CTRL-E 插入光标下方的字符\" CTRL-Y 插入光标上方的字符\" CTRL-A 插入上次插入的文本\" CTRL-@ 插入上次插入的文本并结束插入模式\" CTRL-R &#123;0-9a-z%#:.-=\"&#125; 插入寄存器的内容\" CTRL-W 删除光标前的一个单词\" CTRL-U 删除当前行的所有字符\" CTRL-T 在当前行首插入一个移位宽度的缩进\" CTRL-D 从当前行首删除一个移位宽度的缩进\" 0 CTRL-D 删除当前行的所有缩进\" ^ CTRL-D 删除当前行的所有缩进，恢复下一行的缩进\"\" &lt;S-Left&gt; 按住 SHIFT 按左键，向左移动一个单词\" &lt;S-Right&gt; 按住 SHIFT 按右键，向右移动一个单词\" &lt;S-Up&gt; 按住 SHIFT 按上键，向上翻页\" &lt;S-Down&gt; 按住 SHIFT 按下键，向下翻页\"\" =============================================================================\"\"\"\"切换buffer\":bn 切换到后一个\":bp 切换到前一个\"\"\"\" vim 缩进大法\"\" 缩进4个格 1,18&gt; 1到18行向右缩进4格, &lt;向左缩进4空格\"\" 缩进自定义个格\" ctrl v 进入visual block模式, 选择块, 按I\" ,按1个空格,按esc键就可以整个块向右缩进1格\"\" 按几个空格缩进几个格,\" 甚至不输入空格而是输入字符,都会使得整个块每一行前面都加上这几个字符(其实输入空格就是在开头添加空格,输入字符就是添加字符)\" 编译过程 123456789101112131415161718191. 预定义 宏替换 处理条件编译/预编译指令 头文件展开 添加行号信息方便调试 去掉注释 生成.i文件2. 编译 语法/语义分析,源代码优化,目标代码生成与优化 词法分析: 语法分析: 语义分析: 生成汇编代码 生成.s文件3. 汇编 将汇编指令翻译为二进制指令 生成.o二进制文件4. 链接 gcc g++ 1234567891011-E 只激活预处理,不生成文件,需要把它重定向到一个输出文件里-S 预处理和编译,生成汇编代码-c 只激活预处理,编译,汇编生成obj文件(二进制文件)-o 生成可执行文件(指定文件名称,缺省为a.out)-static 禁止使用动态库(编译出来的东西一般都很大,也不需要什么动态链接库就可以运行),禁止使用共享连接-fPIC --share 尽量使用动态库,生成文件较小,但需要系统由动态库生成共享目标文件-L 指定库的路径-I 头文件默认搜索路径-l 指定链接库名称-g 编译时产生调试信息 gdb 12 makefile 1234makeifle编写规则makefile解释流程makefile解决的是编译问题,可以将命名写成一个脚本文件,然后去执行这个脚本文件 git 1234远程部署三连git add . 添加到缓冲区/暂存区git commit -m \"regular\" 提交文件,提交到仓库区git push -u origin master 提交到远程仓库 git基础操作 12工作区: 磁盘上的文件集合版本区(版本库): .git文件夹 &#x3D; 暂存区(stage) + 分支(master) + 指针Head 1234567git config --global user.name &#39;humancloud&#39;git config --global user.email &#39;humancloud@126.com&#39;git init 版本区建立(创建.git文件)git add . 把工作区所有文件提交到版本区里的暂存区git commit -m &quot;xxx&quot; 暂存区所以文件提交到仓库区(暂存区空)git remote add origin xxxxxx.git 把本地仓库与远程仓库连接起来git push -u origin master 把仓库区文件提交到远程仓库里(将本地的master分支推送到origin主机,同时指定origin为默认主机)) 其他命令: 123456789101112131415161718192021222324252627282930➜ calculator git:(master) ✗ git status 查看状态➜ calculator git:(master) ✗ git remote -v 查看远程仓库➜ calculator git:(master) ✗ git remote add [name] [url] 添加远程仓库➜ calculator git:(master) ✗ git remote rm [name] 删除远程仓库➜ calculator git:(master) ✗ git rm &amp;&amp; git commit -m &quot;xxx&quot; 删除版本区文件➜ calculator git:(master) ✗ git remote set-url --push [name] [new url] 修改远程仓库 ➜ calculator git:(master) ✗ git log 查看日志➜ calculator git:(master) ✗ git pull 把最新的提交从远程仓库抓取下来,在本地合并,和git push 相反注意:: 克隆下项目来,如果想要更新项目,直接git pull 把最新的项目拉下来,即可撤销: 1. 在工作区修改了内容,向回溯到版本区(版本库)里的版本➜ calculator git:(master) ✗ git checkout --file 用版本区的版本替换工作区的版本2. 在工作区修改了内容,并git add添加到了暂存区,要撤销➜ calculator git:(master) ✗ git reset --hard 版本号 ,暂存区回溯到以前的版本(版本号 git log查看)➜ calculator git:(master) ✗ git checkout --file 再用版本区的替换工作区的版本3. .....,并git commit 到了仓库区,与2相同删除:1. 删除版本区(版本库)的文件,(如果git add把某文件存到暂存区了,然后在工作区把这个文件删除了,要想把版本区的这个文件也删除,执行下面)➜ calculator git:(master) ✗ git rm [filename] &amp;&amp; git commit -m &quot;xxx&quot; ,删除版本区的文件并描述这次删除, 2. 如果git add了,然后删除了本地文件,git会知道,要想恢复,可以从版本区恢复,➜ calculator git:(master) ✗ git checkout --file test: 1234567891011121314151617➜ calculator git:(master) ✗ git add a.c 添加到暂存区➜ calculator git:(master) ✗ git commit -m &quot;first&quot; 将文件从暂存区提交到仓库➜ calculator git:(master) ✗ git remote add origin https:&#x2F;&#x2F;github.com&#x2F;humancloud&#x2F;c.git &#x2F;&#x2F;将本地仓库同步到远程仓库➜ calculator git:(master) ✗ git push -u origin master Username for &#39;https:&#x2F;&#x2F;github.com&#39;: humancloudPassword for &#39;https:&#x2F;&#x2F;humancloud@github.com&#39;: 对象计数中: 5, 完成.Delta compression using up to 8 threads.压缩对象中: 100% (2&#x2F;2), 完成.写入对象中: 100% (5&#x2F;5), 1.72 KiB | 1.72 MiB&#x2F;s, 完成.Total 5 (delta 0), reused 0 (delta 0)To https:&#x2F;&#x2F;github.com&#x2F;humancloud&#x2F;c.git * [new branch] master -&gt; master分支 &#39;master&#39; 设置为跟踪来自 &#39;origin&#39; 的远程分支 &#39;master&#39;。➜ calculator git:(master) ✗ ➜ calculator git:(master) ✗ git rm .➜ calculator git:(master) ✗ git commit -m &quot;xxx&quot; 常遇到 删除错误添加到暂存区的文件: 12345678touch 1.txtgit add 1.txt1. 删除添加到暂存区的文件1.txtgit rm --cache 1.txt2. 删除暂存区和工作区的文件git rm -f 1.txt 删除错误提交的 1234567touch 1.txtgit add 1.txtgit cimmit -m \"regular\"撤销版本库的修改(暂存区,工作区不变): git reset - 本站访客数:-soft 版本库ID撤销版本库和暂存区不修改工作区: git reset --mixed 版本库ID将工作区,暂存区,版本库恢复到指定的版本:git reset --hard 版本库ID 日志 1234567891011121314151617181920212223242526272829git log这个最上面的是最近的提交不是最下面的是,这串数字就是版本库IDcommit d2c6f0ca1e7c075692c55870f4166b1e297dfcea (HEAD -&gt; master)Author: humancloud &lt;humancloud@126.com&gt;Date: Sat May 2 19:05:43 2020 +0800 regularcommit d1212d0313103c4a1199624220a1ac7c415c6785Author: humancloud &lt;humancloud@126.com&gt;Date: Sat May 2 18:55:37 2020 +0800 regularcommit 87268a78fff1c94da04de77681cf617e151d6081 (origin/master)Author: humancloud &lt;humancloud@126.com&gt;Date: Wed Apr 22 20:58:16 2020 +0800 regularcommit 9bee9335b7a83680d18e1eb2523d0cd96b59bb31Author: humancloud &lt;humancloud@126.com&gt;Date: Sun Apr 19 13:42:37 2020 +0800 regular: 3. hr常问 工作城市 优缺点 哪些因素决定这家公司 4. C++语言方面4.1 C和C++区别12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561. 设计思想不同C语言是面向过程的: 优点(高效,性能好),缺点(不易维护,可扩展性低)C++是面向对象的,具有三大特性(封装,继承,多态)2. 参数列表C语言如果没有指定参数列表,可以默认接收多个参数C++如果没有指定参数列表,不接受任何参数3. 函数默认返回值C语言函数默认返回值为intC++函数默认返回值为void4. 输入输出不同C printf scanfC++ cout cin5. C++扩展了C语言的关键字static关键字: 全局静态变量: 全局变量前加static成为全局静态变量, 存储在静态区,属于静态变量,整个运行期间一直存在 未被初始化的全局静态变量自动初始化 作用域在当前文件,在声明他的其他文件之外不可见 链接属性由外部变为内部,存储类型不变 (默认全局变量是全局的,所以链接属性是外部的) 局部静态变量: 局部变量前加static成为局部静态变量, 存储在静态区,属于静态变量,整个运行期间一直存在 作用域依然是局部的,定义他的函数块结束,作用域结束,但是变量并没有被销毁,当再次进入此函数时,依然可以访问,值不变 存储类型发生改变,由自动变量改为静态变量 作用域和链接属性不变 静态函数: 函数返回类型前加static,成为静态函数 只在声明他的文件内可见,不能被其他文件所用,不会引起命名冲突 尽量不要在头文件声明static的全局函数 (要在源文件中写是吗,在头文件里写头文件会被包含到其他文件,但包含了并不能使用他) 类的静态成员: 实现多个对象间的数据共享,不会破坏隐藏规则 静态成员是所有对象的共享成员,不属于某一个对象 声明周期是创建类到销毁类 和类中非静态成员不同的是： 非静态成员属于对象，声明周期是从对象实例化开始，而静态成员是类一创建就已经存在了 类的静态函数： 属于类的静态成员，不属于对象 静态成员函数不能直接引用类的非静态成员，可以引用类中的静态成员 对于类中的成员变量和成员函数加上static就不属于对象，自然也没有this指针了extern关键字 引用另一个文件的变量 引用同一个文件的变量 引用另一个文件的函数 5. 常用sql语句必知必会总结 12 6. 数据结构部分MyTinySTL C实现的基础数据结构 cpp实现基础数据结构 交换排序冒泡排序 1234567891011121314151617181920/** * 从大到小 * a1 与 a2 比较,a2&gt;a1则交换位置 * 从第一个元素往后比较每次排序都把最大的放右边,不能放左边, 如果要把最大的放左边则要从最后一个元素往前比较 */void Bubble(int *array,int num)&#123; int tmp; for (int i = 0; i &lt; num; i++) &#123; for (int j = 0; j &lt; num - i; j++) &#123; if(array[j] &gt; array[j+1])&#123; tmp = array[j+1]; array[j+1] = array[j]; array[j] = tmp; &#125; &#125; &#125;&#125; 快速排序 选择排序简单选择排序 12345678910111213141516void SimpLeSelectSort(SqList *L)&#123; int tmp; for (int i = 1; i &lt;= L-&gt;length; i++) &#123; for(int j = i+1;j&lt;=L-&gt;length;j++) &#123; if (L-&gt;r[i].key &gt; L-&gt;r[j].key) &#123; tmp = L-&gt;r[j].key; L-&gt;r[j].key = L-&gt;r[i].key; L-&gt;r[i].key = tmp; &#125; &#125; &#125;&#125; 堆排序 链表队列栈二叉排序树哈希表","categories":[{"name":"面试小总结","slug":"面试小总结","permalink":"https://humancloud.github.io/categories/%E9%9D%A2%E8%AF%95%E5%B0%8F%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"C语言宏实现max","slug":"C语言宏实现max","date":"2020-10-04T14:13:00.000Z","updated":"2020-10-20T15:58:12.317Z","comments":true,"path":"2020/10/04/C语言宏实现max/","link":"","permalink":"https://humancloud.github.io/2020/10/04/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E5%AE%9E%E7%8E%B0max/","excerpt":"前言C语言宏功能强大,但一不小心就会用错,许多经典书籍都曾讲过C语言宏的强大功能,此篇文章是参考C陷阱与缺陷书籍和网上其他文章总结的","text":"前言C语言宏功能强大,但一不小心就会用错,许多经典书籍都曾讲过C语言宏的强大功能,此篇文章是参考C陷阱与缺陷书籍和网上其他文章总结的 根据书籍写此篇文章 编程常用宏(常更新)max函数宏 12345错误版#define max(a,b) ((a)&gt;(b))?(a):(b)a或b会被计算两次,如果每次计算a或b都改变,那么最后得到的结果与预想中的会不同 123456789Linux Kernel 版#define max(x,y) (&#123; \\ typeof(x) _max1 = (x); \\ typeof(y) _max2 = (y); \\ (void)(&amp;_max1 == &amp;_max2); \\ _max1 &gt; _max2 ? _max1:_max2;&#125;)x或y只会被计算一次","categories":[{"name":"C语言","slug":"C语言","permalink":"https://humancloud.github.io/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"网络编程考试总结","slug":"网络编程考试总结","date":"2020-05-31T12:56:25.000Z","updated":"2020-06-02T00:05:47.482Z","comments":true,"path":"2020/05/31/网络编程考试总结/","link":"","permalink":"https://humancloud.github.io/2020/05/31/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/","excerpt":"前言: 笔记linux多线程的同步即 sem 和 互斥量 程序设计题不涉及多线程,不会使用到select,epoll,WSA等模型,有字符串处理 简答五选三(背五道题)","text":"前言: 笔记linux多线程的同步即 sem 和 互斥量 程序设计题不涉及多线程,不会使用到select,epoll,WSA等模型,有字符串处理 简答五选三(背五道题) 函数总结TCP echo服务器用到的函数 12345#include &lt;unistd.h&gt;int close(int fd);成功返回0,失败返回-1,其他返回值通过man了解 123456789101112131415161718192021222324252627282930313233343536#include&lt;netinet/in.h&gt;struct sockaddr_in&#123; uint8_t sin_len; sa_family_t sin_family; in_port_t sin_port; struct in_addr sin_addr; char sin_zero[8];&#125;;struct in_addr&#123; in_addr_t s_addr;&#125;用到的就三个: sin_family, sin_port, sin_addr.s_addr#include&lt;sys/socket.h&gt;struct sockaddr&#123; uint8_t sa_len; sa_family_t sa_family; char sa_data[14];&#125;struct sockaddr_in addr;(struct sockaddr *)&amp;addr; //主要作用就是强制转换sockaddr_in类型为sockaddr类型 123456789101112#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;int socket(AF_INET, SOCK_STREAM,0);int socket(AF_INET,SOCK_DGRAM,0);AF_INET ipv4AF_INET6 ipv6SOCK_STREAM tcpSOCK_DGRAM udp使用指定参数创建一个套接字 123456#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);将创建的套接字标记为被动套接字,等待客户端连接 12345678910111213#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);阻塞等待连接请求到达,连接请求到达后,创建连接套接字,客户端与服务器使用连接套接字通信#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 123456789#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t send(int sockfd, const void *buf, size_t len, int flags);ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);send 和recv 函数只能用于tcp, sendto和recvfrom函数可以用于udp也可用于tcp 1234567#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t recv(int sockfd, void *buf, size_t len, int flags);ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); 123456789101112write#include &lt;unistd.h&gt; ssize_t write(int fd, const void *buf, size_t count);read#include &lt;unistd.h&gt; ssize_t read(int fd, void *buf, size_t count); 1234567891011121314151617181920212223242526inet_ntop()#include &lt;arpa/inet.h&gt;将网络字节序转为ip地址const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);inet_pton()#include &lt;arpa/inet.h&gt;直接将ip地址转为网络字节序(不需要先转为主机字节序,再转为网络字节序)int inet_pton(int af, const char *src, void *dst);#include &lt;arpa/inet.h&gt; uint32_t htonl(uint32_t hostlong); //host to network long 主机字节序转网络字节序 l表示long,转ip,s表示short转port uint16_t htons(uint16_t hostshort); uint32_t ntohl(uint32_t netlong); uint16_t ntohs(uint16_t netshort); Tcp 服务器客户端通信过程12345678910111213141516服务器:socket() 创建套接字bind()listen() 将套接字标记为监听套接字accept() 阻塞等待客户端连接,收到连接请求后,建立连接返回连接套接字send,recv接收消息(或者使用write,read,或者sendto,recvfrom)客户端:socket() 创建套接字bind() 可隐式绑定connect() 连接服务器sendto() recvfrom() 收发消息(udp不能使用recv和send函数) Udp服务器客户端通信过程12345678910111213141516Udp不需建立连接,所以不需要accept不需要connect不需要listen服务器:socket() 创建套接字bind()recvfrom()sendto()客户端:socket() 创建套接字bind() 可以隐式绑定sendto() recvfrom() 非阻塞123456789101112131415161718192021222324252627282930313233343536371）阻塞（Blocked）：当调用某个函数时，若操作条件不具备，函数会一直处于等待状态，程序的执行进程会在该函数调用处停顿，直到操作完成或发生错误为止。2）非阻塞（Nonblocked）：当调用某个函数时，无论操作条件是否具备，函数均会立即返回，程序的执行进程不会在该函数调用处停顿，而是继续执行。1）SOCK_DGRAM及SOCK_STREAM类型的套接字均可以工作在阻塞模式或非阻塞模式2）Linux中，创建套接字的同时可以指定工作模式，例如socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0)上述代码会创建非阻塞模式的套接字。默认情况下，新建的套接字工作在阻塞模式如果要把工作在阻塞模式的套接字改为非阻塞模式,可以使用函数fcntl (下面参数里sockfd即为阻塞模式的套接字),(用法: 例如accept函数返回的套接字不能直接设置为非阻塞需要fcntl函数处理)fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK);1）非阻塞模式套接字的函数调用失败时，并不一定表示真的遇到了网络错误，应根据errno的值进行相应的处理2）若errno值为EAGAIN或EWOULDBLOCK，则表示操作条件目前并不具备，而不是遇到了网络错误 sockC &#x3D; accept(sock, (struct sockaddr*)&amp;addrC, &amp;sizeAddr); if(-1 &#x3D;&#x3D; sockC) &#123; if(errno !&#x3D; EAGAIN &amp;&amp; errno !&#x3D; EWOULDBLOCK) &#123; printf(&quot;accept() error : %d -&gt; %s\\n&quot;, errno, strerror(errno)); &#125; &#125; 多线程多线程创建管理1234567头文件#include&lt;pthread.h&gt; 编译时加上-pthtread参数pthread_t thread;pthread_create(&amp;thread,NULL,doThread,(void*)arg); /*创建线程,线程id为thread*/pthread_detach(thread); /* 分离线程,意思是线程函数执行完毕后系统自动回收线程 */pthread_join(thread,NULL); /* 等待线程函数结束(直到线程函数结束,代码不会向下执行),可以接收线程函数的返回值(线程函数返回值为void* 所以可以返回任何值) */ 多线程同步信号量 1234567891011线程的信号量与进程间通信中使用的信号量的概念是一样，它是一种特殊的变量，它可以被增加或减少，但对其的关键访问被保证是原子操作。如果一个程序中有多个线程试图改变一个信号量的值，系统将保证所有的操作都将依次进行。信号量的函数都以sem_开头，线程中使用的基本信号量函数有4个，它们都声明在头文件semaphore.h中。1. sem_init函数 该函数用于创建信号量 int sem_init(sem_t *sem, int pshared， unsigned int value);2. sem_wait函数 该函数用于以原子操作的方式将信号量的值减1。 int sem_wait(sem_t *sem);3. sem_post函数 该函数用于以原子操作的方式将信号量的值加1。 int sem_post(sem_t *sem);4. sem_destroy函数 该函数用于对用完的信号量的清理 int sem_destroy(sem_t *sem);sem_wait(); 到 sem_post(); 之间的代码是原子操作,不用管信号量的值是几,具体由操作系统管理 互斥量 12345pthread_mutex_t mutex; /* 创建锁*/pthread_mutex_init(&amp;mutex, NULL); /* 初始化锁 */pthread_mutex_lock(&amp;mutex); /* 上锁 */pthread_mutex_unlock(&amp;mutex); /* 解锁*/pthread_mutex_destroy(&amp;mutex); /* 销毁锁 */ select1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;sys/select.h&gt;int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict errorfds, struct timeval *restrict timeout); void FD_ZERO(fd_set *set) 将set清空为0 void FD_SET(int fd,fd_set *set) 将fd设置到set集合中去 void FD_CLR(int fd,fd_set *set) 将fd从set中清除出去 int FD_ISSET(int fd,fd_set *set) 判断文件描述符fd是否在set集合中( FD_ISSET() tests to see if a file descriptor is part of the set;) __FD_SETSIZE 系统定义的宏,表示文件描述符最多个数,一般是1024,也可以不加前面两个下划线即FD_SETSIZE使用过程:fd_set fsRead,fsRead2; //集合int Maxfd; //最大描述符struct timeval tmot; //超时时间int countFd; //select返回值,(满足条件的描述符个数)FD_ZERO(&amp;fsRead); //清空集合FD_SET(listenfd,&amp;fsRead); //将监听套接字放在集合中Maxfd = listenfd;//主循环while(1)&#123; //备份 fsRead2 = fsRead; //设置超时时间 tmot.tv_sec = 0; //秒 tmot.tv_usec = 200000; //微秒 //select函数 countFD = select(maxFD + 1, &amp;fsRead2, NULL, NULL, &amp;tmot); //返回值: 返回发生事件的套接字的个数 if(countFD == -1) &#123; printf(\"select() error : %d -&gt; %s\\n\", errno, strerror(errno)); &#125; else if(countFD == 0) &#123; /* 无就绪描述符,输出超时 */ //time out printf(\"select() timeout\\n\"); &#125;else&#123; for(k = 0; k &lt; maxFD + 1; k++) &#123; if(FD_ISSET(k, &amp;fsRead2)) /* 判断k是否在集合fsRead2中 */ &#123; if(k == listenfd)&#123; //发生事件的是监听套接字,说明有连接到来 int connfd = accept(); /* 把创建的连接描述符放在集合里 */ FD_SET(sockC, &amp;fsRead); if(sockC &gt; maxFD)&#123; maxFD = sockC; &#125; &#125;else&#123; //发生事件的是连接套接字,接收发来的消息,并回复 recv(); send(); &#125; &#125; &#125; &#125;&#125; winsock编程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576771）准备WinSock环境int WSAStartup（WORD wVersionRequested， LPWSADATA lpWSAData）a）参数1：为期待的版本，可以使用MAKEWORD（x，y）来指定版本，其中x为主版本，占据低字节，y为次版本，占据高字节，目前均使用2.0以上版本，常用2.2；b）参数2：指向一个WSADATA结构体，用于填充返回相关信息c）返回值：操作成功，返回0，否则返回错误代码。注意，在WinSock执行环境未准备好时，不能调用WSAGetLastError（）2）清除WinSock环境int WSACleanup（void）若成功返回0，否则返回SOCKET_ERROR。一般不会出错。3）获取错误int WSAGetLastError（void）返回当前线程上次WinSock操作失败时的具体错误代码。大部分WinSock错误代码以WSAE作为前辍4）设置I/O模式int ioctlsocket（SOCKET s，long cmd，u_long FAR *argp）a）s为指定套接字b）cmd为要执行的命令c）argp指向命令需要的参数d）返回值：操作成功返回0，否则返回SOCKET_ERRORe）设置为非阻塞模式时，cmd为FIONBIO，argp指向值为非0的整型变量5）关闭套接字int closesocket（SOCKET s）若操作成功返回0，否则返回SOCKET_ERROR。#include&lt;winsock2.h&gt;#pragma comment(lib,\"ws2_32\")int main()&#123; struct WSADATA wsd; int code = WSAStartup(0x0202,&amp;wsd); //0x0202表示版本 if(code != 0)&#123; printf(\"WSAStartup error: %d\",code); return -1; &#125; 其他与Linux一样 closesocket(sockfd); WSACleanup();&#125; 字符串处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758头文件#include&lt;string.h&gt;strstr(str,\"hello\"); 在字符串str中找到hello字符串返回hello字符串,找不到返回NULLstrchr(str,'\\n'); 在字符串str中寻找回车符strcmp(str,\"hello\"); 如果str字符串与\"hello\"字符串相等,那么返回0,其他返回值不常用strcat(str,\"hello\"); 在字符串str后面拼接上hello字符strcpy(str,\"hello\"); 把字符串hello拷贝给str,str原来的值被覆盖指针,指针也是处理字符串很好用的方式例如:分割http请求第一行GET /index.html HTTP/1.1首先提取出http请求的第一行假设整个请求存在request数组里char *p = request;char *q = strchr(request,'\\n');指针p和q之间就是这一行数据char method[1024];char uri[1024];char version[1024];Split(&amp;p,q,method); 分离出方法Split(&amp;p,q,uri);Split(&amp;p,q,version);最终结果: method 存放 GETuri 存放/index.htmlversion存放HTTP/1.1void Split(char **p,char *q,char *s)&#123; while((*p) != q) &#123; if( (**p) == ' ' ) &#123; (*p)++; break; &#125; *(s++) = *((*p)++); &#125;&#125; 简答题listen backlog作用 recv 返回值 epoll使用过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;sys/epoll.h&gt;2）创建epoll实例int epoll_create（int size）epoll模型由内核管理，需要向内核申请创建实例。参数size为实例大小，可以理解为所管理描述符的数量。在Linux 2.6.8以后，size会由系统自动调整，该参数仅仅为保持兼容而存在。若操作成功，会返回引用该实例的描述符，否则返回-1。3）注册描述符及事件int epoll_ctl（int epfd, int op, int fd, struct epoll_event *event）epoll模型将管理若干描述符及关心的事件（与select作用类似），这些管理功能均通过该函数表示。操作成功，返回0，否则返回-1。各参数含义：a）epfd为epoll实例描述符b）fd为要管理的描述符c）event为该描述符上关心的事件，类型为结构体类型：struct epoll_event&#123; __uint32_t events; epoll_data_t data;｝；events是由以下事件标志通过 | 运算得到的组合EPOLLIN：可读数据（有数据到达）EPOLLOUT：可写数据（可发送给对方）EPOLLPRI：对于流式套接字，收到了OOB数据EPOLLRDHUP：对方调用了close()或shutdown()，在ET模式下很有用EPOLLERR：发生错误的情况EPOLLET：启用ET（Edge Triggered，边缘触发，状态发生变化）模式，默认模式为LT（Level Triggered，条件或水平触发，状态不变，但总满足“操作就绪”的要求）EPOLLONESHOT：只使用一次，单独使用无意义除上述标志以外，Linux的不同版本还增加了其它事件标志。data成员表示事件对应的数据，其定义为：typedef union epoll_data&#123; void *ptr; int fd; __uint32_t u32; __uint64_t u64;｝epoll_data_t；d）op表示要执行的管理操作，有三个：EPOLL_CTL_XXX，其中XXX是ADD、DEL、MOD三者之一，分别表示新注册、删除已有、修改已有4）进行监控int epoll_wait（int epfd, struct epoll_event *events, int maxevents, int timeout）执行完成后，若有描述符上期待的事件发生，返回描述数个数；若超时，返回0；若出错，返回-1。参数含义为：a）epfd，epoll实例的描述符b）events，用户动态申请的内存空间，用于存放产生事件的描述符等信息，若有n个描述符上产生了期待的事件，这n个描述符的相关信息存放在events的前n个元素中c）maxevents，events空间大小d）timeout，该参数与select模型中的不同，它以毫秒为单位设置时间间隔。若为0，调用会立即返回；若为-1，则无限期等待，直至出错或有描述符发生事件；若为其它值，则会等待指定的时间间隔，在此时间内，若有事件发生，会返回，否则会等到超时再返回。该参数设置会影响性能 123456789101112131415一、数据报套接字的两种通信模式1、客户机/服务器模式也可称为主从模式，服务器不主动向客户机发送数据，而是处于等待状态，客户机主动发起数据通信的过程，类似于流式套接字的工作模式。在该模式中，服务器需要绑定操作，客户机不需要。2、对等模式既向不特定主机发送信息，也接收不特定主机发送来的信息。在该模式中，参与通信方均需要绑定操作。 12345672、epoll模型1）epoll是Linux上的高性能I/O模型。Kqueue是FreeBSD系统中的模型，Windows是IOCP模型。2）下图中体现select与epoll模型性能的差异，很明显，当连接数量较大时，select模型的性能明显下降，epoll模型的性能比较稳定，不会随着管理描述数量的增加出现明显性能下降的情况。3）epoll适用于连接数量较多，但活动连接数量相对较少的情况。 123451、WSAAsyncSelect概述1）当协议栈检测到某个套接字上有数据到达（事件）时，便会向该套接字所属应用发送通知消息，应用收到消息后再进行处理。这种方式使用起来非常自然，也符合Windows系统的特性，即事件（套接字状态变化） -&gt; 消息传递（向应用发送消息） -&gt; 响应（应用程序处理）。2）WSAAsyncSelect是另一种I/O复用模型，非常适合GUI界面的应用。 123453、select模型1）该关注的套接字（描述符）存储在fd_set集合中，select模型会监控一段时间内集合中所有有效的套接字是否“操作就绪”，若是会保留下来，否则会将该套接字移出集合，对于仍然存在于集合中的套接字，可以直接进行相应的操作，而不必再花时间等待。2）对套接字的关注只有三种类型：数据是否可读？数据是否可写？是否发生错误？为方便，模型按感兴趣的类型将套接字集合分为三种，某个套接字可以只加入一个集合，也可以同时加入多个集合。 1TIME_WAIT出现的原因","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://humancloud.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"这是一篇示例文章","slug":"example","date":"2020-04-05T03:51:04.000Z","updated":"2020-04-05T11:14:10.458Z","comments":true,"path":"2020/04/05/example/","link":"","permalink":"https://humancloud.github.io/2020/04/05/example/","excerpt":"前言 Hexo博客美化配置,这篇文章讲解了,Hexo博客的美化与配置","text":"前言 Hexo博客美化配置,这篇文章讲解了,Hexo博客的美化与配置 标题1内容1 标题2内容2 如果您喜欢我的文章,欢迎关注下面的我滴公众号","categories":[],"tags":[]},{"title":"network","slug":"network","date":"2020-03-22T07:06:29.275Z","updated":"2020-04-05T02:57:51.619Z","comments":true,"path":"2020/03/22/network/","link":"","permalink":"https://humancloud.github.io/2020/03/22/network/","excerpt":"作业:1、查看listen的man page信息，了解backlog的作用，下次找同学回答。123456789101112backlog::允许同时与服务器连接的客户端数量 查看系统默认backlog:cat /proc/sys/net/ipv4/tcp_max_syn_backlog 监听端口后,被动套接字等待连接(listen函数把套接字变成被动套接字,accept函数阻塞等待连接),此时系统中维护着两个队列,第一个队列存放的是已建立连接的套接字(即完成三次握手后的established),第二个队列是未建立连接的套接字(处于三次握手中的syn_rcvd),每次accept会将第一个队列中的套接字返回,进行通信,以完成网络传输linux2.2以前,backlog表示两个队列总和的长度linux2.2以后,backlog表示已完成连接的队列的长度","text":"作业:1、查看listen的man page信息，了解backlog的作用，下次找同学回答。123456789101112backlog::允许同时与服务器连接的客户端数量 查看系统默认backlog:cat /proc/sys/net/ipv4/tcp_max_syn_backlog 监听端口后,被动套接字等待连接(listen函数把套接字变成被动套接字,accept函数阻塞等待连接),此时系统中维护着两个队列,第一个队列存放的是已建立连接的套接字(即完成三次握手后的established),第二个队列是未建立连接的套接字(处于三次握手中的syn_rcvd),每次accept会将第一个队列中的套接字返回,进行通信,以完成网络传输linux2.2以前,backlog表示两个队列总和的长度linux2.2以后,backlog表示已完成连接的队列的长度 2、查看recv的man page信息，了解recv返回值的信息，下次解答12345678recv函数原型为: ssize_t recv(int sockfd, void *buf, size_t len, int flags);参数:第一个参数：接收端的套接字描述符第二个参数：接受数据的缓冲区第三个参数：缓冲区的尺寸，sizeof（）第四个参数：置0 原理: 123456789101112当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，如果协议在传送s的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR；如果s的发送缓冲中没有数据或者数据被协议成功发送完毕后，recv先检查套接字s的接收缓冲区，如果s接收缓冲区中没有数据或者协议正在接收数据，那么recv就一直等待，直到协议把数据接收完毕；当协议把数据接收完毕，recv函数就把s的接收缓冲中的数据copy到buf中注意协议接收到的数据可能大于buf的长度，所以在这种情况下要调用几次recv函数才能把s的接收缓冲中的数据copy完。recv函数仅仅是copy数据，真正的接收数据是协议来完成的，recv函数返回其实际copy的字节数；如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。 返回值: 12345678910111213如果recv函数成功，返回值大于0，返回的是其实际copy的字节数；如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。EAGAIN：套接字已标记为非阻塞，而接收操作被阻塞或者接收超时EBADF：sock不是有效的描述词ECONNREFUSE：远程主机阻绝网络连接EFAULT：内存空间访问出错EINTR：操作被信号中断EINVAL：参数无效ENOMEM：内存不足ENOTCONN：与面向连接关联的套接字尚未被连接上ENOTSOCK：sock索引的不是套接字 send函数: 12原型:ssize_t send(int sockfd, const void *buf, size_t len, int flags); 返回值: 1231. s 指定发送端套接字描述符。2. buff 表示存放发送数据的缓冲区。 3. 实际要发送的字节数， 原理: 1234567891011121314151617当调用该函数时，send先比较待发送数据的长度len和套接字s的发送缓冲区的长度，如果len大于s的发送缓冲区的长度，该函数返回SOCKET_ERROR； 如果len小于或者等于s的发送缓冲区的长度，那么send先检查协议是否正在发送s的发送缓冲中的数据； 如果是就等待协议把数据发送完，如果协议还没有开始发送s的发送缓冲中的数据或者s的发送缓冲中没有数据，那么send就比较s的发送缓冲区的剩余空间和len； 如果len大于剩余空间大小，send就一直等待协议把s的发送缓冲中的数据发送完，如果len小于剩余空间大小，send就仅仅把buf中的数据copy到剩余空间里（注意并不是send把s的发送缓冲中的数据传到连接的另一端的，而是协议传的，send仅仅是把buf中的数据copy到s的发送缓冲区的剩余空间里）。 如果send函数copy数据成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR； 如果send在等待协议传送数据时网络断开的话，那么send函数也返回SOCKET_ERROR。要注意send函数把buf中的数据成功copy到s的发送缓冲的剩余空间里后它就返回了，但是此时这些数据并不一定马上被传到连接的另一端。 如果协议在后续的传送过程中出现网络错误的话，那么下一个Socket函数就会返回SOCKET_ERROR。（每一个除send外的Socket函数在执行的最开始总要先等待套接字的发送缓冲中的数据被协议传送完毕才能继续，如果在等待时出现网络错误，那么该Socket函数就返回SOCKET_ERROR #### 3、为客户端加上退出机制 12345if (strcmp(bufOut,\"bye\")==0) &#123; printf(\"you input bye\"); break; &#125; 4、为服务端加上特殊的“停止服务”功能。(确定对方是管理员才退出,否则不退出)本节课内容:12345678910111213141516171819202122232425262728293031323334353637383940udp: recvfrom不一定接收到对端发来的信息,因为udp不检查对端是否收到,tcp检查吗浏览器访问www.qq.com:7777是访问不了的,因为服务器上没有应用程序运行在7777端口服务端:1、创建流式套接字，目的是监听连接请求2、绑定对外公布的地址信息3、确定连接请求队列大小，进入监听套接字监听状态4、当有客户端的连接请求到来时，创建一个为该客户端提供1对1服务的流式套接字，它只起数据传输作用，称为响应套接字5、响应套接字与客户端套接字成为通信双方，这个通信是有连接的，在此基础上，可以按照通信规程（业务逻辑）传输数据5.1、发送数据：将数据从应用程序缓冲区复制到套接字的发送缓冲区，至于何时真正发送到对方，由协议栈决定5.2、接收数据：将数据从套接字的接收缓冲区移动到应用程序的缓冲区，6、数据传输完成后，可关闭响应套接字7、一般情况下，不关闭监听套接字，除非有特殊要求客户端:1、创建流式套接字2、根据服务端公布的地址信息，连接到服务端3、连接成功后，可以按照通信规程（业务逻辑）传输数据3.1、发送数据：将数据从应用程序缓冲区复制到套接字的发送缓冲区，至于何时真正发送到对方，由协议栈决定3.2、接收数据：将数据从套接字的接收缓冲区移动到应用程序的缓冲区，4、数据传输完成后，可关闭套接字","categories":[],"tags":[]},{"title":"network-2","slug":"network-2","date":"2020-03-22T07:06:29.265Z","updated":"2020-05-31T12:58:01.016Z","comments":true,"path":"2020/03/22/network-2/","link":"","permalink":"https://humancloud.github.io/2020/03/22/network-2/","excerpt":"前言: 笔记linux系统中维护着两个队列 第一个队列存放的是已建立连接的套接字(即完成三次握手后的established), 第二个队列是未建立连接的套接字(处于三次握手中的syn_rcvd), 每次accept会将第一个队列中的套接字返回,进行通信,以完成网络传输","text":"前言: 笔记linux系统中维护着两个队列 第一个队列存放的是已建立连接的套接字(即完成三次握手后的established), 第二个队列是未建立连接的套接字(处于三次握手中的syn_rcvd), 每次accept会将第一个队列中的套接字返回,进行通信,以完成网络传输 图中仅给出了第一个队列,这个队列的连接已经被TCP接收（已经完成三次握手），但是还没有被应用程序接收（调用accept函数) 1234567监听端口后,被动套接字等待连接(socket函数产生套接字(默认为主动套接字),bind函数绑定端口,listen函数把套接字变成被动套接字,accept函数阻塞等待连接客户端使用connect函数主动与服务器建立连接,服务器accept接收连接,accept函数返回连接套接字,两端通过连接套接字进行通信) listen函数 123456listen函数int listen(int sockfd, int backlog);linux2.2以前,backlog表示两个队列总和的长度linux2.2以后,backlog表示已完成连接的队列的长度,当长度超过会忽略客户端的请求连接 实验1将服务端的listen函数第二个参数设置为0 可以看到,我打开了个5客户端, 123456netstat | grep tcp查看信息,可以看到,前两对客户端的状态是established后面三个客户端(不是3对了),状态是syn_sent(表示请求连接),也就是客户端在请求与服务器连接在一段时间后,后面三个客户端报错了-连接超时(说明服务器忽略了后面三个连接请求,因为达到了队列最大长度) 设置为1 123456netstat | grep tcp查看信息,可以看到,前3对客户端的状态是established后面两个状态是syn_sent(表示请求连接),也就是客户端在请求与服务器连接在一段时间后,后面2个客户端报错了-连接超时 实现1结论:12345backlog设置为0 : 可以与2个客户端建立tcp连接backlog设置为1 : 可以与3个客户端建立tcp连接&lt;&lt;Unix网络编程&gt;&gt;说backlog从未有过正式的定义, 实验2:123456789sockC = accept(sock, (struct sockaddr*)&amp;addrC, &amp;sizeAddr);if(-1 == sockC) &#123; printf(\"accept() error : %d -&gt; %s\\n\", errno, strerror(errno)); continue; &#125;printf(\"accept call\\n\");在accept函数后面加上信息,输出\"accept call\"表示accept已经执行完毕并返回 此时来看一下 第一个客户端与服务器建立连接,可以看到输出了客户端1的ip端口信息并且可以看到accept函数调用成功并返回了,再打开第二个客户端,服务器并没有响应此时客户端1可以与服务器通信但客户端2不可以 结束第一个客户端,可以看到此时第二个客户端连接到服务器并调用了accept函数, 注意: 1234567shell命令netstat查看信息(左下角终端)netstat | grep tcp可以看到有两对连接两对连接都是established状态,即两个客户端都已经与服务器建立了Tcp连接,进入连接队列","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://humancloud.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"pip更换国内源","slug":"pip","date":"2020-03-09T04:33:07.000Z","updated":"2020-04-11T02:03:56.761Z","comments":true,"path":"2020/03/09/pip/","link":"","permalink":"https://humancloud.github.io/2020/03/09/pip/","excerpt":"","text":"pip更换国内源将会有几兆每秒的速度 步骤 12345678mkdir ~/.pipvim ~/.pip/pip.conf打开文件后,输入以下信息,即可使用清华源[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host = https://pypi.tuna.tsinghua.edu.cn 使用easy_install来安装模块 1234567easy_install 换源cd /root 注意要放到/root目录下vi .pydistutils.cfg 打开配置文件[easy_install]index-url=http://mirrors.aliyun.com/pypi/simple/find-links=http://mirrors.aliyun.com/pypi/simple/","categories":[],"tags":[]}],"categories":[{"name":"面试小总结","slug":"面试小总结","permalink":"https://humancloud.github.io/categories/%E9%9D%A2%E8%AF%95%E5%B0%8F%E6%80%BB%E7%BB%93/"},{"name":"C语言","slug":"C语言","permalink":"https://humancloud.github.io/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"网络编程","slug":"网络编程","permalink":"https://humancloud.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]}