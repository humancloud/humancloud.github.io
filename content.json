{"meta":{"title":"L.R.K","subtitle":"","description":"Welcome!","author":"L.R.K","url":"https://humancloud.github.io","root":"/"},"pages":[{"title":"标签","date":"2020-04-05T05:10:45.000Z","updated":"2020-04-05T05:14:19.486Z","comments":true,"path":"tags/index.html","permalink":"https://humancloud.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-05T05:10:56.000Z","updated":"2020-04-05T05:13:47.982Z","comments":true,"path":"categories/index.html","permalink":"https://humancloud.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"编译修改并测试Golang源码","slug":"编译测试Gola源码","date":"2021-01-05T09:59:58.000Z","updated":"2021-02-19T07:00:40.789Z","comments":true,"path":"2021/01/05/编译测试Gola源码/","link":"","permalink":"https://humancloud.github.io/2021/01/05/%E7%BC%96%E8%AF%91%E6%B5%8B%E8%AF%95Gola%E6%BA%90%E7%A0%81/","excerpt":"编译修改并测试Golang源码环境:操作系统: 5.4.80-2-MANJARO本机Golang: go1.15.5要编译的Golang : go1.15.6","text":"编译修改并测试Golang源码环境:操作系统: 5.4.80-2-MANJARO本机Golang: go1.15.5要编译的Golang : go1.15.6 开始安装 官网下载源码包 解压下载的源码包到我的/code目录，解压后进入/code/go/src 直接执行./all.bash, 下面为命令输出 注意: 编译需要你的电脑已经安装了Golang,并且不能设置GOROOT 123456➜ code git:(master) echo $GOROOT # 注意由于编译后会存在两个版本的Golang，所以不要设置GOROOT，如果设置了请删除，其实官方不推荐设置GOROOT，因为安装Golang时程序会自动检测， 不管是包管理器安装编译好的二进制形式的Golang，还是下载源码自己安装，都会自动检测安装目录作为GOROOT，如果要多版本共存，那么就不能手动设置GOROOT，否则两个版本只有一个GOROOT，会出问题， 如果设置了GOROOT，在我的机器上，安装后两个版本的GOROOT都是/usr/lib/go,然后编译测试代码时会提示编译器1.15.5与工具版本1.15.6不合适(本机go为go1.15.5 源码安装的那个为go1.15.6), 也就是我运行go1.15.6编译出来的go二进制文件，其实运行的是GOROOT指定的那个即1.15.5版本的那个， 所以删除GOROOT，将GOROOT设置为空，然后重新编译，然后问题消失，并且GOROOT一个是/usr/lib/go,一个是~/code/go,两个都正确。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163➜ code git:(master) lsgo1.15.6.src.tar.gz➜ code git:(master) tar -zxvf go1.15.6.src.tar.gz➜ code git:(master) cd go/src# 开始编译➜ src git:(master) ./all.bashBuilding Go cmd/dist using /usr/lib/go. (go1.15.5 linux/amd64)Building Go toolchain1 using /usr/lib/go.Building Go bootstrap cmd/go (go_bootstrap) using Go toolchain1.Building Go toolchain2 using go_bootstrap and Go toolchain1.Building Go toolchain3 using go_bootstrap and Go toolchain2.Building packages and commands for linux/amd64.##### Testing packages.ok archive/tar 0.174sok archive/zip 0.171sok bufio 0.245sok bytes 0.565sok compress/bzip2 0.203sok compress/flate 1.672sok compress/gzip 0.139sok compress/lzw 0.041sok compress/zlib 0.113sok container/heap 0.046sok container/list 0.012sok container/ring 0.013sok context 0.035sok crypto 0.018sok crypto/aes 0.093sok crypto/cipher 0.077sok crypto/des 0.044sok crypto/dsa 0.025sok crypto/ecdsa 0.755sok crypto/ed25519 0.218sok crypto/elliptic 0.096sok crypto/hmac 0.045sok crypto/internal/subtle 0.023sok crypto/md5 0.028s--------------------------省略很多输出--------------------------##### os/user with tag osusergook os/user 0.002s##### GOMAXPROCS=2 runtime -cpu=1,2,4 -quickok runtime 17.545s##### cmd/go terminal testPASSok cmd/go/testdata/testterminal18153 0.003s##### Testing without libgcc.ok crypto/x509 0.907sok net 0.024sok os/user 0.087s##### internal linking of -buildmode=pieok reflect 0.226sok os/user 0.009s##### sync -cpu=10ok sync 1.205s##### Testing race detectorok runtime/race 13.396sok flag 0.110sok net 0.127sok os 0.124sok os/exec 0.092sok encoding/gob 0.066sok flag 0.118sok os/exec 0.114s##### ../misc/cgo/stdioPASS##### ../misc/cgo/lifePASS##### ../misc/cgo/testPASSok misc/cgo/test 7.279sPASSok misc/cgo/test 7.097sPASSok misc/cgo/test 7.370sPASSok misc/cgo/testtls 0.011sPASSok misc/cgo/testtls 0.017sPASSok misc/cgo/testtls 0.013sPASSok misc/cgo/nocgo 0.009sPASSok misc/cgo/nocgo 0.006sPASSok misc/cgo/nocgo 0.003sPASSok misc/cgo/test 7.589sPASSok misc/cgo/test 9.427sPASSok misc/cgo/test 8.617sPASSok misc/cgo/test 8.190sPASSok misc/cgo/testtls 0.007sPASSok misc/cgo/nocgo 0.004s##### ../misc/cgo/testgodefsPASS##### ../misc/cgo/testsook misc/cgo/testso 1.069s##### ../misc/cgo/testsovarok misc/cgo/testsovar 1.141s##### ../misc/cgo/testcarchiveSKIP - short mode and $GO_BUILDER_NAME not set##### ../misc/cgo/testcsharedSKIP - short mode and $GO_BUILDER_NAME not set##### ../misc/cgo/testsharedok misc/cgo/testshared 36.556s##### ../misc/cgo/testpluginok misc/cgo/testplugin 0.003s##### ../misc/cgo/testasanok testasan 78ms##### ../misc/cgo/testsanitizersPASS##### ../misc/cgo/errorsPASS##### ../misc/cgo/testsigfwdok testsigfwd##### ../test/bench/go1##### ../test##### API checkGo version is \"go1.15.6\", ignoring -next /home/lu/code/go/api/next.txtALL TESTS PASSED---Installed Go for linux/amd64 in /home/lu/code/goInstalled commands in /home/lu/code/go/bin*** You need to add /home/lu/code/go/bin to your PATH.没有发生错误，测试也全部通过，可以看到编译好的可执行程序的位置 检查安装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788➜ src git:(master) cd ..➜ go git:(master) lsapi AUTHORS bin CONTRIBUTING.md CONTRIBUTORS doc favicon.ico lib LICENSE misc PATENTS pkg README.md robots.txt SECURITY.md src test VERSION➜ go git:(master) cd bin➜ bin git:(master) lsgo gofmt➜ bin git:(master) ./go envGO111MODULE=\"\"GOARCH=\"amd64\"GOBIN=\"/home/lu/go/bin\"GOCACHE=\"/home/lu/.cache/go-build\"GOENV=\"/home/lu/.config/go/env\"GOEXE=\"\"GOFLAGS=\"\"GOHOSTARCH=\"amd64\"GOHOSTOS=\"linux\"GOINSECURE=\"\"GOMODCACHE=\"/home/lu/go/pkg/mod\"GONOPROXY=\"\"GONOSUMDB=\"\"GOOS=\"linux\"GOPATH=\"/home/lu/go:/home/lu/code/mygopath\"GOPRIVATE=\"\"GOPROXY=\"https://proxy.golang.org,direct\"GOROOT=\"/home/lu/code/go\"GOSUMDB=\"sum.golang.org\"GOTMPDIR=\"\"GOTOOLDIR=\"/home/lu/code/go/pkg/tool/linux_amd64\"GCCGO=\"gccgo\"AR=\"ar\"CC=\"gcc\"CXX=\"g++\"CGO_ENABLED=\"1\"GOMOD=\"\"CGO_CFLAGS=\"-g -O2\"CGO_CPPFLAGS=\"\"CGO_CXXFLAGS=\"-g -O2\"CGO_FFLAGS=\"-g -O2\"CGO_LDFLAGS=\"-g -O2\"PKG_CONFIG=\"pkg-config\"GOGCCFLAGS=\"-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build196490024=/tmp/go-build -gno-record-gcc-switches\"两个版本是有区别的，两个版本共存➜ bin git:(master) go envGO111MODULE=\"\"GOARCH=\"amd64\"GOBIN=\"/home/lu/go/bin\"GOCACHE=\"/home/lu/.cache/go-build\"GOENV=\"/home/lu/.config/go/env\"GOEXE=\"\"GOFLAGS=\"\"GOHOSTARCH=\"amd64\"GOHOSTOS=\"linux\"GOINSECURE=\"\"GOMODCACHE=\"/home/lu/go/pkg/mod\"GONOPROXY=\"\"GONOSUMDB=\"\"GOOS=\"linux\"GOPATH=\"/home/lu/go:/home/lu/code/mygopath\"GOPRIVATE=\"\"GOPROXY=\"https://proxy.golang.org,direct\"GOROOT=\"/usr/lib/go\"GOSUMDB=\"sum.golang.org\"GOTMPDIR=\"\"GOTOOLDIR=\"/usr/lib/go/pkg/tool/linux_amd64\"GCCGO=\"gccgo\"AR=\"ar\"CC=\"gcc\"CXX=\"g++\"CGO_ENABLED=\"1\"GOMOD=\"\"CGO_CFLAGS=\"-g -O2\"CGO_CPPFLAGS=\"\"CGO_CXXFLAGS=\"-g -O2\"CGO_FFLAGS=\"-g -O2\"CGO_LDFLAGS=\"-g -O2\"PKG_CONFIG=\"pkg-config\"GOGCCFLAGS=\"-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build986789214=/tmp/go-build -gno-record-gcc-switches\"#然后把自己编译的程序连接到bin目录,使用比较方便➜ bin git:(master) cd /bin➜ bin git:(master) ln -s /home/lu/code/go/bin/go mygo➜ bin git:(master) mygo env #检查一下GOROOT对不对，看看是不是/home/lu/code/go 测试123456789101112131415161718192021~/code/go/src/fmt/print.go里面添加代码，然后重新编译func Myputs(str string) &#123; Printf(\"My-Go: %s\\n\",str)&#125;创建目录专门为了测试自己的Golang，并加入Gopath，因为用到自己写的库的话，必须要设置GOPATH，否则import 找不到， import 会去GOPATH找库在~/code/mygopath/src下面创建文件test.go， (不能在~/code/go/src目录，因为编译时，src目录下的文件都会被编译)文件内容:func main() &#123; fmt.Myputs(\"hello\")&#125;直接编译代码即可，竟然不需要手动编译Golang源代码，应该是自动编译了(这也太方便了)➜ src git:(master) mygo build test.go➜ src git:(master) ./testMy-Go: hello // 我们写的代码已经起了作用 继续测试123456789101112131415161718192021222324252627282930313233343536373839还是修改print.go添加函数：func Myfgets(str *string, len int, w io.Reader) int &#123; var n int var err error buf := make([]byte, len) reader := bufio.NewReaderSize(w, len) if n, err = reader.Read(buf); err != nil &#123; Printf(\"error reader.Read\\n\")&#125; *str = string(buf) return n&#125;➜ src git:(master) cat test.gopackage mainimport ( \"fmt\" \"os\")func main() &#123; var buf string fmt.Myputs(\"hello\") fmt.Myfgets(&amp;buf, 10, os.Stdin) fmt.Myputs(buf)&#125;➜ src git:(master) mygo build test.go #直接编译测试代码，不需手动编译源码，就可以➜ src git:(master) ./testMy-Go: helloaaaaMy-Go: aaaa","categories":[{"name":"Golang","slug":"Golang","permalink":"https://humancloud.github.io/categories/Golang/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"IOCCC1984-02","slug":"IOCCC1984-02","date":"2020-11-20T13:44:06.000Z","updated":"2020-11-22T11:47:04.599Z","comments":true,"path":"2020/11/20/IOCCC1984-02/","link":"","permalink":"https://humancloud.github.io/2020/11/20/IOCCC1984-02/","excerpt":"作者： Sjoerd Mullender and Robbert van Renesse源文件： mullender.c","text":"作者： Sjoerd Mullender and Robbert van Renesse源文件： mullender.c 源文件mullender.c 12345678910short main[] = &#123; 277, 04735, -4129, 25, 0, 477, 1019, 0xbef, 0, 12800, -113, 21119, 0x52d7, -1006, -7151, 0, 0x4bc, 020004, 14880, 10541, 2056, 04010, 4548, 3044, -6716, 0x9, 4407, 6, 5568, 1, -30460, 0, 0x9, 5570, 512, -30419, 0x7e82, 0760, 6, 0, 4, 02400, 15, 0, 4, 1280, 4, 0, 4, 0, 0, 0, 0x8, 0, 4, 0, ',', 0, 12, 0, 4, 0, '#', 0, 020, 0, 4, 0, 30, 0, 026, 0, 0x6176, 120, 25712, 'p', 072163, 'r', 29303, 29801, 'e'&#125;; 源文件目录下的hint.text部分内容123456789101112131415161718192021222324252627282930313233&gt; NOTE: If your machine is not a Vax-11 or pdp-11, this program will&gt; not execute correctly. In later years, machine dependent&gt; code was discouraged.The C startup routine (via crt0.o) transfers control to a locationnamed main. In this case, main just happens to be in the data area.The array of shorts, which has been further obfuscated by use ofdifferent data types, just happens to form a meaningful set of PDP-11and Vax instructions. The first word is a PDP-11 branch instructionthat branches to the rest of the PDP code. On the Vax main is called withthe calls instruction which uses the first word of the subroutine as amask of registers to be saved. So on the Vax the first word can be anything.The real Vax code starts with the second word. This small programmakes direct calls to the write() Unix system call to produce amessage on the screen. Can you guess what is printed? We knew youcouldn&#39;t! :-)翻译:&gt;注意：如果您的机器不是Vax-11或pdp-11，此程序将&gt;执行不正确。在未来,代码是依赖机器的&gt;这样的代码是不被鼓励的。C启动程序（通过crt0.o）将控制权转移到一个位置命名为main。在本例中，main正好在数据区域中。进一步使用了shorts的数组不同的数据类型，恰好形成了一组有意义的PDP-11和Vax指令。第一个字是PDP-11分支指令这将分支到PDP代码的其余部分。在Vax主管道上使用子例程的第一个字作为要保存的寄存器掩码。所以在Vax上第一个词可以是任何东西。真正的Vax代码从第二个单词开始。这个小程序直接调用write（）Unix系统调用以生成屏幕上的消息。你能猜出打印的是什么吗？我们知道你不能！:-) 分析写一个测试程序,只有一个主函数test.c 1234int main()&#123;&#125; 对比两个文件的反汇编 1234567891011test.s里面main标号表示main函数,也标志着程序开始执行的地方(由于内存中数据和指令是放在一起的,main标号的作用就是标志着main标号下面的数据都被当做指令处理,不被当做数据处理)而mullender.s里面也有main标号,这个main标号本来的意思是标志数组main的起始,main下面的数据是main数组的数据,而不是指令,但是由于main是有特殊意义的,所以最终执行时main标号下面的内存块的数据都被当做指令去执行,而main下面的数据是什么那, main标号下面是汇编器指令.value,.value将main数组中的元素存储在main标号内存地址下面(注意: 汇编程序中以.开头的名称并不是指令的助记符，不会被翻译成机器指令,所以最终可执行程序里main下面的所有数据都被当做机器码去执行)所以这个程序是可以执行的,而且会执行一些指令,但是要看机器平台了,源程序的目录下有文件说此程序只能运行在pdp-11或Vax-11机器上,其他平台可能会发生错误.&gt; NOTE: If your machine is not a Vax-11 or pdp-11, this program will&gt; not execute correctly. 使用gdb调试器证明main下的数据被当做指令执行123456789101112131415161718已知一下机器代码代表的汇编代码00 c0 add %al,%al08 c4 or %al,%ah编写一个简单的c程序如下short main[] = &#123;0xc000,0xc408&#125;;然后使用gdb反汇编得到结果如下(gdb) disassemble mainDump of assembler code for function main:0x0000000000004028 &lt;+0&gt;: add %al,%al0x000000000000402a &lt;+2&gt;: or %al,%ahEnd of assembler dump.(gdb)直接调试源文件查看汇编,也是一样,只是这里用了一个较小的文件,比较好看. 在pdp11模拟器上运行 使用pdp11模拟器,搭建unix v6系统运行程序但是编译错误,说声明语法有错误,查看了一下unix上的一些c文件,发现原来以前数组是这样初始化的 修改程序后还是编译错误,原来是unix v6不支持0x开头的十六进制数字,而且也没有short数据类型。。。。 重新使用模拟器搭建unix v7系统运行程序,终于可以运行了。。 运行结果 Linux下制作动态图ffmpeg -i xxx.mp4 xxx.gif 程序原理使用adb调试程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122# adb a.out:sstopped at start: setd:sa.out: runningstopped at start+02: mov 02(sp),r0$rps 0170010pc 02 start+02sp 0177720r5 0r4 0r3 0r2 0r1 06r0 012start+02: mov 02(sp),r0:sa.out: runningstopped at start+06: clr 0177776(r0):sa.out: runningstopped at start+012: mov sp,r0:sa.out: runningstopped at start+014: sub $04,sp:sa.out: runningstopped at start+020: mov 04(sp),(sp):sa.out: runningstopped at start+024: tst (r0)+:sa.out: runningstopped at start+026: mov r0,02(sp):sa.out: runningstopped at start+032: tst (r0)+:sa.out: runningstopped at start+034: bne start+032:sa.out: runningstopped at start+032: tst (r0)+:sa.out: runningstopped at start+034: bne start+032:sa.out: runningstopped at start+036: cmp r0,*02(sp):sa.out: runningstopped at start+042: bcs start+046:sa.out: runningstopped at start+046: mov r0,04(sp):sa.out: runningstopped at start+052: mov r0,_environ:sa.out: runningstopped at start+056: jsr pc,__cleanu+04:sa.out: runningstopped at __cleanu+04: br __cleanu+060:sa.out: runningstopped at __cleanu+060: mov pc,r4:sa.out: runningstopped at __cleanu+062: tst -(r4):sa.out: runningstopped at __cleanu+064: sub $011,r4:sa.out: runningstopped at __cleanu+070: mov r4,_main+076:sa.out: runningstopped at __cleanu+074: mov $01,r0:sa.out: runningstopped at __cleanu+0100: sys write; 0161; 011$rps 0170000pc 0212 __cleanu+0100sp 0177712r5 0r4 0161 _main+043r3 0r2 0r1 06r0 01__cleanu+0100: sys write; 0161; 011:sa.out: runningstopped at __cleanu+0112: sys tiu:sa.out: runningstopped at __cleanu+0112: sys tiu:sa.out: runningstopped at __cleanu+0112: sys tiu:sa.out: runningstopped at __cleanu+0112: sys tiu:sa.out: runningstopped at __cleanu+0112: sys tiu:sa.out: runningstopped at __cleanu+0112: sys tiu:sa.out: runningstopped at __cleanu+0112: sys tiu:sa.out: runningstopped at __cleanu+0112: sys tiu继续执行,后面一直都是stopped at __cleanu+0112: sys tiu 由于暂时对pdp-11和Vax指令很不了解, 详细过程暂时还是没有搞懂 如果您对pdp-11和Vax指令比较了解,并想了解原理,那么这篇博客有可能会帮到你","categories":[{"name":"IOCCC","slug":"IOCCC","permalink":"https://humancloud.github.io/categories/IOCCC/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"IOCCC分享","slug":"IOCCC分享","date":"2020-11-18T12:41:01.000Z","updated":"2020-11-18T12:54:57.033Z","comments":true,"path":"2020/11/18/IOCCC分享/","link":"","permalink":"https://humancloud.github.io/2020/11/18/IOCCC%E5%88%86%E4%BA%AB/","excerpt":"IOCCC官方网站下载代码 由于下载代码需要上外网,所以我将1984-2019的所有代码,放在了github上. 代码","text":"IOCCC官方网站下载代码 由于下载代码需要上外网,所以我将1984-2019的所有代码,放在了github上. 代码","categories":[{"name":"IOCCC","slug":"IOCCC","permalink":"https://humancloud.github.io/categories/IOCCC/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"1984IOCCC代码解析","slug":"IOCCC1984-01","date":"2020-11-18T09:39:39.000Z","updated":"2020-11-26T08:25:42.434Z","comments":true,"path":"2020/11/18/IOCCC1984-01/","link":"","permalink":"https://humancloud.github.io/2020/11/18/IOCCC1984-01/","excerpt":"anonymous.c时间: 1984作者: 作者匿名提交了此代码","text":"anonymous.c时间: 1984作者: 作者匿名提交了此代码 源代码: 12int i;main()&#123;for(;i[\"]&lt;i;++i)&#123;--i;&#125;\"];read('-'-'-',i+++\"hell\\o, world!\\n\",'/'/'/'));&#125;read(j,i,p)&#123;write(j/p+p,i---j,i/i);&#125; 解析初步手动格式化123456789101112131415int i; main()&#123; for(;i[\"]&lt;i;++i) //如果编辑器没有高亮,还是不容易看出来这里的格式化不对,其实这里是作者故意迷惑你的 &#123; --i; &#125; \"]; read('-'-'-',i+++\"hello, world!\\n\",'/'/'/'));&#125;read(j,i,p)&#123; write(j/p+p,i---j,i/i);&#125; 更容易理解的格式123456789101112131415161718192021#define STR \"]&lt;i;++i)&#123;--i;&#125;\"int i;int main()&#123; for(;STR[i];read(0,\"hello,world!\\n\"+i++,1)) // '-' - '-' (是两个字符相减)为0, '/' / '/' (两个字符相除)为1 arr[1] 相当于 1[arr] 运算结果相同 ; // 当STR[i] 为0时循环结束即当字符串到结束符时结束循环(一共14次循环)&#125; // 字符串字面值是字符串的首地址,\"hello,world!\\n\" + i++ 的值就是字符串的第i个字符int read(int j,int i,int p)&#123; write(1,i--,1); // i-- i先被使用后自减, 然而每次函数调用i都更新,所以i减不减1都与最后结果无任何关系 // STDIN_FILENO 0, STDOUT_FILENO 1, STDERR_FILENO 2&#125;循环14次,\"hello,world!\\n\"一个14个字符(字符串末尾有空字符'\\0'),每一个字符都使用write系统调用输出到标准输出STDOUT_FILENO程序功能就是输出hello,world!\\n但是在某些机器上运行,没有结果输出(在我的机器上测试时也没有输出)(原因见下面的疑问与解答) 疑问与解答 为什么write函数当做系统调用,read不被当做系统调用那? 由于用户自定义的函数优先,而read函数在源文件中有自己的定义所以不会被当做系统调用. 注意: 如果在当今的C语言中包含了unistd.h头文件,那么里面有read函数的声明,再去自定义read函数会命名冲突,发生错误 为什么没有输出也没有报错那? 1234567891011121314151617181920212223242526272829303132333435363738394041424344我运行代码发现程序并没有输出我们期望的hello,world!,而是什么也没有输出.原因:\"hello,world!\\n\" + i++ 得到的是一个指针,这个指针指针指向一个字符,write系统调用第二个参数也是一个char指针,但是此代码read函数过程中将指针转为int,write函数中再将int转回指针,由于64位机器,指针占8字节,整数占4字节,所以数据一定会丢失,指针将不再正确,write系统调用会失败,而程序并没有检查write系统调用是否正确执行,所以看起来没有报错.加上错误处理:#include &lt;stdio.h&gt;int i;main()&#123; for(; i[\"]&lt;i;++i)&#123;--i;&#125;\"]; read('-'-'-',i+++\"hello, world!\\n\",'/'/'/'));&#125;read(j,i,p) &#123; int n = write(j/p+p,i---j,i/i); if(-1 == n)&#123; perror(\"write\"); &#125;&#125;输出:➜ anonymous git:(master) ./mytestwrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad addresswrite: Bad address如果你的机器是32位的,那么指针和int都是四字节,相互转换不会有问题 下面使用gdb调试继续分析上个问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051使用此代码:1 #include &lt;stdio.h&gt;2 int i;3 main()4 &#123;5 for(; i[\"]&lt;i;++i)&#123;--i;&#125;\"]; read('-'-'-',i+++\"hello, world!\\n\",'/'/'/'));6 &#125;78 read(j,i,p) 9 &#123;10 int n = write(j/p+p,i---j,i/i);11 if(-1 == n)&#123;12 perror(\"write\");13 &#125;14&#125;➜ anonymous git:(master) gcc anonymous.c -o anonymous -g➜ anonymous git:(master) gdb anonymous(gdb) b 5Breakpoint 1 at 0x114d: file mytest.c, line 5.(gdb) b 10Breakpoint 2 at 0x11b0: file mytest.c, line 10.(gdb) rStarting program: /home/lu/code/c/IOCCC/1984/anonymous/mytestBreakpoint 1, main () at mytest.c:55 for(; i[\"]&lt;i;++i)&#123;--i;&#125;\"]; read('-'-'-',i+++\"hello, world!\\n\",'/'/'/'));(gdb) x/14b \"hello, world!\\n\"0x5555555592a0: 104 101 108 108 111 44 32 1190x5555555592a8: 111 114 108 100 33 10(gdb) nBreakpoint 2, read (j=0, i=1431658500, p=1) at mytest.c:1010 int n = write(j/p+p,i---j,i/i);(gdb) info argsj = 0i = 1431658500p = 1可以看到字符串首地址为0x5555555592a0read函数的第二个参数i的值为1431658500 -&gt; 0x55556003指针的值: 0x55 55 55 55 92 a0 00 00转为int后的值: 0x55 55 60 03明显看到丢失了数据 正确运行 在pdp-11模拟器上的unix v7上面运行代码 可看到Unix v7上int类型和指针类型都是2字节,相互转换数据不会丢失","categories":[{"name":"IOCCC","slug":"IOCCC","permalink":"https://humancloud.github.io/categories/IOCCC/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"pip更换国内源","slug":"pip","date":"2020-03-09T04:33:07.000Z","updated":"2020-11-18T08:52:43.347Z","comments":true,"path":"2020/03/09/pip/","link":"","permalink":"https://humancloud.github.io/2020/03/09/pip/","excerpt":"pip更换国内源可加快下载速度","text":"pip更换国内源可加快下载速度 步骤 12345678mkdir ~/.pipvim ~/.pip/pip.conf打开文件后,输入以下信息,即可使用清华源[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host = https://pypi.tuna.tsinghua.edu.cn 使用easy_install来安装模块 1234567easy_install 换源cd /root 注意要放到/root目录下vi .pydistutils.cfg 打开配置文件[easy_install]index-url=http://mirrors.aliyun.com/pypi/simple/find-links=http://mirrors.aliyun.com/pypi/simple/","categories":[],"tags":[]}],"categories":[{"name":"Golang","slug":"Golang","permalink":"https://humancloud.github.io/categories/Golang/"},{"name":"IOCCC","slug":"IOCCC","permalink":"https://humancloud.github.io/categories/IOCCC/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://humancloud.github.io/tags/%E7%AC%94%E8%AE%B0/"}]}