<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>这是一篇示例文章</title>
    <url>/2020/04/05/example/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p><a href="www.github.com">Hexo博客美化配置</a>,这篇文章讲解了,Hexo博客的美化与配置</p>
</blockquote>
<a id="more"></a>



<h2 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h2><p>内容1</p>
<h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><p>内容2</p>
<p>如果您喜欢我的文章,欢迎关注下面的我滴公众号</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>network-2</title>
    <url>/2020/03/22/network-2/</url>
    <content><![CDATA[<h2 id="前言-笔记"><a href="#前言-笔记" class="headerlink" title="前言: 笔记"></a>前言: 笔记</h2><p><strong>linux系统中维护着两个队列</strong></p>
<ul>
<li>第一个队列存放的是已建立连接的套接字(即完成三次握手后的established),</li>
<li>第二个队列是未建立连接的套接字(处于三次握手中的syn_rcvd),</li>
<li>每次accept会将第一个队列中的套接字返回,进行通信,以完成网络传输<a id="more"></a>

</li>
</ul>
<p>图中仅给出了第一个队列,这个队列的连接已经被TCP接收（已经完成三次握手），但是还没有被应用程序接收（调用accept函数)</p>
<p><img src="/2020/03/22/network-2/4.png" alt></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">监听端口后,被动套接字等待连接</span><br><span class="line"></span><br><span class="line">(socket函数产生套接字(默认为主动套接字),bind函数绑定端口,listen函数把套接字变成被动套接字,accept函数阻塞等待连接</span><br><span class="line"></span><br><span class="line">客户端使用connect函数主动与服务器建立连接,</span><br><span class="line"></span><br><span class="line">服务器accept接收连接,accept函数返回连接套接字,两端通过连接套接字进行通信)</span><br></pre></td></tr></table></figure>

<p><strong>listen函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">listen</span>函数</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line">linux2<span class="number">.2</span>以前,backlog表示两个队列总和的长度</span><br><span class="line">linux2<span class="number">.2</span>以后,backlog表示已完成连接的队列的长度,</span><br><span class="line">当长度超过会忽略客户端的请求连接</span><br></pre></td></tr></table></figure>

<h2 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h2><p><strong>将服务端的listen函数第二个参数设置为0</strong></p>
<p><img src="/2020/03/22/network-2/9.png" alt></p>
<p>可以看到,我打开了个5客户端,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat | grep tcp</span><br><span class="line"></span><br><span class="line">查看信息,可以看到,前两对客户端的状态是established</span><br><span class="line">后面三个客户端(不是3对了),状态是syn_sent(表示请求连接),也就是客户端在请求与服务器连接</span><br><span class="line"></span><br><span class="line">在一段时间后,后面三个客户端报错了-连接超时(说明服务器忽略了后面三个连接请求,因为达到了队列最大长度)</span><br></pre></td></tr></table></figure>
<p><strong>设置为1</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat | grep tcp</span><br><span class="line"></span><br><span class="line">查看信息,可以看到,前3对客户端的状态是established</span><br><span class="line">后面两个状态是syn_sent(表示请求连接),也就是客户端在请求与服务器连接</span><br><span class="line"></span><br><span class="line">在一段时间后,后面2个客户端报错了-连接超时</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/22/network-2/7.png" alt></p>
<p><img src="/2020/03/22/network-2/8.png" alt></p>
<h2 id="实现1结论"><a href="#实现1结论" class="headerlink" title="实现1结论:"></a>实现1结论:</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">backlog设置为0  :  可以与2个客户端建立tcp连接</span><br><span class="line">backlog设置为1  :  可以与3个客户端建立tcp连接</span><br><span class="line"></span><br><span class="line">&lt;&lt;Unix网络编程&gt;&gt;说backlog从未有过正式的定义,</span><br></pre></td></tr></table></figure>


<h2 id="实验2"><a href="#实验2" class="headerlink" title="实验2:"></a>实验2:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sockC = accept(sock, (struct sockaddr*)&amp;addrC, &amp;sizeAddr);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == sockC)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"accept() error : %d -&gt; %s\n"</span>, errno, strerror(errno));</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"accept call\n"</span>);</span><br><span class="line"></span><br><span class="line">在accept函数后面加上信息,输出<span class="string">"accept call"</span>表示accept已经执行完毕并返回</span><br></pre></td></tr></table></figure>

<p><strong>此时来看一下</strong></p>
<p>第一个客户端与服务器建立连接,可以看到输出了客户端1的ip端口信息<br>并且可以看到accept函数调用成功并返回了,再打开第二个客户端,服务器并没有响应<br>此时客户端1可以与服务器通信但客户端2不可以</p>
<p><img src="/2020/03/22/network-2/5.png" alt></p>
<p>结束第一个客户端,可以看到此时第二个客户端连接到服务器并调用了accept函数,</p>
<p><img src="/2020/03/22/network-2/6.png" alt></p>
<p><strong>注意:</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shell命令netstat查看信息(左下角终端)</span><br><span class="line"></span><br><span class="line">netstat | grep tcp</span><br><span class="line"></span><br><span class="line">可以看到有两对连接</span><br><span class="line"></span><br><span class="line">两对连接都是established状态,即两个客户端都已经与服务器建立了Tcp连接,进入连接队列</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>pip更换国内源</title>
    <url>/2020/03/09/pip/</url>
    <content><![CDATA[<p>pip更换国内源将会有几兆每秒的速度</p>
<p><strong>步骤</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ~/.pip</span><br><span class="line">vim ~/.pip/pip.conf</span><br><span class="line"></span><br><span class="line">打开文件后,输入以下信息,即可使用清华源</span><br><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = https://pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure>

<p><strong>使用easy_install来安装模块</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">easy_install 换源</span><br><span class="line">cd /root          注意要放到/root目录下</span><br><span class="line">vi .pydistutils.cfg 打开配置文件</span><br><span class="line"></span><br><span class="line">[easy_install]</span><br><span class="line">index-url=http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">find-links=http://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>剑指offer_01</title>
    <url>/2020/04/06/%E5%89%91%E6%8C%87offer-01/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<blockquote>
<p>剑指offer刷题记录</p>
</blockquote>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）,n&lt;=39</strong></p>
<p>F(n)=<br>⎩<br>⎪<br>⎨<br>⎪<br>⎧<br>​    </p>
<p>0,<br>1,<br>F(n−1)+F(n−2),<br>​    </p>
<p>n=0<br>n=1,2<br>n&gt;2<br>​</p>
<a id="more"></a>

<hr>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p><strong>利用循环</strong></p>
<blockquote>
<p>　将元素保存到数组里,从数组中取值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Fib;</span><br><span class="line">        Fib.push_back(<span class="number">0</span>);  <span class="comment">/* 第0个元素赋值 */</span></span><br><span class="line">        Fib.push_back(<span class="number">1</span>);  <span class="comment">/* 第1个元素*/</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;=<span class="number">39</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Fib.push_back(Fib[i<span class="number">-1</span>] + Fib[i<span class="number">-2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fib[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p><strong>使用递归</strong></p>
<blockquote>
<p>效率很低，占用内存空间较大(ｎ大了很可能会出问题)</p>
</blockquote>
<ul>
<li>时间复杂度 : O(2^n^)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">代码中return是基本操作,所以时间复杂度可以理解为return执行的次数</span><br><span class="line">如果n&#x3D;0&#x2F;n&#x3D;1,复杂度为O(1),</span><br><span class="line">n&#x3D;2为O(3),三次return</span><br><span class="line">n&#x3D;3为O(4),四次return</span><br><span class="line"></span><br><span class="line">O(n) &#x3D; O(n-1)+O(n-2)</span><br></pre></td></tr></table></figure></li>
<li>空间复杂度 : O(1) </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>) + Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。<br>n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念<br>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</p>
<p>常见的算法时间复杂度由小到大依次为：<br>$$<br>Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)<br>$$</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程考试总结</title>
    <url>/2020/05/31/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言-笔记"><a href="#前言-笔记" class="headerlink" title="前言: 笔记"></a>前言: 笔记</h2><p>linux多线程的同步即   sem 和 互斥量</p>
<p>程序设计题不涉及多线程,不会使用到select,epoll,WSA等模型,有字符串处理</p>
<p>简答五选三(背五道题)</p>
<a id="more"></a>



<h2 id="函数总结"><a href="#函数总结" class="headerlink" title="函数总结"></a>函数总结</h2><p><strong>TCP echo服务器用到的函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>,失败返回<span class="number">-1</span>,其他返回值通过man了解</span><br></pre></td></tr></table></figure>


<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint8_t</span> 		sin_len;</span><br><span class="line">	<span class="keyword">sa_family_t</span> 	sin_family;</span><br><span class="line">	<span class="keyword">in_port_t</span> 		sin_port;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> 			sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用到的就三个: sin_family,  sin_port,  sin_addr.s_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint8_t</span> 		sa_len;</span><br><span class="line">	<span class="keyword">sa_family_t</span> 	sa_family;</span><br><span class="line">	<span class="keyword">char</span> 			sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">(struct sockaddr *)&amp;addr;  <span class="comment">//主要作用就是强制转换sockaddr_in类型为sockaddr类型</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(AF_INET, SOCK_STREAM,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(AF_INET,SOCK_DGRAM,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">AF_INET       ipv4</span><br><span class="line">AF_INET6      ipv6</span><br><span class="line">SOCK_STREAM   tcp</span><br><span class="line">SOCK_DGRAM    udp</span><br><span class="line"></span><br><span class="line">使用指定参数创建一个套接字</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;      </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line">将创建的套接字标记为被动套接字,等待客户端连接</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">阻塞等待连接请求到达,连接请求到达后,创建连接套接字,客户端与服务器使用连接套接字通信</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;         </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">send 和recv 函数只能用于tcp, sendto和recvfrom函数可以用于udp也可用于tcp</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                 struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">write</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inet_ntop()</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">将网络字节序转为ip地址</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inet_pton()</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">直接将ip地址转为网络字节序(不需要先转为主机字节序,再转为网络字节序)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;              <span class="comment">//host to network long          主机字节序转网络字节序   l表示long,转ip,s表示short转port</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="Tcp-服务器客户端通信过程"><a href="#Tcp-服务器客户端通信过程" class="headerlink" title="Tcp 服务器客户端通信过程"></a>Tcp 服务器客户端通信过程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">服务器:</span><br><span class="line">socket()  创建套接字</span><br><span class="line"><span class="built_in">listen</span>()  将套接字标记为监听套接字</span><br><span class="line">accept()  阻塞等待客户端连接,收到连接请求后,建立连接返回连接套接字</span><br><span class="line"></span><br><span class="line">send,recv接收消息(或者使用<span class="built_in">write</span>,<span class="built_in">read</span>,或者sendto,recvfrom)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">客户端:</span><br><span class="line">socket()  创建套接字</span><br><span class="line"><span class="built_in">connect</span>() 连接服务器</span><br><span class="line">sendto() </span><br><span class="line">recvfrom()   收发消息(udp不能使用recv和send函数)</span><br></pre></td></tr></table></figure>

<h3 id="Udp服务器客户端通信过程"><a href="#Udp服务器客户端通信过程" class="headerlink" title="Udp服务器客户端通信过程"></a>Udp服务器客户端通信过程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Udp不需建立连接,所以不需要accept不需要<span class="built_in">connect</span>不需要<span class="built_in">listen</span></span><br><span class="line"></span><br><span class="line">服务器:</span><br><span class="line">socket()  创建套接字</span><br><span class="line">recvfrom()</span><br><span class="line">sendto()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">客户端:</span><br><span class="line">socket()  创建套接字</span><br><span class="line">sendto() </span><br><span class="line">recvfrom()</span><br></pre></td></tr></table></figure>




<h2 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）阻塞（Blocked）：当调用某个函数时，若操作条件不具备，函数会一直处于等待状态，程序的执行进程会在该函数调用处停顿，直到操作完成或发生错误为止。</span><br><span class="line"></span><br><span class="line">2）非阻塞（Nonblocked）：当调用某个函数时，无论操作条件是否具备，函数均会立即返回，程序的执行进程不会在该函数调用处停顿，而是继续执行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1）SOCK_DGRAM及SOCK_STREAM类型的套接字均可以工作在阻塞模式或非阻塞模式</span><br><span class="line"></span><br><span class="line">2）Linux中，创建套接字的同时可以指定工作模式，例如</span><br><span class="line"></span><br><span class="line">socket(AF_INET, SOCK_STREAM |  SOCK_NONBLOCK, 0)</span><br><span class="line"></span><br><span class="line">上述代码会创建非阻塞模式的套接字。默认情况下，新建的套接字工作在阻塞模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果要把工作在阻塞模式的套接字改为非阻塞模式,可以使用函数fcntl (下面参数里sockfd即为阻塞模式的套接字),</span><br><span class="line"></span><br><span class="line">(用法: 例如accept函数返回的套接字不能直接设置为非阻塞需要fcntl函数处理)</span><br><span class="line"></span><br><span class="line">fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1）非阻塞模式套接字的函数调用失败时，并不一定表示真的遇到了网络错误，应根据errno的值进行相应的处理</span><br><span class="line">2）若errno值为EAGAIN或EWOULDBLOCK，则表示操作条件目前并不具备，而不是遇到了网络错误</span><br><span class="line"></span><br><span class="line">        sockC &#x3D; accept(sock, (struct sockaddr*)&amp;addrC, &amp;sizeAddr);</span><br><span class="line"></span><br><span class="line">        if(-1 &#x3D;&#x3D; sockC)</span><br><span class="line">        &#123;</span><br><span class="line">            if(errno !&#x3D; EAGAIN &amp;&amp; errno !&#x3D; EWOULDBLOCK)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;accept() error : %d -&gt; %s\n&quot;, errno, strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="多线程创建管理"><a href="#多线程创建管理" class="headerlink" title="多线程创建管理"></a>多线程创建管理</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">头文件</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;     编译时加上-pthtread参数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line">pthread_create(&amp;thread,<span class="literal">NULL</span>,doThread,(<span class="keyword">void</span>*)arg);  <span class="comment">/*创建线程,线程id为thread*/</span></span><br><span class="line">pthread_detach(thread);        <span class="comment">/* 分离线程,意思是线程函数执行完毕后系统自动回收线程 */</span></span><br><span class="line">pthread_join(thread,<span class="literal">NULL</span>);          <span class="comment">/* 等待线程函数结束(直到线程函数结束,代码不会向下执行),可以接收线程函数的返回值(线程函数返回值为void* 所以可以返回任何值) */</span></span><br></pre></td></tr></table></figure>


<h3 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h3><p><strong>信号量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">线程的信号量与进程间通信中使用的信号量的概念是一样，它是一种特殊的变量，它可以被增加或减少，但对其的关键访问被保证是原子操作。</span><br><span class="line">如果一个程序中有多个线程试图改变一个信号量的值，系统将保证所有的操作都将依次进行。</span><br><span class="line"></span><br><span class="line">信号量的函数都以sem_开头，线程中使用的基本信号量函数有<span class="number">4</span>个，它们都声明在头文件semaphore.h中。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> sem_init函数 该函数用于创建信号量                                 <span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared， <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="number">2.</span> sem_wait函数 该函数用于以原子操作的方式将信号量的值减<span class="number">1</span>。          <span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="number">3.</span> sem_post函数 该函数用于以原子操作的方式将信号量的值加<span class="number">1</span>。          <span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="number">4.</span> sem_destroy函数 该函数用于对用完的信号量的清理                    <span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line">sem_wait(); 到 sem_post(); 之间的代码是原子操作,不用管信号量的值是几,具体由操作系统管理</span><br></pre></td></tr></table></figure>


<p><strong>互斥量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;                           <span class="comment">/* 创建锁*/</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);                <span class="comment">/* 初始化锁 */</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);                      <span class="comment">/* 上锁 */</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);                    <span class="comment">/* 解锁*/</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);                   <span class="comment">/* 销毁锁 */</span></span><br></pre></td></tr></table></figure>




<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *<span class="keyword">restrict</span> readfds,</span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> errorfds,</span></span></span><br><span class="line"><span class="function"><span class="params">           struct timeval *<span class="keyword">restrict</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  void FD_ZERO(fd_set *set) 将set清空为0</span><br><span class="line">  void FD_SET(int fd,fd_set *set) 将fd设置到set集合中去</span><br><span class="line">  void FD_CLR(int fd,fd_set *set) 将fd从set中清除出去</span><br><span class="line">  int FD_ISSET(int fd,fd_set *set) 判断文件描述符fd是否在set集合中( FD_ISSET() tests to see if a file descriptor is part of the set;)</span><br><span class="line"></span><br><span class="line">  __FD_SETSIZE 系统定义的宏,表示文件描述符最多个数,一般是<span class="number">1024</span>,也可以不加前面两个下划线即FD_SETSIZE</span><br><span class="line"></span><br><span class="line">使用过程:</span><br><span class="line"></span><br><span class="line">fd_set fsRead,fsRead2;           <span class="comment">//集合</span></span><br><span class="line"><span class="keyword">int</span> Maxfd;               <span class="comment">//最大描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tmot</span>;</span>     <span class="comment">//超时时间</span></span><br><span class="line"><span class="keyword">int</span> countFd;             <span class="comment">//select返回值,(满足条件的描述符个数)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FD_ZERO(&amp;fsRead);         <span class="comment">//清空集合</span></span><br><span class="line">FD_SET(listenfd,&amp;fsRead); <span class="comment">//将监听套接字放在集合中</span></span><br><span class="line">Maxfd = listenfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//备份</span></span><br><span class="line">	fsRead2 = fsRead;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置超时时间</span></span><br><span class="line">	tmot.tv_sec = <span class="number">0</span>;      <span class="comment">//秒          </span></span><br><span class="line">	tmot.tv_usec = <span class="number">200000</span>; <span class="comment">//微秒</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//select函数</span></span><br><span class="line">	countFD = select(maxFD + <span class="number">1</span>, &amp;fsRead2, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tmot);   <span class="comment">//返回值:   返回发生事件的套接字的个数</span></span><br><span class="line">	<span class="keyword">if</span>(countFD == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"select() error : %d -&gt; %s\n"</span>, errno, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(countFD == <span class="number">0</span>) &#123; <span class="comment">/* 无就绪描述符,输出超时 */</span></span><br><span class="line">        <span class="comment">//time out</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"select() timeout\n"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; maxFD + <span class="number">1</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(k, &amp;fsRead2))   <span class="comment">/* 判断k是否在集合fsRead2中 */</span></span><br><span class="line">            &#123;</span><br><span class="line">				<span class="keyword">if</span>(k == listenfd)&#123;</span><br><span class="line">					<span class="comment">//发生事件的是监听套接字,说明有连接到来</span></span><br><span class="line">					<span class="keyword">int</span> connfd = accept();</span><br><span class="line">					</span><br><span class="line">					<span class="comment">/* 把创建的连接描述符放在集合里 */</span></span><br><span class="line">                	FD_SET(sockC, &amp;fsRead);</span><br><span class="line">                	<span class="keyword">if</span>(sockC &gt; maxFD)&#123;</span><br><span class="line">                		maxFD = sockC;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="comment">//发生事件的是连接套接字,接收发来的消息,并回复</span></span><br><span class="line">					recv();  </span><br><span class="line">					send();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="winsock编程"><a href="#winsock编程" class="headerlink" title="winsock编程"></a>winsock编程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）准备WinSock环境</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  WSAStartup（WORD wVersionRequested， LPWSADATA  lpWSAData）</span><br><span class="line"></span><br><span class="line">a）参数<span class="number">1</span>：为期待的版本，可以使用MAKEWORD（x，y）来指定版本，其中x为主版本，占据低字节，y为次版本，占据高字节，目前均使用<span class="number">2.0</span>以上版本，常用<span class="number">2.2</span>；</span><br><span class="line"></span><br><span class="line">b）参数<span class="number">2</span>：指向一个WSADATA结构体，用于填充返回相关信息</span><br><span class="line"></span><br><span class="line">c）返回值：操作成功，返回<span class="number">0</span>，否则返回错误代码。注意，在WinSock执行环境未准备好时，不能调用WSAGetLastError（）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）清除WinSock环境</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> WSACleanup（<span class="keyword">void</span>）</span><br><span class="line"></span><br><span class="line">若成功返回<span class="number">0</span>，否则返回SOCKET_ERROR。一般不会出错。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）获取错误</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  WSAGetLastError（<span class="keyword">void</span>）</span><br><span class="line"></span><br><span class="line">返回当前线程上次WinSock操作失败时的具体错误代码。大部分WinSock错误代码以WSAE作为前辍</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）设置I/O模式</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  ioctlsocket（SOCKET  s，<span class="keyword">long</span>  cmd，u_long  FAR  *argp）</span><br><span class="line"></span><br><span class="line">a）s为指定套接字</span><br><span class="line"></span><br><span class="line">b）cmd为要执行的命令</span><br><span class="line"></span><br><span class="line">c）argp指向命令需要的参数</span><br><span class="line"></span><br><span class="line">d）返回值：操作成功返回<span class="number">0</span>，否则返回SOCKET_ERROR</span><br><span class="line"></span><br><span class="line">e）设置为非阻塞模式时，cmd为FIONBIO，argp指向值为非<span class="number">0</span>的整型变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）关闭套接字</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  closesocket（SOCKET  s）</span><br><span class="line"></span><br><span class="line">若操作成功返回<span class="number">0</span>，否则返回SOCKET_ERROR。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"ws2_32"</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">WSADATA</span> <span class="title">wsd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> code = WSAStartup(<span class="number">0x0202</span>,&amp;wsd);    <span class="comment">//0x0202表示版本</span></span><br><span class="line">	<span class="keyword">if</span>(code != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"WSAStartup error: %d"</span>,code);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	其他与Linux一样</span><br><span class="line"></span><br><span class="line">	closesocket(sockfd);</span><br><span class="line">	</span><br><span class="line">	WSACleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">头文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">strstr</span>(str,<span class="string">"hello"</span>);    在字符串str中找到hello字符串返回hello字符串,找不到返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strchr</span>(str,<span class="string">'\n'</span>);       在字符串str中寻找回车符</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcmp</span>(str,<span class="string">"hello"</span>);    如果str字符串与<span class="string">"hello"</span>字符串相等,那么返回<span class="number">0</span>,其他返回值不常用</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(str,<span class="string">"hello"</span>);    在字符串str后面拼接上hello字符</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(str,<span class="string">"hello"</span>);    把字符串hello拷贝给str,str原来的值被覆盖</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">指针,指针也是处理字符串很好用的方式</span><br><span class="line"></span><br><span class="line">例如:分割http请求第一行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /index.html HTTP/<span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">首先提取出http请求的第一行</span><br><span class="line"></span><br><span class="line">假设整个请求存在request数组里</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p = request;</span><br><span class="line"><span class="keyword">char</span> *q = <span class="built_in">strchr</span>(request,<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">指针p和q之间就是这一行数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> method[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">char</span> uri[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">char</span> version[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">Split(&amp;p,q,method);   分离出方法</span><br><span class="line">Split(&amp;p,q,uri);</span><br><span class="line">Split(&amp;p,q,version);</span><br><span class="line"></span><br><span class="line">最终结果: </span><br><span class="line">method 存放  GET</span><br><span class="line">uri 存放/index.html</span><br><span class="line">version存放HTTP/<span class="number">1.1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">char</span> **p,<span class="keyword">char</span> *q,<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>((*p) != q) &#123;</span><br><span class="line">        <span class="keyword">if</span>( (**p) == <span class="string">' '</span> ) &#123;</span><br><span class="line">            (*p)++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *(s++) = *((*p)++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><p>listen backlog作用</p>
<p>recv 返回值</p>
<p><strong>epoll使用过程</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include <span class="tag">&lt;<span class="name">sys</span>/<span class="attr">epoll.h</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2）创建epoll实例</span><br><span class="line"></span><br><span class="line">int epoll_create（int size）</span><br><span class="line"></span><br><span class="line">epoll模型由内核管理，需要向内核申请创建实例。参数size为实例大小，可以理解为所管理描述符的数量。在Linux 2.6.8以后，size会由系统自动调整，该参数仅仅为保持兼容而存在。</span><br><span class="line"></span><br><span class="line">若操作成功，会返回引用该实例的描述符，否则返回-1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3）注册描述符及事件</span><br><span class="line"></span><br><span class="line">int epoll_ctl（int epfd, int op, int fd, struct epoll_event *event）</span><br><span class="line"></span><br><span class="line">epoll模型将管理若干描</span><br><span class="line">述符及关心的事件（与select作用类似），这些管理功能均通过该函数表示。操作成功，返回0，否则返回-1。各参数含义：</span><br><span class="line"></span><br><span class="line">a）epfd为epoll实例描述符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b）fd为要管理的描述符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c）event为该描述符上关心的事件，类型为结构体类型：</span><br><span class="line"></span><br><span class="line">struct epoll_event&#123;</span><br><span class="line"></span><br><span class="line">　　__uint32_t     events;  </span><br><span class="line"></span><br><span class="line">　　epoll_data_t  data;</span><br><span class="line"></span><br><span class="line">｝；</span><br><span class="line"></span><br><span class="line">events是由以下事件标志通过 | 运算得到的组合</span><br><span class="line"></span><br><span class="line">EPOLLIN：可读数据（有数据到达）</span><br><span class="line"></span><br><span class="line">EPOLLOUT：可写数据（可发送给对方）</span><br><span class="line"></span><br><span class="line">EPOLLPRI：对于流式套接字，收到了OOB数据</span><br><span class="line"></span><br><span class="line">EPOLLRDHUP：对方调用了close()或shutdown()，在ET模式下很有用</span><br><span class="line"></span><br><span class="line">EPOLLERR：发生错误的情况</span><br><span class="line"></span><br><span class="line">EPOLLET：启用ET（Edge Triggered，边缘触发，状态发生变化）模式，默认模式为LT（Level Triggered，条件或水平触发，状态不变，但总满足“操作就绪”的要求）</span><br><span class="line"></span><br><span class="line">EPOLLONESHOT：只使用一次，单独使用无意义</span><br><span class="line"></span><br><span class="line">除上述标志以外，Linux的不同版本还增加了其它事件标志。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data成员表示事件对应的数据，其定义为：</span><br><span class="line"></span><br><span class="line">typedef union epoll_data&#123;</span><br><span class="line"></span><br><span class="line">　　void           *ptr;</span><br><span class="line"></span><br><span class="line">　　int              fd;</span><br><span class="line"></span><br><span class="line">　　__uint32_t  u32;</span><br><span class="line"></span><br><span class="line">　　__uint64_t  u64;</span><br><span class="line"></span><br><span class="line">｝epoll_data_t；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d）op表示要执行的管理操作，有三个：EPOLL_CTL_XXX，其中XXX是ADD、DEL、MOD三者之一，分别表示新注册、删除已有、修改已有</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4）进行监控</span><br><span class="line"></span><br><span class="line">int epoll_wait（int epfd, struct epoll_event *events, int maxevents, int timeout）</span><br><span class="line"></span><br><span class="line">执行完成后，若有描述符上期待的事件发生，返回描述数个数；若超时，返回0；若出错，返回-1。参数含义为：</span><br><span class="line"></span><br><span class="line">a）epfd，epoll实例的描述符</span><br><span class="line"></span><br><span class="line">b）events，用户动态申请的内存空间，用于存放产生事件的描述符等信息，若有n个描述符上产生了期待的事件，这n个描述符的相关信息存放在events的前n个元素中</span><br><span class="line"></span><br><span class="line">c）maxevents，events空间大小</span><br><span class="line"></span><br><span class="line">d）timeout，该参数与select模型中的不同，它以毫秒为单位设置时间间隔。若为0，调用会立即返回；若为-1，则无限期等待，直至出错或有描述符发生事件；若为其它值，则会等待指定的时间间隔，在此时间内，若有事件发生，会返回，否则会等到超时再返回。该参数设置会影响性能</span><br></pre></td></tr></table></figure>


<hr>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">一、数据报套接字的两种通信模式</span><br><span class="line"></span><br><span class="line">1、客户机/服务器模式</span><br><span class="line"></span><br><span class="line">也可称为主从模式，服务器不主动向客户机发送数据，而是处于等待状态，客户机主动发起数据通信的过程，类似于流式套接字的工作模式。</span><br><span class="line"></span><br><span class="line">在该模式中，服务器需要绑定操作，客户机不需要。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、对等模式</span><br><span class="line"></span><br><span class="line">既向不特定主机发送信息，也接收不特定主机发送来的信息。</span><br><span class="line"></span><br><span class="line">在该模式中，参与通信方均需要绑定操作。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2、epoll模型</span><br><span class="line"></span><br><span class="line">1）epoll是Linux上的高性能I/O模型。Kqueue是FreeBSD系统中的模型，Windows是IOCP模型。</span><br><span class="line"></span><br><span class="line">2）下图中体现select与epoll模型性能的差异，很明显，当连接数量较大时，select模型的性能明显下降，epoll模型的性能比较稳定，不会随着管理描述数量的增加出现明显性能下降的情况。</span><br><span class="line"></span><br><span class="line">3）epoll适用于连接数量较多，但活动连接数量相对较少的情况。</span><br></pre></td></tr></table></figure>


<hr>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1、WSAAsyncSelect概述</span><br><span class="line"></span><br><span class="line">1）当协议栈检测到某个套接字上有数据到达（事件）时，便会向该套接字所属应用发送通知消息，应用收到消息后再进行处理。这种方式使用起来非常自然，也符合Windows系统的特性，即事件（套接字状态变化） -&gt; 消息传递（向应用发送消息） -&gt; 响应（应用程序处理）。</span><br><span class="line"></span><br><span class="line">2）WSAAsyncSelect是另一种I/O复用模型，非常适合GUI界面的应用。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">3、select模型</span><br><span class="line"></span><br><span class="line">1）该关注的套接字（描述符）存储在fd_set集合中，select模型会监控一段时间内集合中所有有效的套接字是否“操作就绪”，若是会保留下来，否则会将该套接字移出集合，对于仍然存在于集合中的套接字，可以直接进行相应的操作，而不必再花时间等待。</span><br><span class="line"></span><br><span class="line">2）对套接字的关注只有三种类型：数据是否可读？数据是否可写？是否发生错误？为方便，模型按感兴趣的类型将套接字集合分为三种，某个套接字可以只加入一个集合，也可以同时加入多个集合。</span><br></pre></td></tr></table></figure>


<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TIME_WAIT出现的原因</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>network</title>
    <url>/2020/03/22/network/</url>
    <content><![CDATA[<h1 id="作业"><a href="#作业" class="headerlink" title="作业:"></a>作业:</h1><h4 id="1、查看listen的man-page信息，了解backlog的作用，下次找同学回答。"><a href="#1、查看listen的man-page信息，了解backlog的作用，下次找同学回答。" class="headerlink" title="1、查看listen的man page信息，了解backlog的作用，下次找同学回答。"></a>1、查看listen的man page信息，了解backlog的作用，下次找同学回答。</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">backlog::允许同时与服务器连接的客户端数量</span><br><span class="line">    </span><br><span class="line">查看系统默认backlog:</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_max_syn_backlog</span><br><span class="line">    </span><br><span class="line">监听端口后,被动套接字等待连接(listen函数把套接字变成被动套接字,accept函数阻塞等待连接),</span><br><span class="line">此时系统中维护着两个队列,第一个队列存放的是已建立连接的套接字(即完成三次握手后的established),</span><br><span class="line">第二个队列是未建立连接的套接字(处于三次握手中的syn_rcvd),</span><br><span class="line">每次accept会将第一个队列中的套接字返回,进行通信,以完成网络传输</span><br><span class="line"></span><br><span class="line">linux2.2以前,backlog表示两个队列总和的长度</span><br><span class="line">linux2.2以后,backlog表示已完成连接的队列的长度</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="2、查看recv的man-page信息，了解recv返回值的信息，下次解答"><a href="#2、查看recv的man-page信息，了解recv返回值的信息，下次解答" class="headerlink" title="2、查看recv的man page信息，了解recv返回值的信息，下次解答"></a>2、查看recv的man page信息，了解recv返回值的信息，下次解答</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">recv函数原型为:</span><br><span class="line">	<span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line">参数:</span><br><span class="line">第一个参数：接收端的套接字描述符</span><br><span class="line">第二个参数：接受数据的缓冲区</span><br><span class="line">第三个参数：缓冲区的尺寸，<span class="keyword">sizeof</span>（）</span><br><span class="line">第四个参数：置<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>原理:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，</span><br><span class="line">如果协议在传送s的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR；</span><br><span class="line">如果s的发送缓冲中没有数据或者数据被协议成功发送完毕后，recv先检查套接字s的接收缓冲区，</span><br><span class="line">如果s接收缓冲区中没有数据或者协议正在接收数据，那么recv就一直等待，直到协议把数据接收完毕；</span><br><span class="line"></span><br><span class="line">当协议把数据接收完毕，recv函数就把s的接收缓冲中的数据copy到buf中注意协议接收到的数据可能大于buf的</span><br><span class="line">长度，所以在这种情况下要调用几次recv函数才能把s的接收缓冲中的数据copy完。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">recv函数仅仅是copy数据，真正的接收数据是协议来完成的，recv函数返回其实际copy的字节数；</span><br><span class="line">如果recv在copy时出错，那么它返回SOCKET_ERROR；</span><br><span class="line">如果recv函数在等待协议接收数据时网络中断了，那么它返回0。</span><br></pre></td></tr></table></figure>

<p>返回值:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">如果recv函数成功，返回值大于0，返回的是其实际copy的字节数；</span><br><span class="line">如果recv在copy时出错，那么它返回SOCKET_ERROR；</span><br><span class="line">如果recv函数在等待协议接收数据时网络中断了，那么它返回0。</span><br><span class="line"></span><br><span class="line">EAGAIN：套接字已标记为非阻塞，而接收操作被阻塞或者接收超时</span><br><span class="line">EBADF：sock不是有效的描述词</span><br><span class="line">ECONNREFUSE：远程主机阻绝网络连接</span><br><span class="line">EFAULT：内存空间访问出错</span><br><span class="line">EINTR：操作被信号中断</span><br><span class="line">EINVAL：参数无效</span><br><span class="line">ENOMEM：内存不足</span><br><span class="line">ENOTCONN：与面向连接关联的套接字尚未被连接上</span><br><span class="line">ENOTSOCK：sock索引的不是套接字</span><br></pre></td></tr></table></figure>


<p><strong>send函数:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">原型:</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回值:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1. s 指定发送端套接字描述符。</span><br><span class="line">2. buff 表示存放发送数据的缓冲区。 </span><br><span class="line">3. 实际要发送的字节数，</span><br></pre></td></tr></table></figure>

<p>原理:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">当调用该函数时，send先比较待发送数据的长度len和套接字s的发送缓冲区的长度，</span><br><span class="line">如果len大于s的发送缓冲区的长度，该函数返回SOCKET_ERROR； </span><br><span class="line">如果len小于或者等于s的发送缓冲区的长度，那么send先检查协议是否正在发送s的发送缓冲中的数据； </span><br><span class="line">如果是就等待协议把数据发送完，</span><br><span class="line">如果协议还没有开始发送s的发送缓冲中的数据或者s的发送缓冲中没有数据，那么send就比较s的发送缓冲区的剩余空间和len； </span><br><span class="line">如果len大于剩余空间大小，send就一直等待协议把s的发送缓冲中的数据发送完，</span><br><span class="line">如果len小于剩余空间大小，send就仅仅把buf中的数据copy到剩余空间里（注意并不是send把s的发送缓冲中的数据传到连接的另一端的，而是协议传的，send仅仅是把buf中的数据copy到s的发送缓冲区的剩余空间里）。 </span><br><span class="line">如果send函数copy数据成功，就返回实际copy的字节数，</span><br><span class="line">如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR； </span><br><span class="line">如果send在等待协议传送数据时网络断开的话，那么send函数也返回SOCKET_ERROR。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">要注意send函数把buf中的数据成功copy到s的发送缓冲的剩余空间里后它就返回了，</span><br><span class="line">但是此时这些数据并不一定马上被传到连接的另一端。 如果协议在后续的传送过程中出现网络错误的话，</span><br><span class="line">那么下一个Socket函数就会返回SOCKET_ERROR。</span><br><span class="line">（每一个除send外的Socket函数在执行的最开始总要先等待套接字的发送缓冲中的数据被协议传送完毕才能继续，</span><br><span class="line">如果在等待时出现网络错误，那么该Socket函数就返回SOCKET_ERROR</span><br></pre></td></tr></table></figure>


<p>####　3、为客户端加上退出机制</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(bufOut,<span class="string">"bye"</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"you input bye"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="4、为服务端加上特殊的“停止服务”功能。-确定对方是管理员才退出-否则不退出"><a href="#4、为服务端加上特殊的“停止服务”功能。-确定对方是管理员才退出-否则不退出" class="headerlink" title="4、为服务端加上特殊的“停止服务”功能。(确定对方是管理员才退出,否则不退出)"></a>4、为服务端加上特殊的“停止服务”功能。(确定对方是管理员才退出,否则不退出)</h4><h1 id="本节课内容"><a href="#本节课内容" class="headerlink" title="本节课内容:"></a>本节课内容:</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">udp: recvfrom不一定接收到对端发来的信息,因为udp不检查对端是否收到,tcp检查吗</span><br><span class="line"></span><br><span class="line">浏览器访问www.qq.com:7777是访问不了的,因为服务器上没有应用程序运行在7777端口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">服务端:</span><br><span class="line"></span><br><span class="line">1、创建流式套接字，目的是监听连接请求</span><br><span class="line"></span><br><span class="line">2、绑定对外公布的地址信息</span><br><span class="line"></span><br><span class="line">3、确定连接请求队列大小，进入监听套接字监听状态</span><br><span class="line"></span><br><span class="line">4、当有客户端的连接请求到来时，创建一个为该客户端提供1对1服务的流式套接字，它只起数据传输作用，称为响应套接字</span><br><span class="line"></span><br><span class="line">5、响应套接字与客户端套接字成为通信双方，这个通信是有连接的，在此基础上，可以按照通信规程（业务逻辑）传输数据</span><br><span class="line"></span><br><span class="line">5.1、发送数据：将数据从应用程序缓冲区复制到套接字的发送缓冲区，至于何时真正发送到对方，由协议栈决定</span><br><span class="line"></span><br><span class="line">5.2、接收数据：将数据从套接字的接收缓冲区移动到应用程序的缓冲区，</span><br><span class="line"></span><br><span class="line">6、数据传输完成后，可关闭响应套接字</span><br><span class="line"></span><br><span class="line">7、一般情况下，不关闭监听套接字，除非有特殊要求</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">客户端:</span><br><span class="line"></span><br><span class="line">1、创建流式套接字</span><br><span class="line"></span><br><span class="line">2、根据服务端公布的地址信息，连接到服务端</span><br><span class="line"></span><br><span class="line">3、连接成功后，可以按照通信规程（业务逻辑）传输数据</span><br><span class="line"></span><br><span class="line">3.1、发送数据：将数据从应用程序缓冲区复制到套接字的发送缓冲区，至于何时真正发送到对方，由协议栈决定</span><br><span class="line"></span><br><span class="line">3.2、接收数据：将数据从套接字的接收缓冲区移动到应用程序的缓冲区，</span><br><span class="line"></span><br><span class="line">4、数据传输完成后，可关闭套接字</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
