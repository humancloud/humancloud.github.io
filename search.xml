<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>这是一篇示例文章</title>
    <url>/2020/04/05/example/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p><a href="www.github.com">Hexo博客美化配置</a>,这篇文章讲解了,Hexo博客的美化与配置</p>
</blockquote>
<a id="more"></a>



<h2 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h2><p>内容1</p>
<h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><p>内容2</p>
<p>如果您喜欢我的文章,欢迎关注下面的我滴公众号</p>
]]></content>
  </entry>
  <entry>
    <title>C语言宏实现max</title>
    <url>/2020/10/04/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E5%AE%9E%E7%8E%B0max/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C语言宏功能强大,但一不小心就会用错,许多经典书籍都曾讲过C语言宏的强大功能,此篇文章是参考C陷阱与缺陷书籍和网上其他文章总结的</p>
<a id="more"></a>





<p>根据书籍写此篇文章</p>
<h2 id="编程常用宏-常更新"><a href="#编程常用宏-常更新" class="headerlink" title="编程常用宏(常更新)"></a>编程常用宏(常更新)</h2><p><strong>max函数宏</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">错误版</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b))?(a):(b)</span></span><br><span class="line"></span><br><span class="line">a或b会被计算两次,如果每次计算a或b都改变,那么最后得到的结果与预想中的会不同</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Linux Kernel 版</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(x,y) (&#123;                \</span></span><br><span class="line">		typeof(x) _max1 = (x);     \</span><br><span class="line">		typeof(y) _max2 = (y);     \</span><br><span class="line">		(<span class="keyword">void</span>)(&amp;_max1 == &amp;_max2);  \</span><br><span class="line">		_max1 &gt; _max2 ? _max1:_max2;&#125;)</span><br><span class="line"></span><br><span class="line">x或y只会被计算一次</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>mianshi</title>
    <url>/2020/10/20/mianshi/</url>
    <content><![CDATA[<h1 id="1-网络编程系统编程部分"><a href="#1-网络编程系统编程部分" class="headerlink" title="1. 网络编程系统编程部分"></a>1. 网络编程系统编程部分</h1><p><strong>常见面试题目</strong></p>
<p><strong>1. TCP和UDP的区别</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</span><br><span class="line">(2) TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</span><br><span class="line">(3) TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的</span><br><span class="line">UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</span><br><span class="line">(4) 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</span><br><span class="line">(5) TCP首部开销20字节;UDP的首部开销小，只有8个字节</span><br><span class="line">(6) TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。</span><br></pre></td></tr></table></figure>

<a id="more"></a>


<p><strong>流量控制与拥塞控制</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拥塞控制</span><br><span class="line">网络拥塞现象是指到达通信子网中某一部分的分组数量过多,使得该部分网络来不及处理,以致引起这部分乃至整个网络性能下降的现象,严重时甚至会导致网络通信业务陷入停顿,即出现死锁现象。拥塞控制是处理网络拥塞现象的一种机制。</span><br><span class="line">流量控制</span><br><span class="line">数据的传送与接收过程当中很可能出现收方来不及接收的情况,这时就需要对发方进行控制,以免数据丢失。</span><br></pre></td></tr></table></figure>



<p><strong>多线程如何同步</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windows</span><br><span class="line"></span><br><span class="line">线程同步有四种方式：临界区、内核对象、互斥量、信号量。</span><br><span class="line"></span><br><span class="line">Linux</span><br><span class="line"></span><br><span class="line">线程同步有最常用的是：互斥锁、条件变量和信号量。</span><br></pre></td></tr></table></figure>



<p><strong>进程间通信有哪些方式,各有什么优缺点</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Linux 进程间通信（IPC）以下以几部分发展而来：</span><br><span class="line">早期UNIX进程间通信、基于System V进程间通信、基于Socket进程间通信和POSIX进程间通信。</span><br><span class="line">UNIX进程间通信方式包括：管道、FIFO、信号。</span><br><span class="line">System V进程间通信方式包括：System V消息队列、System V信号灯、System V共享内存、</span><br><span class="line">POSIX进程间通信包括：posix消息队列、posix信号灯、posix共享内存。</span><br><span class="line">现在linux使用的进程间通信方式：</span><br><span class="line">（1）管道（pipe）和有名管道（FIFO）</span><br><span class="line">（2）信号（signal）</span><br><span class="line">（3）消息队列</span><br><span class="line">（4）共享内存</span><br><span class="line">（5）信号量</span><br><span class="line">（6）套接字（socket)</span><br></pre></td></tr></table></figure>



<p><strong>tcp连接建立的时候3次握手，断开连接的4次握手的具体过程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">建立连接采用的3次握手协议，具体是指：</span><br><span class="line">第一次握手是客户端connect连接到server，server accept client的请求之后，向client端发送一个消息，相当于说我都准备好了，你连接上我了，这是第二次握手，第3次握手就是client向server发送的，就是对第二次握手消息的确认。之后client和server就开始通讯了。</span><br><span class="line"></span><br><span class="line">断开连接的4次握手,具体如下：</span><br><span class="line">断开连接的一端发送close请求是第一次握手，另外一端接收到断开连接的请求之后需要对close进行确认，发送一个消息，这是第二次握手，发送了确认消息之后还要向对端发送close消息，要关闭对对端的连接，这是第3次握手，而在最初发送断开连接的一端接收到消息之后，进入到一个很重要的状态time_wait状态，这个状态也是面试官经常问道的问题，最后一次握手是最初发送断开连接的一端接收到消息之后。对消息的确认。</span><br></pre></td></tr></table></figure>



<p><strong>epoll和select的区别</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) select缺点:</span><br><span class="line">1.最大并发数限制：使用32个整数的32位，即32*32&#x3D;1024来标识fd，虽然可修改，但是有以下第二点的瓶颈；</span><br><span class="line">2.效率低：每次都会线性扫描整个fd_set，集合越大速度越慢；</span><br><span class="line">3.内核&#x2F;用户空间内存拷贝问题。</span><br><span class="line"></span><br><span class="line">(2) epoll的提升：</span><br><span class="line">1.本身没有最大并发连接的限制，仅受系统中进程能打开的最大文件数目限制；</span><br><span class="line">2.效率提升：只有活跃的socket才会主动的去调用callback函数；</span><br><span class="line">3.省去不必要的内存拷贝：epoll通过内核与用户空间mmap同一块内存实现。            (不知道有没有共享内存..................)</span><br></pre></td></tr></table></figure>









<h1 id="2-Linux部分"><a href="#2-Linux部分" class="headerlink" title="2. Linux部分"></a>2. Linux部分</h1><p><strong>基础指令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 进入目录，切换目录</span><br><span class="line">pwd 查看当前路径</span><br><span class="line">ls -l , </span><br><span class="line">ls -a 列出所有文件（包括隐藏文件）</span><br><span class="line">mkdir 创建目录</span><br><span class="line">rmdir 删除空目录</span><br><span class="line">.当前目录，..上层目录，~ 主目录</span><br><span class="line"></span><br><span class="line">cat -b 显示行号</span><br><span class="line">vi touch 创建文件 (会修改文件的时间)</span><br></pre></td></tr></table></figure>

<p><strong>硬盘使用命令</strong></p>
<p>df </p>
<p><strong>CPU使用指令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo 查看cpu基本硬件信息</span><br><span class="line">top 或 datat -c   查看cpu使用状态信息(yum install dstat)</span><br></pre></td></tr></table></figure>



<p><strong>内存使用指令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/meminfo  查看内存基本容量</span><br><span class="line">free -k(以kb为单位显示), free -m(以mb为单位显示)           查看内存运行空间信息</span><br></pre></td></tr></table></figure>



<p><strong>查看系统版本</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -a</span><br><span class="line">cat /etc/redhat-release  (centos版本)</span><br></pre></td></tr></table></figure>



<p><strong>查看网络/进程信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查看网络连接: </span><br><span class="line">netstat -anp  (-a 显示所有选项  -t 仅显示tcp相关选项, -u 仅显示udp相关选项, -n 尽量显示出数字 -p 显示相关链接的程序名)</span><br><span class="line">可以显示出:   Proto 协议类型, LocalAddress本地地址,ForeignAddress对端地址,State表示状态对tcp有效,pid表示对应的进程id</span><br><span class="line">查看8080端口被哪个进程占用  netstat -apn | grep 8080</span><br><span class="line">查看进程名为Python的进程有哪些连接 netstat -apn | grep python</span><br><span class="line"></span><br><span class="line">查看进程信息:</span><br><span class="line">top</span><br><span class="line">执行top命令,使用快捷键M即可以查看内存占用最多的N个进程</span><br><span class="line">            使用快捷键P即可以查看CPU占用最多的前N个进程</span><br><span class="line">top -p pid  使用H键可以查看线程相关的信息</span><br><span class="line"></span><br><span class="line">查看ip地址, ifconfig可能会出现多个ip地址,因为一台主机可能具备多个网络接口,多个网络接口对应多个网卡或虚拟网卡设备</span><br></pre></td></tr></table></figure>



<p><strong>修改文件权限</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 777 file   以八进制数字形式指定文件权限</span><br><span class="line">chmod &lt;访问者&gt;[+ - =]&lt;访问权限&gt; 向指定用户添加,删除,设置指定权限    (没懂)</span><br><span class="line">chmod +t directory/ 设置目录的沾滞位,防止其他用户在该目录下删除文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chown</span><br><span class="line"></span><br><span class="line">chown user file  将文件所有者改为指定用户</span><br><span class="line">chmod -R user directory 将目录下所有文件所有者权限都设置为指定用户</span><br><span class="line"></span><br><span class="line">chgrp group file 将文件所属组改为指定用户组</span><br></pre></td></tr></table></figure>



<p><strong>查看文件权限</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查看文件访问的权限:   ls -l  (每个文件或目录都有三个权限 r,w,x)   文件所有者  文件所属者  其他用户</span><br><span class="line"></span><br><span class="line">					  umask   查看默认的权限掩码(掩码取反就是文件权限)信息,最后显示出来的是八进制数字的形式,如 0222</span><br></pre></td></tr></table></figure>



<p><strong>root指令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su root    切换root用户</span><br><span class="line">sudo 普通用户执行root指令,         只有被root用户添加到/etc/sudoers 文件中的用户才可以使用sudo指令</span><br></pre></td></tr></table></figure>



<p><strong>grep指令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>find指令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find pathname -name filename  在pathname目录下寻找文件名为filename的文件</span><br><span class="line">find pathname -size filesize  寻找文件大小为filesize的文件</span><br><span class="line">find pathname -size +/- filesize  寻找文件大小大于/小于filesize的文件</span><br></pre></td></tr></table></figure>



<p><strong>uniq命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">用于检查和删除文本中重复出现的行列</span><br><span class="line"></span><br><span class="line">uniq filename 去除文件当中重复的行,输出到标准输出</span><br><span class="line">uniq file file1 去除文件当中重复的行,输出到file1</span><br><span class="line">uniq -c file  每列旁边显示该行重复的次数</span><br><span class="line">uniq -u file   显示只出现一次的行</span><br></pre></td></tr></table></figure>



<p><strong>Linux目录结构</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin  二进制可执行文件,常用命令</span><br><span class="line">/etc  系统管理和配置文件</span><br><span class="line">/usr  很多应用程序的安装目录</span><br><span class="line">/home 所有用户的家目录</span><br><span class="line">/root 超级用户的家目录</span><br><span class="line">/var  保存各种服务的日志文件</span><br></pre></td></tr></table></figure>





<p><strong>压缩</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">打包并压缩</span><br><span class="line"> tar -cvf ./abc.tar ./abc    只打包不压缩</span><br><span class="line"> tar -zcvf ./abc.tar.gz ./abc  打包并使用gzip压缩</span><br><span class="line"> tar -jcvf ./abc.tar.bz2 ./abc  打包并使用bzip2压缩</span><br><span class="line"> </span><br><span class="line"> 解压只需替换c为x即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">不打包直接压缩</span><br><span class="line"></span><br><span class="line">gzip -v file 压缩文件</span><br><span class="line">gzip -d file.gz 解压缩</span><br></pre></td></tr></table></figure>



<p><strong>IPC相关</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipcs 显示进程间通信设施状态的工具</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  code git:(master) ipcs    </span><br><span class="line"></span><br><span class="line">--------- 消息队列 -----------</span><br><span class="line">键        msqid      拥有者  权限     已用字节数 消息      </span><br><span class="line"></span><br><span class="line">------------ 共享内存段 --------------</span><br><span class="line">键        shmid      拥有者  权限     字节     连接数  状态      </span><br><span class="line">0x00000000 688136     lu         700        8294400    2          目标       </span><br><span class="line">0x00000000 688141     lu         700        91656      2          目标       </span><br><span class="line">0x00000000 753682     lu         600        524288     2          目标       </span><br><span class="line">0x51310018 22         lu         600        33024      1                       </span><br><span class="line">0x5131001a 23         lu         600        16         1                       </span><br><span class="line">0x00000000 688153     lu         700        1600       2          目标       </span><br><span class="line">0x00000000 27         lu         600        524288     2          目标       </span><br><span class="line">0x00000000 688159     lu         700        2537600    2          目标       </span><br><span class="line">0x00000000 32         lu         600        524288     2          目标       </span><br><span class="line">0x5131002f 37         lu         600        16         1                       </span><br><span class="line">0x00000000 229416     lu         600        524288     2          目标       </span><br><span class="line">0x00000000 622634     lu         600        8015104    2          目标       </span><br><span class="line">0x00000000 65584      lu         700        30000      2          目标       </span><br><span class="line">0x00000000 557110     lu         700        307400     2          目标       </span><br><span class="line">0x5131004c 163900     lu         600        1024       1                       </span><br><span class="line">0x00000000 622654     lu         700        289380     2          目标       </span><br><span class="line"></span><br><span class="line">--------- 信号量数组 -----------</span><br><span class="line">键        semid      拥有者  权限     nsems     </span><br><span class="line">0x51310017 1          lu         600        1         </span><br><span class="line">0x51310019 3          lu         600        1         </span><br><span class="line">0x5131002e 5          lu         600        1         </span><br><span class="line">0x5131004b 9          lu         600        1</span><br></pre></td></tr></table></figure>



<p><strong>其他</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown -h now</span><br><span class="line">reboot</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;(追加)    &gt;(覆盖)    重定向</span></span><br></pre></td></tr></table></figure>



<p><strong>vim</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:tabe a.txt    打开或创建新文件,使用gt切换文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" %在括号匹配之间跳转</span><br><span class="line">"</span><br><span class="line">"</span><br><span class="line">" =============================================================================</span><br><span class="line">"                       Nomal模式</span><br><span class="line">" =============================================================================</span><br><span class="line">" ctrl v 块选择,可以用来给代码多行注释</span><br><span class="line">" gd 跳转到局部定义 不用ctags" gf 跳转到文件</span><br><span class="line">" ctrl o 跳转到上一个跳转位置   这个很重要,  不管怎么跳转,都可以ctrl o 跳转回来</span><br><span class="line">" ctrl i 到下一个跳转位置</span><br><span class="line">" ctrl b 查看上一页内容  常用</span><br><span class="line">" ctrl f 查看下一页内容  常用</span><br><span class="line">" K 跳转到manul</span><br><span class="line">" </span><br><span class="line">" &lt;&lt; 左缩进</span><br><span class="line">" &gt;&gt; 右缩进</span><br><span class="line">" == 自动缩进 原来还可以这样"</span><br><span class="line">" 0到行首</span><br><span class="line">" ^ 跳转到行首第一个非空字符" $到行尾" % 匹配括号移动</span><br><span class="line">" gg到第一行行首</span><br><span class="line">" G 到最后一行的行尾</span><br><span class="line">" 100G 跳转到100行行首 , 比命令模式输入:行号方便" </span><br><span class="line">" </span><br><span class="line">" y$复制到行尾</span><br><span class="line">" yw 复制一个单词" yy 复制一整行</span><br><span class="line">" 10yy 复制光标下10行" yG 复制到文本结束</span><br><span class="line">" yH 从文本开始复制到光标处</span><br><span class="line">"</span><br><span class="line">"</span><br><span class="line">" x 删掉光标处字符" 3x剪切三个</span><br><span class="line">" p 光标之后粘贴</span><br><span class="line">" P光标之前粘贴" 3p粘贴三次" </span><br><span class="line">"</span><br><span class="line">" fa移动光标到本行下第一个字符a处, 2fa移动到第二个a处</span><br><span class="line">" Fa移动到上一个字符a" nfa 移动到第n个字符处" nFa</span><br><span class="line">"</span><br><span class="line">" yfa 复制光标字符到字符a之间的内容</span><br><span class="line">" y2fa 复制光标字符到第2个a之间的内容</span><br><span class="line">"</span><br><span class="line">" </span><br><span class="line">" dw </span><br><span class="line">" d2w 删除两个单词" df" 删除到出现第一个双引号的位置" d2f" 删除到出现第2个双引号的位置" d$ 删除到本行结尾</span><br><span class="line">" d^  删除到本行开头</span><br><span class="line">" dH 同yH" dG 同yG </span><br><span class="line">" dtg 删除到g字符的位置不删除g字符 (例如abcdegfhijk) 按键dtg从光标删除到g字符," 其实就是delete to g 的缩写很好用啊</span><br><span class="line">"</span><br><span class="line">" 重要的:" f&#123; 移动到大括号处,然后d%删除整个大括号的内容(包括大括号), 或者di&#123;" 删除大括号里面的内容,不删除大括号"</span><br><span class="line">" </span><br><span class="line">"</span><br><span class="line">" u 撤销操作</span><br><span class="line">" ctrl r 恢复撤销操作"</span><br><span class="line">"</span><br><span class="line">"</span><br><span class="line">" ~ 将光标处的字符改变大小写" 3~ 将光标位置开始的3个字符改变其大小写</span><br><span class="line">" g~~ 改变当前行字符大小写</span><br><span class="line">" gUU 当前行字符改成大写</span><br><span class="line">" guu 当前行改成小写</span><br><span class="line">" gUw 光标处的单词改成大写</span><br><span class="line">" guw 光标处的单词改成小写</span><br><span class="line">"</span><br><span class="line">"</span><br><span class="line">" 替换:"  r 替换光标处字符"  S替换行(删除当前行,并进入插入模式)"  cc 同 S</span><br><span class="line">"  ciw改写光标所处的单词</span><br><span class="line">"  caw改写光标所处的单词(如果两侧有空格删除空格)"  c0                  从光标改写到行首</span><br><span class="line">"  c^                  从光标改写到行首（第一个非零字符）</span><br><span class="line">"  c$                  从光标改写到行末</span><br><span class="line">"  C                   从光标改写到行尾（同c$）</span><br><span class="line">"  ci"                 改写双引号中的内容</span><br><span class="line">"  ci'                 改写单引号中的内容</span><br><span class="line">"  cib                 改写小括号中的内容</span><br><span class="line">"  cab                 改写小括号中的内容（包含小括号本身）</span><br><span class="line">"  ci)                 改写小括号中的内容</span><br><span class="line">"  ci]                 改写中括号中内容</span><br><span class="line">"  ciB                 改写大括号中内容</span><br><span class="line">"  caB                 改写大括号中的内容（包含大括号本身）</span><br><span class="line">"  ci&#125;                 改写大括号中内容</span><br><span class="line">"  c2w                 改写下两个单词</span><br><span class="line">"  ct(                 改写到小括号前</span><br><span class="line">"  c/apple             改写到光标后的第一个apple前"</span><br><span class="line">"</span><br><span class="line">"</span><br><span class="line">"</span><br><span class="line">"</span><br><span class="line">" =============================================================================</span><br><span class="line">" 底行命令模式</span><br><span class="line">" =============================================================================</span><br><span class="line">" :%!xxd 16进制</span><br><span class="line">" :s/$/sth 行尾追加sth</span><br><span class="line">" :g/^/s*$/d 删除空行以及只有空格的行</span><br><span class="line">"</span><br><span class="line">" 替换</span><br><span class="line">" :s/from/to    当前行第一个from替换成to</span><br><span class="line">" :s/from/to/g  当前行所有from替换成to</span><br><span class="line">" :33s/from/to/g 在第33行进行替换操作 </span><br><span class="line">" :%s/from/to/g  对所有行内容进行替换</span><br><span class="line">"</span><br><span class="line">"</span><br><span class="line">" =============================================================================</span><br><span class="line">" Insert模式</span><br><span class="line">" =============================================================================</span><br><span class="line">" I 进入编辑,并将光标置于行首</span><br><span class="line">" A 置光标与行尾并进入插入模式(在行尾插入)</span><br><span class="line">" O 当前行上面新加一行,进入插入模式</span><br><span class="line">"</span><br><span class="line">" insert 模式  ctrl [ 相当于esc 但比esc更顺手</span><br><span class="line">" ctrl d crtl t 左右缩进</span><br><span class="line">" ctrl u 重新编辑本行" ctrl w 删除单词</span><br><span class="line">" </span><br><span class="line">"</span><br><span class="line">" 插入模式快捷键" CTRL-M 或 CTRL-J                                开始新行</span><br><span class="line">" CTRL-E                  插入光标下方的字符</span><br><span class="line">" CTRL-Y                  插入光标上方的字符</span><br><span class="line">" CTRL-A                  插入上次插入的文本</span><br><span class="line">" CTRL-@                  插入上次插入的文本并结束插入模式</span><br><span class="line">" CTRL-R &#123;0-9a-z%#:.-="&#125;        插入寄存器的内容</span><br><span class="line">" CTRL-W                  删除光标前的一个单词</span><br><span class="line">" CTRL-U                  删除当前行的所有字符</span><br><span class="line">" CTRL-T                  在当前行首插入一个移位宽度的缩进</span><br><span class="line">" CTRL-D                  从当前行首删除一个移位宽度的缩进</span><br><span class="line">" 0 CTRL-D        删除当前行的所有缩进</span><br><span class="line">" ^ CTRL-D        删除当前行的所有缩进，恢复下一行的缩进</span><br><span class="line">"</span><br><span class="line">" &lt;S-Left&gt;            按住 SHIFT 按左键，向左移动一个单词" &lt;S-Right&gt;           按住 SHIFT 按右键，向右移动一个单词" &lt;S-Up&gt;              按住 SHIFT 按上键，向上翻页</span><br><span class="line">" &lt;S-Down&gt;            按住 SHIFT 按下键，向下翻页</span><br><span class="line">"</span><br><span class="line">" =============================================================================</span><br><span class="line">"</span><br><span class="line">"</span><br><span class="line">""切换buffer</span><br><span class="line">":bn 切换到后一个</span><br><span class="line">":bp 切换到前一个</span><br><span class="line">"</span><br><span class="line">"</span><br><span class="line">"</span><br><span class="line">" vim 缩进大法</span><br><span class="line">"</span><br><span class="line">" 缩进4个格  1,18&gt; 1到18行向右缩进4格,       &lt;向左缩进4空格</span><br><span class="line">"</span><br><span class="line">" 缩进自定义个格</span><br><span class="line">" ctrl v 进入visual block模式, 选择块, 按I</span><br><span class="line">" ,按1个空格,按esc键就可以整个块向右缩进1格</span><br><span class="line">"</span><br><span class="line">" 按几个空格缩进几个格," 甚至不输入空格而是输入字符,都会使得整个块每一行前面都加上这几个字符(其实输入空格就是在开头添加空格,输入字符就是添加字符)"</span><br></pre></td></tr></table></figure>



<p><strong>编译过程</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 预定义</span><br><span class="line">     宏替换</span><br><span class="line">     处理条件编译/预编译指令</span><br><span class="line">     头文件展开</span><br><span class="line">     添加行号信息方便调试</span><br><span class="line">     去掉注释</span><br><span class="line">     生成.i文件</span><br><span class="line">2. 编译</span><br><span class="line">     语法/语义分析,源代码优化,目标代码生成与优化</span><br><span class="line">     	词法分析: </span><br><span class="line">     	语法分析:</span><br><span class="line">     	语义分析:</span><br><span class="line">     生成汇编代码</span><br><span class="line">     生成.s文件</span><br><span class="line">3. 汇编</span><br><span class="line">     将汇编指令翻译为二进制指令</span><br><span class="line">     生成.o二进制文件</span><br><span class="line"></span><br><span class="line">4. 链接</span><br></pre></td></tr></table></figure>





<p><strong>gcc g++</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-E 只激活预处理,不生成文件,需要把它重定向到一个输出文件里</span><br><span class="line">-S 预处理和编译,生成汇编代码</span><br><span class="line">-c 只激活预处理,编译,汇编生成obj文件(二进制文件)</span><br><span class="line">-o 生成可执行文件(指定文件名称,缺省为a.out)</span><br><span class="line">-static 禁止使用动态库(编译出来的东西一般都很大,也不需要什么动态链接库就可以运行),禁止使用共享连接</span><br><span class="line">-fPIC </span><br><span class="line">--share 尽量使用动态库,生成文件较小,但需要系统由动态库生成共享目标文件</span><br><span class="line">-L  指定库的路径</span><br><span class="line">-I 头文件默认搜索路径</span><br><span class="line">-l 指定链接库名称</span><br><span class="line">-g 编译时产生调试信息</span><br></pre></td></tr></table></figure>



<p><strong>gdb</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>makefile</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">makeifle编写规则</span><br><span class="line">makefile解释流程</span><br><span class="line"></span><br><span class="line">makefile解决的是编译问题,可以将命名写成一个脚本文件,然后去执行这个脚本文件</span><br></pre></td></tr></table></figure>





<p><strong>git</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">远程部署三连</span><br><span class="line">git add .    添加到缓冲区/暂存区</span><br><span class="line">git commit -m "regular"  提交文件,提交到仓库区</span><br><span class="line">git push -u origin master  提交到远程仓库</span><br></pre></td></tr></table></figure>



<p><strong>git基础操作</strong></p>
<p><img src="/2020/10/20/mianshi/lu/%E6%96%87%E6%A1%A3/typorafile/git/ass/git.jpg" alt="git"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">工作区: 磁盘上的文件集合</span><br><span class="line">版本区(版本库): .git文件夹 &#x3D; 暂存区(stage) + 分支(master) + 指针Head</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &#39;humancloud&#39;</span><br><span class="line">git config --global user.email &#39;humancloud@126.com&#39;</span><br><span class="line">git init  版本区建立(创建.git文件)</span><br><span class="line">git add . 把工作区所有文件提交到版本区里的暂存区</span><br><span class="line">git commit -m &quot;xxx&quot; 暂存区所以文件提交到仓库区(暂存区空)</span><br><span class="line">git remote add origin xxxxxx.git  把本地仓库与远程仓库连接起来</span><br><span class="line">git push -u origin master 把仓库区文件提交到远程仓库里(将本地的master分支推送到origin主机,同时指定origin为默认主机))</span><br></pre></td></tr></table></figure>



<p><strong>其他命令:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  calculator git:(master) ✗ git status 查看状态</span><br><span class="line">➜  calculator git:(master) ✗ git remote -v 查看远程仓库</span><br><span class="line">➜  calculator git:(master) ✗ git remote add [name] [url] 添加远程仓库</span><br><span class="line">➜  calculator git:(master) ✗ git remote rm [name] 删除远程仓库</span><br><span class="line">➜  calculator git:(master) ✗ git rm &amp;&amp; git commit -m &quot;xxx&quot; 删除版本区文件</span><br><span class="line">➜  calculator git:(master) ✗ git remote set-url --push [name] [new url] 修改远程仓库 </span><br><span class="line">➜  calculator git:(master) ✗ git log 查看日志</span><br><span class="line">➜  calculator git:(master) ✗ git pull 把最新的提交从远程仓库抓取下来,在本地合并,和git push 相反</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意:: 克隆下项目来,如果想要更新项目,直接git pull 把最新的项目拉下来,即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">撤销: </span><br><span class="line">1. 在工作区修改了内容,向回溯到版本区(版本库)里的版本</span><br><span class="line">➜  calculator git:(master) ✗ git checkout --file 用版本区的版本替换工作区的版本</span><br><span class="line"></span><br><span class="line">2. 在工作区修改了内容,并git add添加到了暂存区,要撤销</span><br><span class="line">➜  calculator git:(master) ✗ git reset --hard 版本号 ,暂存区回溯到以前的版本(版本号 git log查看)</span><br><span class="line">➜  calculator git:(master) ✗ git checkout --file 再用版本区的替换工作区的版本</span><br><span class="line">3. .....,并git commit 到了仓库区,与2相同</span><br><span class="line"></span><br><span class="line">删除:</span><br><span class="line">1. 删除版本区(版本库)的文件,(如果git add把某文件存到暂存区了,然后在工作区把这个文件删除了,要想把版本区的这个文件也删除,执行下面)</span><br><span class="line">➜  calculator git:(master) ✗ git rm [filename] &amp;&amp; git commit -m &quot;xxx&quot; ,删除版本区的文件并描述这次删除, </span><br><span class="line"></span><br><span class="line">2. 如果git add了,然后删除了本地文件,git会知道,要想恢复,可以从版本区恢复,</span><br><span class="line">➜  calculator git:(master) ✗ git checkout --file</span><br></pre></td></tr></table></figure>



<p><strong>test:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  calculator git:(master) ✗ git add a.c     添加到暂存区</span><br><span class="line">➜  calculator git:(master) ✗ git commit -m &quot;first&quot;	将文件从暂存区提交到仓库</span><br><span class="line">➜  calculator git:(master) ✗ git remote add origin https:&#x2F;&#x2F;github.com&#x2F;humancloud&#x2F;c.git &#x2F;&#x2F;将本地仓库同步到远程仓库</span><br><span class="line">➜  calculator git:(master) ✗ git push -u origin master </span><br><span class="line">Username for &#39;https:&#x2F;&#x2F;github.com&#39;: humancloud</span><br><span class="line">Password for &#39;https:&#x2F;&#x2F;humancloud@github.com&#39;: </span><br><span class="line">对象计数中: 5, 完成.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">压缩对象中: 100% (2&#x2F;2), 完成.</span><br><span class="line">写入对象中: 100% (5&#x2F;5), 1.72 KiB | 1.72 MiB&#x2F;s, 完成.</span><br><span class="line">Total 5 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;humancloud&#x2F;c.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">分支 &#39;master&#39; 设置为跟踪来自 &#39;origin&#39; 的远程分支 &#39;master&#39;。</span><br><span class="line">➜  calculator git:(master) ✗ </span><br><span class="line">➜  calculator git:(master) ✗ git rm .</span><br><span class="line">➜  calculator git:(master) ✗ git commit -m &quot;xxx&quot;</span><br></pre></td></tr></table></figure>



<p><strong>常遇到</strong></p>
<p><strong>删除错误添加到暂存区的文件:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch 1.txt</span><br><span class="line">git add 1.txt</span><br><span class="line"></span><br><span class="line">1. 删除添加到暂存区的文件1.txt</span><br><span class="line">git rm --cache 1.txt</span><br><span class="line"></span><br><span class="line">2. 删除暂存区和工作区的文件</span><br><span class="line">git rm -f 1.txt</span><br></pre></td></tr></table></figure>



<p><strong>删除错误提交的</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch 1.txt</span><br><span class="line">git add 1.txt</span><br><span class="line">git cimmit -m "regular"</span><br><span class="line"></span><br><span class="line">撤销版本库的修改(暂存区,工作区不变): git reset - 本站访客数:-soft 版本库ID</span><br><span class="line">撤销版本库和暂存区不修改工作区: git reset --mixed 版本库ID</span><br><span class="line">将工作区,暂存区,版本库恢复到指定的版本:git reset --hard 版本库ID</span><br></pre></td></tr></table></figure>



<p><strong>日志</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这个最上面的是最近的提交不是最下面的是,这串数字就是版本库ID</span><br><span class="line"></span><br><span class="line">commit d2c6f0ca1e7c075692c55870f4166b1e297dfcea (HEAD -&gt; master)</span><br><span class="line">Author: humancloud &lt;humancloud@126.com&gt;</span><br><span class="line">Date:   Sat May 2 19:05:43 2020 +0800</span><br><span class="line"></span><br><span class="line">    regular</span><br><span class="line"></span><br><span class="line">commit d1212d0313103c4a1199624220a1ac7c415c6785</span><br><span class="line">Author: humancloud &lt;humancloud@126.com&gt;</span><br><span class="line">Date:   Sat May 2 18:55:37 2020 +0800</span><br><span class="line"></span><br><span class="line">    regular</span><br><span class="line"></span><br><span class="line">commit 87268a78fff1c94da04de77681cf617e151d6081 (origin/master)</span><br><span class="line">Author: humancloud &lt;humancloud@126.com&gt;</span><br><span class="line">Date:   Wed Apr 22 20:58:16 2020 +0800</span><br><span class="line"></span><br><span class="line">    regular</span><br><span class="line"></span><br><span class="line">commit 9bee9335b7a83680d18e1eb2523d0cd96b59bb31</span><br><span class="line">Author: humancloud &lt;humancloud@126.com&gt;</span><br><span class="line">Date:   Sun Apr 19 13:42:37 2020 +0800</span><br><span class="line"></span><br><span class="line">    regular</span><br><span class="line">:</span><br></pre></td></tr></table></figure>







<h1 id="3-hr常问"><a href="#3-hr常问" class="headerlink" title="3. hr常问"></a>3. hr常问</h1><ol>
<li>工作城市</li>
</ol>
<ol start="2">
<li>优缺点</li>
</ol>
<ol start="3">
<li>哪些因素决定这家公司</li>
</ol>
<ol start="4">
<li></li>
</ol>
<h1 id="4-C-语言方面"><a href="#4-C-语言方面" class="headerlink" title="4. C++语言方面"></a>4. C++语言方面</h1><h2 id="4-1-C和C-区别"><a href="#4-1-C和C-区别" class="headerlink" title="4.1 C和C++区别"></a>4.1 C和C++区别</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 设计思想不同</span><br><span class="line"></span><br><span class="line">C语言是面向过程的: 优点(高效,性能好),缺点(不易维护,可扩展性低)</span><br><span class="line">C++是面向对象的,具有三大特性(封装,继承,多态)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 参数列表</span><br><span class="line">C语言如果没有指定参数列表,可以默认接收多个参数</span><br><span class="line">C++如果没有指定参数列表,不接受任何参数</span><br><span class="line"></span><br><span class="line">3. 函数默认返回值</span><br><span class="line">C语言函数默认返回值为int</span><br><span class="line">C++函数默认返回值为void</span><br><span class="line"></span><br><span class="line">4. 输入输出不同</span><br><span class="line"></span><br><span class="line">C    printf scanf</span><br><span class="line">C++  cout cin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5. C++扩展了C语言的关键字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static关键字:</span><br><span class="line"></span><br><span class="line">	全局静态变量: 全局变量前加static成为全局静态变量,</span><br><span class="line">		        存储在静态区,属于静态变量,整个运行期间一直存在</span><br><span class="line">		        未被初始化的全局静态变量自动初始化</span><br><span class="line">		        作用域在当前文件,在声明他的其他文件之外不可见</span><br><span class="line">		        链接属性由外部变为内部,存储类型不变</span><br><span class="line">		        (默认全局变量是全局的,所以链接属性是外部的)</span><br><span class="line">		        </span><br><span class="line">   </span><br><span class="line">   局部静态变量:  局部变量前加static成为局部静态变量,</span><br><span class="line">                存储在静态区,属于静态变量,整个运行期间一直存在</span><br><span class="line">                作用域依然是局部的,定义他的函数块结束,作用域结束,但是变量并没有被销毁,当再次进入此函数时,依然可以访问,值不变</span><br><span class="line">                存储类型发生改变,由自动变量改为静态变量</span><br><span class="line">                作用域和链接属性不变</span><br><span class="line">   </span><br><span class="line">   静态函数:      函数返回类型前加static,成为静态函数</span><br><span class="line">                 只在声明他的文件内可见,不能被其他文件所用,不会引起命名冲突</span><br><span class="line">                 尽量不要在头文件声明static的全局函数         (要在源文件中写是吗,在头文件里写头文件会被包含到其他文件,但包含了并不能使用他)</span><br><span class="line">     </span><br><span class="line">   类的静态成员:   实现多个对象间的数据共享,不会破坏隐藏规则</span><br><span class="line">   				 静态成员是所有对象的共享成员,不属于某一个对象</span><br><span class="line">   				 声明周期是创建类到销毁类</span><br><span class="line">   				 和类中非静态成员不同的是：  非静态成员属于对象，声明周期是从对象实例化开始，而静态成员是类一创建就已经存在了</span><br><span class="line">   </span><br><span class="line">   类的静态函数：  属于类的静态成员，不属于对象</span><br><span class="line">   				 静态成员函数不能直接引用类的非静态成员，可以引用类中的静态成员</span><br><span class="line">   				 对于类中的成员变量和成员函数加上static就不属于对象，自然也没有this指针了</span><br><span class="line">extern关键字</span><br><span class="line"></span><br><span class="line">		引用另一个文件的变量</span><br><span class="line">		引用同一个文件的变量</span><br><span class="line">		引用另一个文件的函数</span><br></pre></td></tr></table></figure>

















<h1 id="5-常用sql语句"><a href="#5-常用sql语句" class="headerlink" title="5. 常用sql语句"></a>5. 常用sql语句</h1><p>必知必会总结</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

















<h1 id="6-数据结构部分"><a href="#6-数据结构部分" class="headerlink" title="6. 数据结构部分"></a>6. 数据结构部分</h1><p>MyTinySTL</p>
<p>C实现的基础数据结构</p>
<p>cpp实现基础数据结构</p>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><p><strong>冒泡排序</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从大到小</span></span><br><span class="line"><span class="comment"> * a1 与 a2 比较,a2&gt;a1则交换位置</span></span><br><span class="line"><span class="comment"> * 从第一个元素往后比较每次排序都把最大的放右边,不能放左边,    如果要把最大的放左边则要从最后一个元素往前比较</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j+<span class="number">1</span>])&#123;</span><br><span class="line">				tmp = <span class="built_in">array</span>[j+<span class="number">1</span>];</span><br><span class="line">				<span class="built_in">array</span>[j+<span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">				<span class="built_in">array</span>[j] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>快速排序</strong></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><strong>简单选择排序</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SimpLeSelectSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L-&gt;length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;=L-&gt;length;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (L-&gt;r[i].key &gt; L-&gt;r[j].key)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp = L-&gt;r[j].key;</span><br><span class="line">				L-&gt;r[j].key = L-&gt;r[i].key;</span><br><span class="line">				L-&gt;r[i].key = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>堆排序</strong></p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3>]]></content>
      <categories>
        <category>面试小总结</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>network-2</title>
    <url>/2020/03/22/network-2/</url>
    <content><![CDATA[<h2 id="前言-笔记"><a href="#前言-笔记" class="headerlink" title="前言: 笔记"></a>前言: 笔记</h2><p><strong>linux系统中维护着两个队列</strong></p>
<ul>
<li>第一个队列存放的是已建立连接的套接字(即完成三次握手后的established),</li>
<li>第二个队列是未建立连接的套接字(处于三次握手中的syn_rcvd),</li>
<li>每次accept会将第一个队列中的套接字返回,进行通信,以完成网络传输<a id="more"></a>

</li>
</ul>
<p>图中仅给出了第一个队列,这个队列的连接已经被TCP接收（已经完成三次握手），但是还没有被应用程序接收（调用accept函数)</p>
<p><img src="/2020/03/22/network-2/4.png" alt></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">监听端口后,被动套接字等待连接</span><br><span class="line"></span><br><span class="line">(socket函数产生套接字(默认为主动套接字),bind函数绑定端口,listen函数把套接字变成被动套接字,accept函数阻塞等待连接</span><br><span class="line"></span><br><span class="line">客户端使用connect函数主动与服务器建立连接,</span><br><span class="line"></span><br><span class="line">服务器accept接收连接,accept函数返回连接套接字,两端通过连接套接字进行通信)</span><br></pre></td></tr></table></figure>

<p><strong>listen函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">listen</span>函数</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line">linux2<span class="number">.2</span>以前,backlog表示两个队列总和的长度</span><br><span class="line">linux2<span class="number">.2</span>以后,backlog表示已完成连接的队列的长度,</span><br><span class="line">当长度超过会忽略客户端的请求连接</span><br></pre></td></tr></table></figure>

<h2 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h2><p><strong>将服务端的listen函数第二个参数设置为0</strong></p>
<p><img src="/2020/03/22/network-2/9.png" alt></p>
<p>可以看到,我打开了个5客户端,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat | grep tcp</span><br><span class="line"></span><br><span class="line">查看信息,可以看到,前两对客户端的状态是established</span><br><span class="line">后面三个客户端(不是3对了),状态是syn_sent(表示请求连接),也就是客户端在请求与服务器连接</span><br><span class="line"></span><br><span class="line">在一段时间后,后面三个客户端报错了-连接超时(说明服务器忽略了后面三个连接请求,因为达到了队列最大长度)</span><br></pre></td></tr></table></figure>
<p><strong>设置为1</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat | grep tcp</span><br><span class="line"></span><br><span class="line">查看信息,可以看到,前3对客户端的状态是established</span><br><span class="line">后面两个状态是syn_sent(表示请求连接),也就是客户端在请求与服务器连接</span><br><span class="line"></span><br><span class="line">在一段时间后,后面2个客户端报错了-连接超时</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/22/network-2/7.png" alt></p>
<p><img src="/2020/03/22/network-2/8.png" alt></p>
<h2 id="实现1结论"><a href="#实现1结论" class="headerlink" title="实现1结论:"></a>实现1结论:</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">backlog设置为0  :  可以与2个客户端建立tcp连接</span><br><span class="line">backlog设置为1  :  可以与3个客户端建立tcp连接</span><br><span class="line"></span><br><span class="line">&lt;&lt;Unix网络编程&gt;&gt;说backlog从未有过正式的定义,</span><br></pre></td></tr></table></figure>


<h2 id="实验2"><a href="#实验2" class="headerlink" title="实验2:"></a>实验2:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sockC = accept(sock, (struct sockaddr*)&amp;addrC, &amp;sizeAddr);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == sockC)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"accept() error : %d -&gt; %s\n"</span>, errno, strerror(errno));</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"accept call\n"</span>);</span><br><span class="line"></span><br><span class="line">在accept函数后面加上信息,输出<span class="string">"accept call"</span>表示accept已经执行完毕并返回</span><br></pre></td></tr></table></figure>

<p><strong>此时来看一下</strong></p>
<p>第一个客户端与服务器建立连接,可以看到输出了客户端1的ip端口信息<br>并且可以看到accept函数调用成功并返回了,再打开第二个客户端,服务器并没有响应<br>此时客户端1可以与服务器通信但客户端2不可以</p>
<p><img src="/2020/03/22/network-2/5.png" alt></p>
<p>结束第一个客户端,可以看到此时第二个客户端连接到服务器并调用了accept函数,</p>
<p><img src="/2020/03/22/network-2/6.png" alt></p>
<p><strong>注意:</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shell命令netstat查看信息(左下角终端)</span><br><span class="line"></span><br><span class="line">netstat | grep tcp</span><br><span class="line"></span><br><span class="line">可以看到有两对连接</span><br><span class="line"></span><br><span class="line">两对连接都是established状态,即两个客户端都已经与服务器建立了Tcp连接,进入连接队列</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>network</title>
    <url>/2020/03/22/network/</url>
    <content><![CDATA[<h1 id="作业"><a href="#作业" class="headerlink" title="作业:"></a>作业:</h1><h4 id="1、查看listen的man-page信息，了解backlog的作用，下次找同学回答。"><a href="#1、查看listen的man-page信息，了解backlog的作用，下次找同学回答。" class="headerlink" title="1、查看listen的man page信息，了解backlog的作用，下次找同学回答。"></a>1、查看listen的man page信息，了解backlog的作用，下次找同学回答。</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">backlog::允许同时与服务器连接的客户端数量</span><br><span class="line">    </span><br><span class="line">查看系统默认backlog:</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_max_syn_backlog</span><br><span class="line">    </span><br><span class="line">监听端口后,被动套接字等待连接(listen函数把套接字变成被动套接字,accept函数阻塞等待连接),</span><br><span class="line">此时系统中维护着两个队列,第一个队列存放的是已建立连接的套接字(即完成三次握手后的established),</span><br><span class="line">第二个队列是未建立连接的套接字(处于三次握手中的syn_rcvd),</span><br><span class="line">每次accept会将第一个队列中的套接字返回,进行通信,以完成网络传输</span><br><span class="line"></span><br><span class="line">linux2.2以前,backlog表示两个队列总和的长度</span><br><span class="line">linux2.2以后,backlog表示已完成连接的队列的长度</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="2、查看recv的man-page信息，了解recv返回值的信息，下次解答"><a href="#2、查看recv的man-page信息，了解recv返回值的信息，下次解答" class="headerlink" title="2、查看recv的man page信息，了解recv返回值的信息，下次解答"></a>2、查看recv的man page信息，了解recv返回值的信息，下次解答</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">recv函数原型为:</span><br><span class="line">	<span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line">参数:</span><br><span class="line">第一个参数：接收端的套接字描述符</span><br><span class="line">第二个参数：接受数据的缓冲区</span><br><span class="line">第三个参数：缓冲区的尺寸，<span class="keyword">sizeof</span>（）</span><br><span class="line">第四个参数：置<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>原理:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，</span><br><span class="line">如果协议在传送s的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR；</span><br><span class="line">如果s的发送缓冲中没有数据或者数据被协议成功发送完毕后，recv先检查套接字s的接收缓冲区，</span><br><span class="line">如果s接收缓冲区中没有数据或者协议正在接收数据，那么recv就一直等待，直到协议把数据接收完毕；</span><br><span class="line"></span><br><span class="line">当协议把数据接收完毕，recv函数就把s的接收缓冲中的数据copy到buf中注意协议接收到的数据可能大于buf的</span><br><span class="line">长度，所以在这种情况下要调用几次recv函数才能把s的接收缓冲中的数据copy完。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">recv函数仅仅是copy数据，真正的接收数据是协议来完成的，recv函数返回其实际copy的字节数；</span><br><span class="line">如果recv在copy时出错，那么它返回SOCKET_ERROR；</span><br><span class="line">如果recv函数在等待协议接收数据时网络中断了，那么它返回0。</span><br></pre></td></tr></table></figure>

<p>返回值:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">如果recv函数成功，返回值大于0，返回的是其实际copy的字节数；</span><br><span class="line">如果recv在copy时出错，那么它返回SOCKET_ERROR；</span><br><span class="line">如果recv函数在等待协议接收数据时网络中断了，那么它返回0。</span><br><span class="line"></span><br><span class="line">EAGAIN：套接字已标记为非阻塞，而接收操作被阻塞或者接收超时</span><br><span class="line">EBADF：sock不是有效的描述词</span><br><span class="line">ECONNREFUSE：远程主机阻绝网络连接</span><br><span class="line">EFAULT：内存空间访问出错</span><br><span class="line">EINTR：操作被信号中断</span><br><span class="line">EINVAL：参数无效</span><br><span class="line">ENOMEM：内存不足</span><br><span class="line">ENOTCONN：与面向连接关联的套接字尚未被连接上</span><br><span class="line">ENOTSOCK：sock索引的不是套接字</span><br></pre></td></tr></table></figure>


<p><strong>send函数:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">原型:</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回值:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1. s 指定发送端套接字描述符。</span><br><span class="line">2. buff 表示存放发送数据的缓冲区。 </span><br><span class="line">3. 实际要发送的字节数，</span><br></pre></td></tr></table></figure>

<p>原理:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">当调用该函数时，send先比较待发送数据的长度len和套接字s的发送缓冲区的长度，</span><br><span class="line">如果len大于s的发送缓冲区的长度，该函数返回SOCKET_ERROR； </span><br><span class="line">如果len小于或者等于s的发送缓冲区的长度，那么send先检查协议是否正在发送s的发送缓冲中的数据； </span><br><span class="line">如果是就等待协议把数据发送完，</span><br><span class="line">如果协议还没有开始发送s的发送缓冲中的数据或者s的发送缓冲中没有数据，那么send就比较s的发送缓冲区的剩余空间和len； </span><br><span class="line">如果len大于剩余空间大小，send就一直等待协议把s的发送缓冲中的数据发送完，</span><br><span class="line">如果len小于剩余空间大小，send就仅仅把buf中的数据copy到剩余空间里（注意并不是send把s的发送缓冲中的数据传到连接的另一端的，而是协议传的，send仅仅是把buf中的数据copy到s的发送缓冲区的剩余空间里）。 </span><br><span class="line">如果send函数copy数据成功，就返回实际copy的字节数，</span><br><span class="line">如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR； </span><br><span class="line">如果send在等待协议传送数据时网络断开的话，那么send函数也返回SOCKET_ERROR。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">要注意send函数把buf中的数据成功copy到s的发送缓冲的剩余空间里后它就返回了，</span><br><span class="line">但是此时这些数据并不一定马上被传到连接的另一端。 如果协议在后续的传送过程中出现网络错误的话，</span><br><span class="line">那么下一个Socket函数就会返回SOCKET_ERROR。</span><br><span class="line">（每一个除send外的Socket函数在执行的最开始总要先等待套接字的发送缓冲中的数据被协议传送完毕才能继续，</span><br><span class="line">如果在等待时出现网络错误，那么该Socket函数就返回SOCKET_ERROR</span><br></pre></td></tr></table></figure>


<p>####　3、为客户端加上退出机制</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(bufOut,<span class="string">"bye"</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"you input bye"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="4、为服务端加上特殊的“停止服务”功能。-确定对方是管理员才退出-否则不退出"><a href="#4、为服务端加上特殊的“停止服务”功能。-确定对方是管理员才退出-否则不退出" class="headerlink" title="4、为服务端加上特殊的“停止服务”功能。(确定对方是管理员才退出,否则不退出)"></a>4、为服务端加上特殊的“停止服务”功能。(确定对方是管理员才退出,否则不退出)</h4><h1 id="本节课内容"><a href="#本节课内容" class="headerlink" title="本节课内容:"></a>本节课内容:</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">udp: recvfrom不一定接收到对端发来的信息,因为udp不检查对端是否收到,tcp检查吗</span><br><span class="line"></span><br><span class="line">浏览器访问www.qq.com:7777是访问不了的,因为服务器上没有应用程序运行在7777端口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">服务端:</span><br><span class="line"></span><br><span class="line">1、创建流式套接字，目的是监听连接请求</span><br><span class="line"></span><br><span class="line">2、绑定对外公布的地址信息</span><br><span class="line"></span><br><span class="line">3、确定连接请求队列大小，进入监听套接字监听状态</span><br><span class="line"></span><br><span class="line">4、当有客户端的连接请求到来时，创建一个为该客户端提供1对1服务的流式套接字，它只起数据传输作用，称为响应套接字</span><br><span class="line"></span><br><span class="line">5、响应套接字与客户端套接字成为通信双方，这个通信是有连接的，在此基础上，可以按照通信规程（业务逻辑）传输数据</span><br><span class="line"></span><br><span class="line">5.1、发送数据：将数据从应用程序缓冲区复制到套接字的发送缓冲区，至于何时真正发送到对方，由协议栈决定</span><br><span class="line"></span><br><span class="line">5.2、接收数据：将数据从套接字的接收缓冲区移动到应用程序的缓冲区，</span><br><span class="line"></span><br><span class="line">6、数据传输完成后，可关闭响应套接字</span><br><span class="line"></span><br><span class="line">7、一般情况下，不关闭监听套接字，除非有特殊要求</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">客户端:</span><br><span class="line"></span><br><span class="line">1、创建流式套接字</span><br><span class="line"></span><br><span class="line">2、根据服务端公布的地址信息，连接到服务端</span><br><span class="line"></span><br><span class="line">3、连接成功后，可以按照通信规程（业务逻辑）传输数据</span><br><span class="line"></span><br><span class="line">3.1、发送数据：将数据从应用程序缓冲区复制到套接字的发送缓冲区，至于何时真正发送到对方，由协议栈决定</span><br><span class="line"></span><br><span class="line">3.2、接收数据：将数据从套接字的接收缓冲区移动到应用程序的缓冲区，</span><br><span class="line"></span><br><span class="line">4、数据传输完成后，可关闭套接字</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>pip更换国内源</title>
    <url>/2020/03/09/pip/</url>
    <content><![CDATA[<p>pip更换国内源将会有几兆每秒的速度</p>
<p><strong>步骤</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ~/.pip</span><br><span class="line">vim ~/.pip/pip.conf</span><br><span class="line"></span><br><span class="line">打开文件后,输入以下信息,即可使用清华源</span><br><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = https://pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure>

<p><strong>使用easy_install来安装模块</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">easy_install 换源</span><br><span class="line">cd /root          注意要放到/root目录下</span><br><span class="line">vi .pydistutils.cfg 打开配置文件</span><br><span class="line"></span><br><span class="line">[easy_install]</span><br><span class="line">index-url=http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">find-links=http://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>网络编程考试总结</title>
    <url>/2020/05/31/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言-笔记"><a href="#前言-笔记" class="headerlink" title="前言: 笔记"></a>前言: 笔记</h2><p>linux多线程的同步即   sem 和 互斥量</p>
<p>程序设计题不涉及多线程,不会使用到select,epoll,WSA等模型,有字符串处理</p>
<p>简答五选三(背五道题)</p>
<a id="more"></a>



<h2 id="函数总结"><a href="#函数总结" class="headerlink" title="函数总结"></a>函数总结</h2><p><strong>TCP echo服务器用到的函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">成功返回<span class="number">0</span>,失败返回<span class="number">-1</span>,其他返回值通过man了解</span><br></pre></td></tr></table></figure>


<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint8_t</span> 		sin_len;</span><br><span class="line">	<span class="keyword">sa_family_t</span> 	sin_family;</span><br><span class="line">	<span class="keyword">in_port_t</span> 		sin_port;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> 			sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用到的就三个: sin_family,  sin_port,  sin_addr.s_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint8_t</span> 		sa_len;</span><br><span class="line">	<span class="keyword">sa_family_t</span> 	sa_family;</span><br><span class="line">	<span class="keyword">char</span> 			sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">(struct sockaddr *)&amp;addr;  <span class="comment">//主要作用就是强制转换sockaddr_in类型为sockaddr类型</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(AF_INET, SOCK_STREAM,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(AF_INET,SOCK_DGRAM,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">AF_INET       ipv4</span><br><span class="line">AF_INET6      ipv6</span><br><span class="line">SOCK_STREAM   tcp</span><br><span class="line">SOCK_DGRAM    udp</span><br><span class="line"></span><br><span class="line">使用指定参数创建一个套接字</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;      </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line">将创建的套接字标记为被动套接字,等待客户端连接</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">阻塞等待连接请求到达,连接请求到达后,创建连接套接字,客户端与服务器使用连接套接字通信</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;         </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">send 和recv 函数只能用于tcp, sendto和recvfrom函数可以用于udp也可用于tcp</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                 struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">write</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inet_ntop()</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">将网络字节序转为ip地址</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inet_pton()</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">直接将ip地址转为网络字节序(不需要先转为主机字节序,再转为网络字节序)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;              <span class="comment">//host to network long          主机字节序转网络字节序   l表示long,转ip,s表示short转port</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="Tcp-服务器客户端通信过程"><a href="#Tcp-服务器客户端通信过程" class="headerlink" title="Tcp 服务器客户端通信过程"></a>Tcp 服务器客户端通信过程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">服务器:</span><br><span class="line">socket()  创建套接字</span><br><span class="line">bind()</span><br><span class="line"><span class="built_in">listen</span>()  将套接字标记为监听套接字</span><br><span class="line">accept()  阻塞等待客户端连接,收到连接请求后,建立连接返回连接套接字</span><br><span class="line"></span><br><span class="line">send,recv接收消息(或者使用<span class="built_in">write</span>,<span class="built_in">read</span>,或者sendto,recvfrom)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">客户端:</span><br><span class="line">socket()  创建套接字</span><br><span class="line">bind()    可隐式绑定</span><br><span class="line"><span class="built_in">connect</span>() 连接服务器</span><br><span class="line">sendto() </span><br><span class="line">recvfrom()   收发消息(udp不能使用recv和send函数)</span><br></pre></td></tr></table></figure>

<h3 id="Udp服务器客户端通信过程"><a href="#Udp服务器客户端通信过程" class="headerlink" title="Udp服务器客户端通信过程"></a>Udp服务器客户端通信过程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Udp不需建立连接,所以不需要accept不需要<span class="built_in">connect</span>不需要<span class="built_in">listen</span></span><br><span class="line"></span><br><span class="line">服务器:</span><br><span class="line">socket()  创建套接字</span><br><span class="line">bind()</span><br><span class="line">recvfrom()</span><br><span class="line">sendto()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">客户端:</span><br><span class="line">socket()  创建套接字</span><br><span class="line">bind()    可以隐式绑定</span><br><span class="line">sendto() </span><br><span class="line">recvfrom()</span><br></pre></td></tr></table></figure>




<h2 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）阻塞（Blocked）：当调用某个函数时，若操作条件不具备，函数会一直处于等待状态，程序的执行进程会在该函数调用处停顿，直到操作完成或发生错误为止。</span><br><span class="line"></span><br><span class="line">2）非阻塞（Nonblocked）：当调用某个函数时，无论操作条件是否具备，函数均会立即返回，程序的执行进程不会在该函数调用处停顿，而是继续执行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1）SOCK_DGRAM及SOCK_STREAM类型的套接字均可以工作在阻塞模式或非阻塞模式</span><br><span class="line"></span><br><span class="line">2）Linux中，创建套接字的同时可以指定工作模式，例如</span><br><span class="line"></span><br><span class="line">socket(AF_INET, SOCK_STREAM |  SOCK_NONBLOCK, 0)</span><br><span class="line"></span><br><span class="line">上述代码会创建非阻塞模式的套接字。默认情况下，新建的套接字工作在阻塞模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果要把工作在阻塞模式的套接字改为非阻塞模式,可以使用函数fcntl (下面参数里sockfd即为阻塞模式的套接字),</span><br><span class="line"></span><br><span class="line">(用法: 例如accept函数返回的套接字不能直接设置为非阻塞需要fcntl函数处理)</span><br><span class="line"></span><br><span class="line">fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1）非阻塞模式套接字的函数调用失败时，并不一定表示真的遇到了网络错误，应根据errno的值进行相应的处理</span><br><span class="line">2）若errno值为EAGAIN或EWOULDBLOCK，则表示操作条件目前并不具备，而不是遇到了网络错误</span><br><span class="line"></span><br><span class="line">        sockC &#x3D; accept(sock, (struct sockaddr*)&amp;addrC, &amp;sizeAddr);</span><br><span class="line"></span><br><span class="line">        if(-1 &#x3D;&#x3D; sockC)</span><br><span class="line">        &#123;</span><br><span class="line">            if(errno !&#x3D; EAGAIN &amp;&amp; errno !&#x3D; EWOULDBLOCK)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;accept() error : %d -&gt; %s\n&quot;, errno, strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="多线程创建管理"><a href="#多线程创建管理" class="headerlink" title="多线程创建管理"></a>多线程创建管理</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">头文件</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;     编译时加上-pthtread参数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line">pthread_create(&amp;thread,<span class="literal">NULL</span>,doThread,(<span class="keyword">void</span>*)arg);  <span class="comment">/*创建线程,线程id为thread*/</span></span><br><span class="line">pthread_detach(thread);        <span class="comment">/* 分离线程,意思是线程函数执行完毕后系统自动回收线程 */</span></span><br><span class="line">pthread_join(thread,<span class="literal">NULL</span>);          <span class="comment">/* 等待线程函数结束(直到线程函数结束,代码不会向下执行),可以接收线程函数的返回值(线程函数返回值为void* 所以可以返回任何值) */</span></span><br></pre></td></tr></table></figure>


<h3 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h3><p><strong>信号量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">线程的信号量与进程间通信中使用的信号量的概念是一样，它是一种特殊的变量，它可以被增加或减少，但对其的关键访问被保证是原子操作。</span><br><span class="line">如果一个程序中有多个线程试图改变一个信号量的值，系统将保证所有的操作都将依次进行。</span><br><span class="line"></span><br><span class="line">信号量的函数都以sem_开头，线程中使用的基本信号量函数有<span class="number">4</span>个，它们都声明在头文件semaphore.h中。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> sem_init函数 该函数用于创建信号量                                 <span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared， <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="number">2.</span> sem_wait函数 该函数用于以原子操作的方式将信号量的值减<span class="number">1</span>。          <span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="number">3.</span> sem_post函数 该函数用于以原子操作的方式将信号量的值加<span class="number">1</span>。          <span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="number">4.</span> sem_destroy函数 该函数用于对用完的信号量的清理                    <span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line">sem_wait(); 到 sem_post(); 之间的代码是原子操作,不用管信号量的值是几,具体由操作系统管理</span><br></pre></td></tr></table></figure>


<p><strong>互斥量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;                           <span class="comment">/* 创建锁*/</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);                <span class="comment">/* 初始化锁 */</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);                      <span class="comment">/* 上锁 */</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);                    <span class="comment">/* 解锁*/</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);                   <span class="comment">/* 销毁锁 */</span></span><br></pre></td></tr></table></figure>




<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *<span class="keyword">restrict</span> readfds,</span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> errorfds,</span></span></span><br><span class="line"><span class="function"><span class="params">           struct timeval *<span class="keyword">restrict</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  void FD_ZERO(fd_set *set) 将set清空为0</span><br><span class="line">  void FD_SET(int fd,fd_set *set) 将fd设置到set集合中去</span><br><span class="line">  void FD_CLR(int fd,fd_set *set) 将fd从set中清除出去</span><br><span class="line">  int FD_ISSET(int fd,fd_set *set) 判断文件描述符fd是否在set集合中( FD_ISSET() tests to see if a file descriptor is part of the set;)</span><br><span class="line"></span><br><span class="line">  __FD_SETSIZE 系统定义的宏,表示文件描述符最多个数,一般是<span class="number">1024</span>,也可以不加前面两个下划线即FD_SETSIZE</span><br><span class="line"></span><br><span class="line">使用过程:</span><br><span class="line"></span><br><span class="line">fd_set fsRead,fsRead2;           <span class="comment">//集合</span></span><br><span class="line"><span class="keyword">int</span> Maxfd;               <span class="comment">//最大描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tmot</span>;</span>     <span class="comment">//超时时间</span></span><br><span class="line"><span class="keyword">int</span> countFd;             <span class="comment">//select返回值,(满足条件的描述符个数)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FD_ZERO(&amp;fsRead);         <span class="comment">//清空集合</span></span><br><span class="line">FD_SET(listenfd,&amp;fsRead); <span class="comment">//将监听套接字放在集合中</span></span><br><span class="line">Maxfd = listenfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//备份</span></span><br><span class="line">	fsRead2 = fsRead;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置超时时间</span></span><br><span class="line">	tmot.tv_sec = <span class="number">0</span>;      <span class="comment">//秒          </span></span><br><span class="line">	tmot.tv_usec = <span class="number">200000</span>; <span class="comment">//微秒</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//select函数</span></span><br><span class="line">	countFD = select(maxFD + <span class="number">1</span>, &amp;fsRead2, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tmot);   <span class="comment">//返回值:   返回发生事件的套接字的个数</span></span><br><span class="line">	<span class="keyword">if</span>(countFD == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"select() error : %d -&gt; %s\n"</span>, errno, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(countFD == <span class="number">0</span>) &#123; <span class="comment">/* 无就绪描述符,输出超时 */</span></span><br><span class="line">        <span class="comment">//time out</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"select() timeout\n"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; maxFD + <span class="number">1</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(k, &amp;fsRead2))   <span class="comment">/* 判断k是否在集合fsRead2中 */</span></span><br><span class="line">            &#123;</span><br><span class="line">				<span class="keyword">if</span>(k == listenfd)&#123;</span><br><span class="line">					<span class="comment">//发生事件的是监听套接字,说明有连接到来</span></span><br><span class="line">					<span class="keyword">int</span> connfd = accept();</span><br><span class="line">					</span><br><span class="line">					<span class="comment">/* 把创建的连接描述符放在集合里 */</span></span><br><span class="line">                	FD_SET(sockC, &amp;fsRead);</span><br><span class="line">                	<span class="keyword">if</span>(sockC &gt; maxFD)&#123;</span><br><span class="line">                		maxFD = sockC;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="comment">//发生事件的是连接套接字,接收发来的消息,并回复</span></span><br><span class="line">					recv();  </span><br><span class="line">					send();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="winsock编程"><a href="#winsock编程" class="headerlink" title="winsock编程"></a>winsock编程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）准备WinSock环境</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  WSAStartup（WORD wVersionRequested， LPWSADATA  lpWSAData）</span><br><span class="line"></span><br><span class="line">a）参数<span class="number">1</span>：为期待的版本，可以使用MAKEWORD（x，y）来指定版本，其中x为主版本，占据低字节，y为次版本，占据高字节，目前均使用<span class="number">2.0</span>以上版本，常用<span class="number">2.2</span>；</span><br><span class="line"></span><br><span class="line">b）参数<span class="number">2</span>：指向一个WSADATA结构体，用于填充返回相关信息</span><br><span class="line"></span><br><span class="line">c）返回值：操作成功，返回<span class="number">0</span>，否则返回错误代码。注意，在WinSock执行环境未准备好时，不能调用WSAGetLastError（）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）清除WinSock环境</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> WSACleanup（<span class="keyword">void</span>）</span><br><span class="line"></span><br><span class="line">若成功返回<span class="number">0</span>，否则返回SOCKET_ERROR。一般不会出错。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）获取错误</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  WSAGetLastError（<span class="keyword">void</span>）</span><br><span class="line"></span><br><span class="line">返回当前线程上次WinSock操作失败时的具体错误代码。大部分WinSock错误代码以WSAE作为前辍</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）设置I/O模式</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  ioctlsocket（SOCKET  s，<span class="keyword">long</span>  cmd，u_long  FAR  *argp）</span><br><span class="line"></span><br><span class="line">a）s为指定套接字</span><br><span class="line"></span><br><span class="line">b）cmd为要执行的命令</span><br><span class="line"></span><br><span class="line">c）argp指向命令需要的参数</span><br><span class="line"></span><br><span class="line">d）返回值：操作成功返回<span class="number">0</span>，否则返回SOCKET_ERROR</span><br><span class="line"></span><br><span class="line">e）设置为非阻塞模式时，cmd为FIONBIO，argp指向值为非<span class="number">0</span>的整型变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）关闭套接字</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  closesocket（SOCKET  s）</span><br><span class="line"></span><br><span class="line">若操作成功返回<span class="number">0</span>，否则返回SOCKET_ERROR。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"ws2_32"</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">WSADATA</span> <span class="title">wsd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> code = WSAStartup(<span class="number">0x0202</span>,&amp;wsd);    <span class="comment">//0x0202表示版本</span></span><br><span class="line">	<span class="keyword">if</span>(code != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"WSAStartup error: %d"</span>,code);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	其他与Linux一样</span><br><span class="line"></span><br><span class="line">	closesocket(sockfd);</span><br><span class="line">	</span><br><span class="line">	WSACleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">头文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">strstr</span>(str,<span class="string">"hello"</span>);    在字符串str中找到hello字符串返回hello字符串,找不到返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strchr</span>(str,<span class="string">'\n'</span>);       在字符串str中寻找回车符</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcmp</span>(str,<span class="string">"hello"</span>);    如果str字符串与<span class="string">"hello"</span>字符串相等,那么返回<span class="number">0</span>,其他返回值不常用</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(str,<span class="string">"hello"</span>);    在字符串str后面拼接上hello字符</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(str,<span class="string">"hello"</span>);    把字符串hello拷贝给str,str原来的值被覆盖</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">指针,指针也是处理字符串很好用的方式</span><br><span class="line"></span><br><span class="line">例如:分割http请求第一行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /index.html HTTP/<span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">首先提取出http请求的第一行</span><br><span class="line"></span><br><span class="line">假设整个请求存在request数组里</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p = request;</span><br><span class="line"><span class="keyword">char</span> *q = <span class="built_in">strchr</span>(request,<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">指针p和q之间就是这一行数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> method[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">char</span> uri[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">char</span> version[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">Split(&amp;p,q,method);   分离出方法</span><br><span class="line">Split(&amp;p,q,uri);</span><br><span class="line">Split(&amp;p,q,version);</span><br><span class="line"></span><br><span class="line">最终结果: </span><br><span class="line">method 存放  GET</span><br><span class="line">uri 存放/index.html</span><br><span class="line">version存放HTTP/<span class="number">1.1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">char</span> **p,<span class="keyword">char</span> *q,<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>((*p) != q) &#123;</span><br><span class="line">        <span class="keyword">if</span>( (**p) == <span class="string">' '</span> ) &#123;</span><br><span class="line">            (*p)++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *(s++) = *((*p)++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><p>listen backlog作用</p>
<p>recv 返回值</p>
<p><strong>epoll使用过程</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include <span class="tag">&lt;<span class="name">sys</span>/<span class="attr">epoll.h</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2）创建epoll实例</span><br><span class="line"></span><br><span class="line">int epoll_create（int size）</span><br><span class="line"></span><br><span class="line">epoll模型由内核管理，需要向内核申请创建实例。参数size为实例大小，可以理解为所管理描述符的数量。在Linux 2.6.8以后，size会由系统自动调整，该参数仅仅为保持兼容而存在。</span><br><span class="line"></span><br><span class="line">若操作成功，会返回引用该实例的描述符，否则返回-1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3）注册描述符及事件</span><br><span class="line"></span><br><span class="line">int epoll_ctl（int epfd, int op, int fd, struct epoll_event *event）</span><br><span class="line"></span><br><span class="line">epoll模型将管理若干描</span><br><span class="line">述符及关心的事件（与select作用类似），这些管理功能均通过该函数表示。操作成功，返回0，否则返回-1。各参数含义：</span><br><span class="line"></span><br><span class="line">a）epfd为epoll实例描述符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b）fd为要管理的描述符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c）event为该描述符上关心的事件，类型为结构体类型：</span><br><span class="line"></span><br><span class="line">struct epoll_event&#123;</span><br><span class="line"></span><br><span class="line">　　__uint32_t     events;  </span><br><span class="line"></span><br><span class="line">　　epoll_data_t  data;</span><br><span class="line"></span><br><span class="line">｝；</span><br><span class="line"></span><br><span class="line">events是由以下事件标志通过 | 运算得到的组合</span><br><span class="line"></span><br><span class="line">EPOLLIN：可读数据（有数据到达）</span><br><span class="line"></span><br><span class="line">EPOLLOUT：可写数据（可发送给对方）</span><br><span class="line"></span><br><span class="line">EPOLLPRI：对于流式套接字，收到了OOB数据</span><br><span class="line"></span><br><span class="line">EPOLLRDHUP：对方调用了close()或shutdown()，在ET模式下很有用</span><br><span class="line"></span><br><span class="line">EPOLLERR：发生错误的情况</span><br><span class="line"></span><br><span class="line">EPOLLET：启用ET（Edge Triggered，边缘触发，状态发生变化）模式，默认模式为LT（Level Triggered，条件或水平触发，状态不变，但总满足“操作就绪”的要求）</span><br><span class="line"></span><br><span class="line">EPOLLONESHOT：只使用一次，单独使用无意义</span><br><span class="line"></span><br><span class="line">除上述标志以外，Linux的不同版本还增加了其它事件标志。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data成员表示事件对应的数据，其定义为：</span><br><span class="line"></span><br><span class="line">typedef union epoll_data&#123;</span><br><span class="line"></span><br><span class="line">　　void           *ptr;</span><br><span class="line"></span><br><span class="line">　　int              fd;</span><br><span class="line"></span><br><span class="line">　　__uint32_t  u32;</span><br><span class="line"></span><br><span class="line">　　__uint64_t  u64;</span><br><span class="line"></span><br><span class="line">｝epoll_data_t；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d）op表示要执行的管理操作，有三个：EPOLL_CTL_XXX，其中XXX是ADD、DEL、MOD三者之一，分别表示新注册、删除已有、修改已有</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4）进行监控</span><br><span class="line"></span><br><span class="line">int epoll_wait（int epfd, struct epoll_event *events, int maxevents, int timeout）</span><br><span class="line"></span><br><span class="line">执行完成后，若有描述符上期待的事件发生，返回描述数个数；若超时，返回0；若出错，返回-1。参数含义为：</span><br><span class="line"></span><br><span class="line">a）epfd，epoll实例的描述符</span><br><span class="line"></span><br><span class="line">b）events，用户动态申请的内存空间，用于存放产生事件的描述符等信息，若有n个描述符上产生了期待的事件，这n个描述符的相关信息存放在events的前n个元素中</span><br><span class="line"></span><br><span class="line">c）maxevents，events空间大小</span><br><span class="line"></span><br><span class="line">d）timeout，该参数与select模型中的不同，它以毫秒为单位设置时间间隔。若为0，调用会立即返回；若为-1，则无限期等待，直至出错或有描述符发生事件；若为其它值，则会等待指定的时间间隔，在此时间内，若有事件发生，会返回，否则会等到超时再返回。该参数设置会影响性能</span><br></pre></td></tr></table></figure>


<hr>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">一、数据报套接字的两种通信模式</span><br><span class="line"></span><br><span class="line">1、客户机/服务器模式</span><br><span class="line"></span><br><span class="line">也可称为主从模式，服务器不主动向客户机发送数据，而是处于等待状态，客户机主动发起数据通信的过程，类似于流式套接字的工作模式。</span><br><span class="line"></span><br><span class="line">在该模式中，服务器需要绑定操作，客户机不需要。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、对等模式</span><br><span class="line"></span><br><span class="line">既向不特定主机发送信息，也接收不特定主机发送来的信息。</span><br><span class="line"></span><br><span class="line">在该模式中，参与通信方均需要绑定操作。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2、epoll模型</span><br><span class="line"></span><br><span class="line">1）epoll是Linux上的高性能I/O模型。Kqueue是FreeBSD系统中的模型，Windows是IOCP模型。</span><br><span class="line"></span><br><span class="line">2）下图中体现select与epoll模型性能的差异，很明显，当连接数量较大时，select模型的性能明显下降，epoll模型的性能比较稳定，不会随着管理描述数量的增加出现明显性能下降的情况。</span><br><span class="line"></span><br><span class="line">3）epoll适用于连接数量较多，但活动连接数量相对较少的情况。</span><br></pre></td></tr></table></figure>


<hr>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1、WSAAsyncSelect概述</span><br><span class="line"></span><br><span class="line">1）当协议栈检测到某个套接字上有数据到达（事件）时，便会向该套接字所属应用发送通知消息，应用收到消息后再进行处理。这种方式使用起来非常自然，也符合Windows系统的特性，即事件（套接字状态变化） -&gt; 消息传递（向应用发送消息） -&gt; 响应（应用程序处理）。</span><br><span class="line"></span><br><span class="line">2）WSAAsyncSelect是另一种I/O复用模型，非常适合GUI界面的应用。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">3、select模型</span><br><span class="line"></span><br><span class="line">1）该关注的套接字（描述符）存储在fd_set集合中，select模型会监控一段时间内集合中所有有效的套接字是否“操作就绪”，若是会保留下来，否则会将该套接字移出集合，对于仍然存在于集合中的套接字，可以直接进行相应的操作，而不必再花时间等待。</span><br><span class="line"></span><br><span class="line">2）对套接字的关注只有三种类型：数据是否可读？数据是否可写？是否发生错误？为方便，模型按感兴趣的类型将套接字集合分为三种，某个套接字可以只加入一个集合，也可以同时加入多个集合。</span><br></pre></td></tr></table></figure>


<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TIME_WAIT出现的原因</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
